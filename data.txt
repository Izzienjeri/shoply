# Extracted Python Code
# Date and Time: 2025-05-04 06:42:51
# Files Included: 17

# === ./server/seed.py ===
import os
import random
from decimal import Decimal
from faker import Faker
from app import create_app, db
from app.models import User, Artist, Artwork, Cart, CartItem, Order, OrderItem

NUM_ARTISTS = 10
NUM_USERS = 5
ARTWORK_IMAGE_FOLDER_RELATIVE = 'artwork_images'
IMAGES_BASE_NAME = 'art'
NUM_IMAGES = 48
DEFAULT_PASSWORD = "pass123"

try:
    fake = Faker()
except ImportError:
    print("Faker not installed. Using basic placeholder data. (pip install Faker)")
    fake = None

def get_image_path(image_index):
    """Constructs the relative path for the image URL field."""
    return f"{ARTWORK_IMAGE_FOLDER_RELATIVE}/{IMAGES_BASE_NAME}{image_index}.jpg"

def clear_data():
    """Clears existing data from tables in reverse dependency order."""
    print("Clearing existing data...")
    db.session.query(OrderItem).delete()
    db.session.query(CartItem).delete()
    db.session.query(Order).delete()
    db.session.query(Cart).delete()
    db.session.query(Artwork).delete()
    db.session.query(User).delete()
    db.session.query(Artist).delete()
    db.session.commit()
    print("Data cleared.")

def seed_artists(num_artists):
    """Seeds the database with Artist data."""
    print(f"Seeding {num_artists} artists...")
    artists = []
    for i in range(num_artists):
        artist_name = fake.name() if fake else f"Artist {i+1}"
        artist_bio = fake.paragraph(nb_sentences=3) if fake else f"This is the biography for {artist_name}."
        artist = Artist(name=artist_name, bio=artist_bio)
        artists.append(artist)
    db.session.add_all(artists)
    db.session.commit()
    print("Artists seeded.")
    return artists

def seed_artworks(artists, num_images_available, media_folder_base):
    """Seeds the database with Artwork data, linking to artists and images."""
    if not artists:
        print("No artists available to assign artworks to. Skipping artwork seeding.")
        return

    print(f"Seeding artworks (up to {num_images_available} based on image files)...")
    artworks = []
    image_folder_full_path = os.path.join(media_folder_base, ARTWORK_IMAGE_FOLDER_RELATIVE)
    print(f"Checking for images in: {image_folder_full_path}")

    for i in range(1, num_images_available + 1):
        image_filename = f"{IMAGES_BASE_NAME}{i}.jpg"
        image_full_path = os.path.join(image_folder_full_path, image_filename)
        relative_image_url = get_image_path(i)

        if not os.path.exists(image_full_path):
            print(f"Warning: Image file not found: {image_full_path}. Skipping artwork {i}.")
            continue

        artwork_name = fake.catch_phrase() if fake else f"Artwork {i}: {random.choice(['Sunrise', 'Portrait', 'Abstract', 'Landscape'])}"
        description = fake.text(max_nb_chars=200) if fake else f"A beautiful piece numbered {i}."
        price = Decimal(random.uniform(50.0, 1500.0)).quantize(Decimal("0.01"))
        stock_quantity = random.randint(0, 10)
        assigned_artist = random.choice(artists)

        artwork = Artwork(
            name=artwork_name,
            description=description,
            price=price,
            stock_quantity=stock_quantity,
            artist_id=assigned_artist.id,
            image_url=relative_image_url
        )
        artworks.append(artwork)

    if artworks:
        db.session.add_all(artworks)
        db.session.commit()
        print(f"{len(artworks)} artworks seeded.")
    else:
        print("No artworks were seeded (possibly due to missing images or artists).")

def seed_users(num_users):
    """Seeds the database with User data."""
    print(f"Seeding {num_users} users...")
    users = []
    for i in range(num_users):
        user_email = fake.email() if fake else f"user{i+1}@example.com"
        user_name = fake.name() if fake else f"Test User {i+1}"
        user_address = fake.address() if fake else f"{i+1} Seed St, Testville"

        if User.query.filter_by(email=user_email).first():
            print(f"User with email {user_email} already exists, skipping.")
            continue

        user = User(
            email=user_email,
            name=user_name,
            address=user_address
        )
        user.set_password(DEFAULT_PASSWORD)
        users.append(user)

    if users:
        db.session.add_all(users)
        db.session.commit()
        print(f"{len(users)} users seeded (default password: '{DEFAULT_PASSWORD}').")
    else:
        print("No new users were seeded.")
    return users

def run_seed():
    """Main function to run the seeding process."""
    app = create_app()
    with app.app_context():
        media_folder = app.config.get('MEDIA_FOLDER')
        if not media_folder or not os.path.isdir(media_folder):
             print(f"ERROR: MEDIA_FOLDER ('{media_folder}') is not configured correctly or does not exist.")
             print("Ensure MEDIA_FOLDER is set in your Flask app config and the directory exists.")
             return

        clear_data()
        created_artists = seed_artists(NUM_ARTISTS)
        seed_artworks(created_artists, NUM_IMAGES, media_folder)
        seed_users(NUM_USERS)
        print("-" * 20)
        print("Seeding process completed!")
        print("-" * 20)

# === ./server/run.py ===
from app import create_app
from seed import run_seed

app = create_app()

@app.cli.command("seed")
def seed_db():
    """Populates the database with initial data."""
    run_seed()

if __name__ =='__main__':
    app.run(debug=True)

# === ./server/migrations/env.py ===
import logging
from logging.config import fileConfig

from flask import current_app

from alembic import context

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
fileConfig(config.config_file_name)
logger = logging.getLogger('alembic.env')


def get_engine():
    try:
        # this works with Flask-SQLAlchemy<3 and Alchemical
        return current_app.extensions['migrate'].db.get_engine()
    except (TypeError, AttributeError):
        # this works with Flask-SQLAlchemy>=3
        return current_app.extensions['migrate'].db.engine


def get_engine_url():
    try:
        return get_engine().url.render_as_string(hide_password=False).replace(
            '%', '%%')
    except AttributeError:
        return str(get_engine().url).replace('%', '%%')


# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
config.set_main_option('sqlalchemy.url', get_engine_url())
target_db = current_app.extensions['migrate'].db

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def get_metadata():
    if hasattr(target_db, 'metadatas'):
        return target_db.metadatas[None]
    return target_db.metadata


def run_migrations_offline():
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url, target_metadata=get_metadata(), literal_binds=True
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online():
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """

    # this callback is used to prevent an auto-migration from being generated
    # when there are no changes to the schema
    # reference: http://alembic.zzzcomputing.com/en/latest/cookbook.html
    def process_revision_directives(context, revision, directives):
        if getattr(config.cmd_opts, 'autogenerate', False):
            script = directives[0]
            if script.upgrade_ops.is_empty():
                directives[:] = []
                logger.info('No changes in schema detected.')

    conf_args = current_app.extensions['migrate'].configure_args
    if conf_args.get("process_revision_directives") is None:
        conf_args["process_revision_directives"] = process_revision_directives

    connectable = get_engine()

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=get_metadata(),
            **conf_args
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

# === ./server/migrations/versions/7a98d245193e_add_artist_model_rename_product_to_.py ===
"""Add Artist model, rename Product to Artwork, establish relationships

Revision ID: 7a98d245193e
Revises: 
Create Date: 2025-05-04 04:43:31.344868

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import mysql

# revision identifiers, used by Alembic.
revision = '7a98d245193e'
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('artists',
    sa.Column('id', sa.String(length=36), nullable=False),
    sa.Column('name', sa.String(length=150), nullable=False),
    sa.Column('bio', sa.Text(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('users',
    sa.Column('id', sa.String(length=36), nullable=False),
    sa.Column('email', sa.String(length=120), nullable=False),
    sa.Column('password_hash', sa.String(length=128), nullable=False),
    sa.Column('name', sa.String(length=100), nullable=True),
    sa.Column('address', sa.Text(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('email')
    )
    op.create_table('artworks',
    sa.Column('id', sa.String(length=36), nullable=False),
    sa.Column('name', sa.String(length=255), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('price', mysql.DECIMAL(precision=10, scale=2), nullable=False),
    sa.Column('stock_quantity', sa.Integer(), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.Column('image_url', sa.String(length=255), nullable=True),
    sa.Column('artist_id', sa.String(length=36), nullable=False),
    sa.ForeignKeyConstraint(['artist_id'], ['artists.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('carts',
    sa.Column('id', sa.String(length=36), nullable=False),
    sa.Column('user_id', sa.String(length=36), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('user_id')
    )
    op.create_table('orders',
    sa.Column('id', sa.String(length=36), nullable=False),
    sa.Column('user_id', sa.String(length=36), nullable=False),
    sa.Column('total_price', mysql.DECIMAL(precision=10, scale=2), nullable=False),
    sa.Column('status', sa.String(length=50), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.Column('shipped_at', sa.DateTime(), nullable=True),
    sa.Column('shipping_address', sa.Text(), nullable=True),
    sa.Column('billing_address', sa.Text(), nullable=True),
    sa.Column('payment_gateway_ref', sa.String(length=255), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('cart_items',
    sa.Column('id', sa.String(length=36), nullable=False),
    sa.Column('cart_id', sa.String(length=36), nullable=False),
    sa.Column('artwork_id', sa.String(length=36), nullable=False),
    sa.Column('quantity', sa.Integer(), nullable=False),
    sa.ForeignKeyConstraint(['artwork_id'], ['artworks.id'], ),
    sa.ForeignKeyConstraint(['cart_id'], ['carts.id'], ),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('cart_id', 'artwork_id', name='_cart_artwork_uc')
    )
    op.create_table('order_items',
    sa.Column('id', sa.String(length=36), nullable=False),
    sa.Column('order_id', sa.String(length=36), nullable=False),
    sa.Column('artwork_id', sa.String(length=36), nullable=False),
    sa.Column('quantity', sa.Integer(), nullable=False),
    sa.Column('price_at_purchase', mysql.DECIMAL(precision=10, scale=2), nullable=False),
    sa.ForeignKeyConstraint(['artwork_id'], ['artworks.id'], ),
    sa.ForeignKeyConstraint(['order_id'], ['orders.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('order_items')
    op.drop_table('cart_items')
    op.drop_table('orders')
    op.drop_table('carts')
    op.drop_table('artworks')
    op.drop_table('users')
    op.drop_table('artists')
    # ### end Alembic commands ###

# === ./server/app/schemas.py ===
from marshmallow import fields, validate, post_dump, exceptions as marshmallow_exceptions
from flask import url_for, current_app

from . import ma, db
from .models import User, Artist, Artwork, Cart, CartItem, Order, OrderItem
from decimal import Decimal, InvalidOperation


class UserSchema(ma.SQLAlchemyAutoSchema):
    password = fields.Str(required=True, load_only=True, validate=validate.Length(min=8))
    email = fields.Email(required=True)
    name = fields.Str()
    address = fields.Str()

    class Meta:
        model = User
        load_instance = True
        exclude = ('password_hash',)
        sqla_session = db.session

class ArtistSchema(ma.SQLAlchemyAutoSchema):
    name = fields.Str(required=True)
    bio = fields.Str()

    class Meta:
        model = Artist
        load_instance = True
        sqla_session = db.session


class ArtworkSchema(ma.SQLAlchemyAutoSchema):
    price = fields.Decimal(as_string=True, required=True, validate=validate.Range(min=0))
    stock_quantity = fields.Int(validate=validate.Range(min=0))
    image_url = fields.String(dump_only=True, required=False, allow_none=True)

    artist = fields.Nested(ArtistSchema, only=('id', 'name'), dump_only=True)
    artist_id = fields.Str(required=True, load_only=True)

    class Meta:
        model = Artwork
        load_instance = True
        sqla_session = db.session

    @post_dump
    def make_image_url_absolute(self, data, **kwargs):
        """Converts the stored relative image path to an absolute URL after dumping."""
        relative_path = data.get('image_url')
        if relative_path:
            try:
                with current_app.app_context():
                     absolute_url = url_for('serve_media', filename=relative_path, _external=True)
                data['image_url'] = absolute_url
            except RuntimeError as e:
                current_app.logger.error(f"Could not generate URL for '{relative_path}'. Is app context available? Error: {e}", exc_info=True)
                data['image_url'] = None
            except Exception as e:
                current_app.logger.error(f"Unexpected error generating URL for '{relative_path}': {e}", exc_info=True)
                data['image_url'] = None
        else:
            data['image_url'] = None
        return data

class CartItemSchema(ma.SQLAlchemyAutoSchema):
    artwork = fields.Nested(
        ArtworkSchema,
        only=('id', 'name', 'price', 'image_url', 'artist', 'stock_quantity')
    )
    quantity = fields.Int(required=True, validate=validate.Range(min=1))

    class Meta:
        model = CartItem
        load_instance = True
        sqla_session = db.session
        exclude = ('cart_id',)

class CartSchema(ma.SQLAlchemyAutoSchema):
    items = fields.Nested(CartItemSchema, many=True)
    total_price = fields.Method("calculate_total", dump_only=True)

    def calculate_total(self, cart):
        """Calculates the total price of the cart items."""
        total = Decimal('0.00')
        items_iterable = []
        if hasattr(cart, 'items'):
            try:
                items_iterable = cart.items.all() if callable(getattr(cart.items, 'all', None)) else cart.items
            except Exception as e:
                 current_app.logger.warning(f"Could not iterate cart items for cart {cart.id}: {e}")
                 items_iterable = []

        for item in items_iterable:
             if (hasattr(item, 'artwork') and item.artwork and
                 hasattr(item.artwork, 'price') and item.artwork.price is not None and
                 hasattr(item, 'quantity')):
                 try:
                      item_price = Decimal(item.artwork.price)
                      total += item_price * Decimal(item.quantity)
                 except (TypeError, ValueError, InvalidOperation) as e:
                      current_app.logger.warning(f"Could not calculate price for item {getattr(item, 'id', 'N/A')}, artwork {getattr(item.artwork, 'id', 'N/A')}. Price: '{item.artwork.price}', Qty: {item.quantity}. Error: {e}")
                      continue
             else:
                 current_app.logger.warning(f"Artwork data (price/quantity) missing or incomplete for cart item {getattr(item, 'id', 'N/A')} in cart {cart.id}. Cannot calculate total accurately.")

        return str(total)

    class Meta:
        model = Cart
        load_instance = True
        sqla_session = db.session


class OrderItemSchema(ma.SQLAlchemyAutoSchema):
    artwork = fields.Nested(ArtworkSchema, only=('id', 'name', 'image_url', 'artist'))
    price_at_purchase = fields.Decimal(as_string=True, dump_only=True)
    quantity = fields.Int(dump_only=True)

    class Meta:
        model = OrderItem
        load_instance = True
        sqla_session = db.session
        exclude = ('order_id',)

class OrderSchema(ma.SQLAlchemyAutoSchema):
    items = fields.Nested(OrderItemSchema, many=True, dump_only=True)
    total_price = fields.Decimal(as_string=True, dump_only=True)
    status = fields.Str(dump_only=True)
    user_id = fields.String(dump_only=True)
    created_at = fields.DateTime(dump_only=True)
    updated_at = fields.DateTime(dump_only=True)
    shipped_at = fields.DateTime(dump_only=True, allow_none=True)
    shipping_address = fields.Str(dump_only=True, allow_none=True)
    billing_address = fields.Str(dump_only=True, allow_none=True)
    payment_gateway_ref = fields.Str(dump_only=True, allow_none=True)


    class Meta:
        model = Order
        load_instance = True
        sqla_session = db.session


user_schema = UserSchema()
artist_schema = ArtistSchema()
artwork_schema = ArtworkSchema()
cart_schema = CartSchema()
order_schema = OrderSchema()

users_schema = UserSchema(many=True)
artists_schema = ArtistSchema(many=True)
artworks_schema = ArtworkSchema(many=True)
orders_schema = OrderSchema(many=True)

# === ./server/app/models.py ===
import uuid
from datetime import datetime
from sqlalchemy.dialects.mysql import DECIMAL

from . import db, bcrypt

def generate_uuid():
    return str(uuid.uuid4())

class Artist(db.Model):
    __tablename__ = 'artists'

    id = db.Column(db.String(36), primary_key=True, default=generate_uuid)
    name = db.Column(db.String(150), nullable=False)
    bio = db.Column(db.Text, nullable=True)
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)

    artworks = db.relationship('Artwork', back_populates='artist', lazy='dynamic', cascade="all, delete-orphan")

    def __repr__(self):
        return f"<Artist {self.name}>"


class User(db.Model):
    __tablename__ = 'users'

    id = db.Column(db.String(36), primary_key=True, default=generate_uuid)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.String(128), nullable=False)
    name = db.Column(db.String(100), nullable=True)
    address = db.Column(db.Text, nullable=True)
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)

    cart = db.relationship('Cart', back_populates='user', uselist=False, cascade="all, delete-orphan")
    orders = db.relationship('Order', back_populates='user', lazy=True, cascade="all, delete-orphan")

    def set_password(self, password):
        """Hashes the password and stores it."""
        self.password_hash = bcrypt.generate_password_hash(password).decode('utf-8')

    def check_password(self, password):
        """Checks if the provided password matches the stored hash."""
        return bcrypt.check_password_hash(self.password_hash, password)

    def __repr__(self):
        return f"<User {self.email}>"

class Artwork(db.Model):
    __tablename__ = 'artworks'

    id = db.Column(db.String(36), primary_key=True, default=generate_uuid)
    name = db.Column(db.String(255), nullable=False)
    description = db.Column(db.Text, nullable=True)
    price = db.Column(DECIMAL(precision=10, scale=2), nullable=False)
    stock_quantity = db.Column(db.Integer, nullable=False, default=1)
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)
    image_url = db.Column(db.String(255), nullable=True)

    artist_id = db.Column(db.String(36), db.ForeignKey('artists.id'), nullable=False)

    artist = db.relationship('Artist', back_populates='artworks')
    cart_items = db.relationship('CartItem', back_populates='artwork', lazy=True)
    order_items = db.relationship('OrderItem', back_populates='artwork', lazy=True)

    def __repr__(self):
        return f"<Artwork {self.name} by Artist {self.artist_id}>"

class Cart(db.Model):
    __tablename__ = 'carts'

    id = db.Column(db.String(36), primary_key=True, default=generate_uuid)
    user_id = db.Column(db.String(36), db.ForeignKey('users.id'), unique=True, nullable=False)
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)

    user = db.relationship('User', back_populates='cart')
    items = db.relationship('CartItem', back_populates='cart', lazy='dynamic', cascade="all, delete-orphan")

    def __repr__(self):
        return f"<Cart {self.id} for User {self.user_id}>"

class CartItem(db.Model):
    __tablename__ = 'cart_items'

    id = db.Column(db.String(36), primary_key=True, default=generate_uuid)
    cart_id = db.Column(db.String(36), db.ForeignKey('carts.id'), nullable=False)
    artwork_id = db.Column(db.String(36), db.ForeignKey('artworks.id'), nullable=False)
    quantity = db.Column(db.Integer, nullable=False, default=1)

    __table_args__ = (db.UniqueConstraint('cart_id', 'artwork_id', name='_cart_artwork_uc'),)

    cart = db.relationship('Cart', back_populates='items')
    artwork = db.relationship('Artwork', back_populates='cart_items')

    def __repr__(self):
        return f"<CartItem Artwork {self.artwork_id} Qty {self.quantity} in Cart {self.cart_id}>"


class Order(db.Model):
    __tablename__ = 'orders'

    id = db.Column(db.String(36), primary_key=True, default=generate_uuid)
    user_id = db.Column(db.String(36), db.ForeignKey('users.id'), nullable=False)
    total_price = db.Column(DECIMAL(precision=10, scale=2), nullable=False)
    status = db.Column(db.String(50), nullable=False, default='pending')
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)
    shipped_at = db.Column(db.DateTime, nullable=True)
    shipping_address = db.Column(db.Text, nullable=True)
    billing_address = db.Column(db.Text, nullable=True)
    payment_gateway_ref = db.Column(db.String(255), nullable=True)

    user = db.relationship('User', back_populates='orders')
    items = db.relationship('OrderItem', back_populates='order', cascade="all, delete-orphan")

    def __repr__(self):
        return f"<Order {self.id} Status {self.status} by User {self.user_id}>"

class OrderItem(db.Model):
    __tablename__ = 'order_items'

    id = db.Column(db.String(36), primary_key=True, default=generate_uuid)
    order_id = db.Column(db.String(36), db.ForeignKey('orders.id'), nullable=False)
    artwork_id = db.Column(db.String(36), db.ForeignKey('artworks.id'), nullable=False)
    quantity = db.Column(db.Integer, nullable=False)
    price_at_purchase = db.Column(DECIMAL(precision=10, scale=2), nullable=False)

    order = db.relationship('Order', back_populates='items')
    artwork = db.relationship('Artwork', back_populates='order_items')

    def __repr__(self):
        return f"<OrderItem Artwork {self.artwork_id} Qty {self.quantity} Price {self.price_at_purchase} in Order {self.order_id}>"

# === ./server/app/config.py ===
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    SECRET_KEY = os.getenv('SECRET_KEY')
    JWT_SECRET_KEY = os.getenv('JWT_SECRET_KEY')
    SQLALCHEMY_TRACK_MODIFICATIONS = False

    DATABASE_USER = os.getenv('DATABASE_USER')
    DATABASE_PASSWORD = os.getenv('DATABASE_PASSWORD')
    DATABASE_HOST = os.getenv('DATABASE_HOST')
    DATABASE_PORT = os.getenv('DATABASE_PORT')
    DATABASE_NAME = os.getenv('DATABASE_NAME')
    SQLALCHEMY_DATABASE_URI = (
        f"mysql+pymysql://{DATABASE_USER}:{DATABASE_PASSWORD}@{DATABASE_HOST}:{DATABASE_PORT}/{DATABASE_NAME}"
    )

    JWT_BLACKLIST_ENABLED = True
    JWT_BLACKLIST_TOKEN_CHECKS = ['access']

    DARAJA_ENVIRONMENT = os.getenv('DARAJA_ENVIRONMENT', 'sandbox')
    DARAJA_CONSUMER_KEY = os.getenv('DARAJA_CONSUMER_KEY')
    DARAJA_CONSUMER_SECRET = os.getenv('DARAJA_CONSUMER_SECRET')
    DARAJA_SHORTCODE = os.getenv('DARAJA_SHORTCODE')
    DARAJA_PASSKEY = os.getenv('DARAJA_PASSKEY')
    DARAJA_TRANSACTION_TYPE = os.getenv('DARAJA_TRANSACTION_TYPE', 'CustomerPayBillOnline')
    DARAJA_CALLBACK_URL_BASE = os.getenv('DARAJA_CALLBACK_URL_BASE')

    if DARAJA_ENVIRONMENT == 'production':
        DARAJA_AUTH_URL = 'https://api.safaricom.co.ke/oauth/v1/generate?grant_type=client_credentials'
        DARAJA_STK_PUSH_URL = 'https://api.safaricom.co.ke/mpesa/stkpush/v1/processrequest'
    else:
        DARAJA_AUTH_URL = 'https://sandbox.safaricom.co.ke/oauth/v1/generate?grant_type=client_credentials'
        DARAJA_STK_PUSH_URL = 'https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest'

    DARAJA_CALLBACK_URL = f"{DARAJA_CALLBACK_URL_BASE.rstrip('/')}/api/payments/callback"


    if not all([DARAJA_CONSUMER_KEY, DARAJA_CONSUMER_SECRET, DARAJA_SHORTCODE, DARAJA_PASSKEY, DARAJA_CALLBACK_URL_BASE]):
        print("WARNING: Essential Daraja configuration missing in environment variables!")

# === ./server/app/__init__.py ===
import os
from flask import Flask, jsonify, send_from_directory, abort, current_app
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from flask_jwt_extended import JWTManager
from flask_bcrypt import Bcrypt
from flask_marshmallow import Marshmallow
from flask_cors import CORS
from .config import Config

db = SQLAlchemy()
migrate = Migrate()
jwt = JWTManager()
bcrypt = Bcrypt()
ma = Marshmallow()
cors = CORS()

BLOCKLIST = set()

@jwt.token_in_blocklist_loader
def check_if_token_in_blocklist(jwt_header, jwt_payload):
    jti = jwt_payload["jti"]
    return jti in BLOCKLIST


@jwt.unauthorized_loader
def missing_token_callback(error):
    return jsonify({"description": "Request does not contain an access token.", "error": "authorization_required"}), 401

def create_app(config_class=Config):
    app = Flask(__name__)
    app.config.from_object(config_class)

    print(f"DEBUG: Connecting to DB: {app.config['SQLALCHEMY_DATABASE_URI']}")

    MEDIA_FOLDER = os.path.join(app.root_path, '..', 'media')
    app.config['MEDIA_FOLDER'] = MEDIA_FOLDER
    print(f"DEBUG: Media folder (base) set to: {app.config['MEDIA_FOLDER']}")

    db.init_app(app)
    migrate.init_app(app, db)
    jwt.init_app(app)
    bcrypt.init_app(app)
    ma.init_app(app)
    cors.init_app(app, resources={r"/api/*": {"origins": "*"}, r"/media/*": {"origins": "*"}})

    from . import models

    @app.route('/media/<path:filename>')
    def serve_media(filename):
        """
        Serves files from the MEDIA_FOLDER.
        Example: /media/artwork_images/art1.jpg will serve file from ./server/media/artwork_images/art1.jpg
        """
        print(f"Attempting to serve media file: {filename}")
        media_folder = current_app.config.get('MEDIA_FOLDER')
        if not media_folder:
             print("ERROR: MEDIA_FOLDER not configured in Flask app.")
             abort(500)
        try:
            return send_from_directory(media_folder, filename)
        except FileNotFoundError:
            full_path = os.path.join(media_folder, filename)
            print(f"ERROR: File not found: {full_path}")
            abort(404)
        except Exception as e:
             print(f"ERROR: Unexpected error serving file {filename}: {e}")
             abort(500)


    from .resources.auth import auth_bp
    from .resources.artwork import artwork_bp
    from .resources.artist import artist_bp
    from .resources.cart import cart_bp
    from .resources.order import order_bp
    from .resources.payment import payment_bp

    app.register_blueprint(auth_bp, url_prefix='/api/auth')
    app.register_blueprint(artwork_bp, url_prefix='/api/artworks')
    app.register_blueprint(artist_bp, url_prefix='/api/artists')
    app.register_blueprint(cart_bp, url_prefix='/api/cart')
    app.register_blueprint(order_bp, url_prefix='/api/orders')
    app.register_blueprint(payment_bp, url_prefix='/api/payments')


    @app.route('/')
    def index():
        return "Shoply Artwork Backend is running!"

    return app

# === ./server/app/resources/cart.py ===
from flask import request, Blueprint, jsonify
from flask_restful import Resource, Api, abort
from marshmallow import ValidationError, fields
from sqlalchemy.orm import joinedload

from .. import db, ma
from ..models import Cart, CartItem, Artwork, User
from ..schemas import cart_schema

from flask_jwt_extended import jwt_required, get_jwt_identity

cart_bp = Blueprint('cart', __name__)
cart_api = Api(cart_bp)

def get_or_create_cart(user_id):
    """Finds the user's cart or creates one if it doesn't exist."""
    user = User.query.get(user_id)
    if not user:
        abort(404, message="User not found.")

    cart = Cart.query.options(
        joinedload(Cart.items).options(
            joinedload(CartItem.artwork).joinedload(Artwork.artist)
        )
    ).filter_by(user_id=user_id).first()

    if not cart:
        cart = Cart(user_id=user_id)
        db.session.add(cart)
        try:
            db.session.commit()
        except Exception as e:
            db.session.rollback()
            print(f"Error creating new cart: {e}")
            abort(500, message="Could not create cart.")
        cart = Cart.query.options(
            joinedload(Cart.items).options(
                joinedload(CartItem.artwork).joinedload(Artwork.artist)
            )
        ).filter_by(user_id=user_id).first()

    return cart

class AddToCartSchema(ma.Schema):
    artwork_id = fields.Str(required=True)
    quantity = fields.Int(required=True, validate=lambda q: q > 0)

add_to_cart_schema = AddToCartSchema()


class CartResource(Resource):
    @jwt_required()
    def get(self):
        """
        Fetches the current user's cart contents, including artwork and artist details.
        """
        user_id = get_jwt_identity()
        cart = get_or_create_cart(user_id)

        return cart_schema.dump(cart), 200

    @jwt_required()
    def post(self):
        """
        Adds an artwork to the current user's cart or updates its quantity.
        """
        user_id = get_jwt_identity()
        json_data = request.get_json()
        if not json_data:
            abort(400, message="No input data provided")

        try:
            data = add_to_cart_schema.load(json_data)
        except ValidationError as err:
            abort(400, message=err.messages)

        artwork_id = data['artwork_id']
        quantity_to_add = data['quantity']

        cart = get_or_create_cart(user_id)
        if cart.id is None:
            abort(500, message="Failed to retrieve or initialize cart.")

        artwork = Artwork.query.get(artwork_id)

        if not artwork:
            abort(404, message=f"Artwork with ID {artwork_id} not found.")

        if artwork.stock_quantity < quantity_to_add:
             abort(400, message=f"Insufficient stock for Artwork ID {artwork_id}. Available: {artwork.stock_quantity}")

        cart_item = next((item for item in cart.items if item.artwork_id == artwork_id), None)
        if cart_item is None:
             cart_item = CartItem.query.filter_by(cart_id=cart.id, artwork_id=artwork_id).first()


        if cart_item:
            new_quantity = cart_item.quantity + quantity_to_add
            if artwork.stock_quantity < new_quantity:
                 abort(400, message=f"Insufficient stock to increase quantity for Artwork ID {artwork_id}. Available: {artwork.stock_quantity}, In Cart: {cart_item.quantity}")
            cart_item.quantity = new_quantity
        else:
            cart_item = CartItem(cart_id=cart.id, artwork_id=artwork_id, quantity=quantity_to_add)
            db.session.add(cart_item)

        try:
            db.session.commit()
            cart_updated = Cart.query.options(
                 joinedload(Cart.items).options(
                     joinedload(CartItem.artwork).joinedload(Artwork.artist)
                 )
            ).get(cart.id)
            return cart_schema.dump(cart_updated), 200
        except Exception as e:
            db.session.rollback()
            print(f"Error committing cart changes: {e}")
            if "UniqueViolation" in str(e) or "_cart_artwork_uc" in str(e):
                 abort(409, message="Item already exists in cart or concurrent modification error.")
            abort(500, message="An error occurred while updating the cart.")


class CartItemResource(Resource):

    @jwt_required()
    def put(self, item_id):
        """
        Updates the quantity of a specific item in the cart.
        """
        user_id = get_jwt_identity()
        cart = get_or_create_cart(user_id)

        json_data = request.get_json()
        if not json_data or 'quantity' not in json_data:
             abort(400, message="Quantity is required.")

        try:
            new_quantity = int(json_data['quantity'])
            if new_quantity <= 0:
                abort(400, message="Quantity must be positive. Use DELETE to remove item.")
        except ValueError:
            abort(400, message="Quantity must be an integer.")

        cart_item = CartItem.query.filter_by(id=item_id, cart_id=cart.id).first()
        if not cart_item:
            abort(404, message=f"Cart item with ID {item_id} not found in your cart.")

        artwork = Artwork.query.get(cart_item.artwork_id)
        if not artwork:
             abort(404, message=f"Artwork associated with cart item not found.")

        if artwork.stock_quantity < new_quantity:
            abort(400, message=f"Insufficient stock for Artwork ID {artwork.id}. Available: {artwork.stock_quantity}")

        cart_item.quantity = new_quantity

        try:
            db.session.commit()
            cart_updated = Cart.query.options(
                 joinedload(Cart.items).options(
                     joinedload(CartItem.artwork).joinedload(Artwork.artist)
                 )
            ).get(cart.id)
            return cart_schema.dump(cart_updated), 200
        except Exception as e:
            db.session.rollback()
            print(f"Error updating cart item: {e}")
            abort(500, message="An error occurred while updating the cart item.")


    @jwt_required()
    def delete(self, item_id):
        """
        Removes a specific item from the cart.
        """
        user_id = get_jwt_identity()
        cart = get_or_create_cart(user_id)

        cart_item = CartItem.query.filter_by(id=item_id, cart_id=cart.id).first()
        if not cart_item:
            abort(404, message=f"Cart item with ID {item_id} not found in your cart.")

        try:
            db.session.delete(cart_item)
            db.session.commit()
            cart_updated = Cart.query.options(
                 joinedload(Cart.items).options(
                     joinedload(CartItem.artwork).joinedload(Artwork.artist)
                 )
            ).get(cart.id)
            return cart_schema.dump(cart_updated), 200
        except Exception as e:
            db.session.rollback()
            print(f"Error deleting cart item: {e}")
            abort(500, message="An error occurred while removing the item from the cart.")


cart_api.add_resource(CartResource, '/')
cart_api.add_resource(CartItemResource, '/items/<string:item_id>')

# === ./server/app/resources/artist.py ===
from flask import request, Blueprint, jsonify
from flask_restful import Resource, Api, abort
from marshmallow import ValidationError
from sqlalchemy.orm import joinedload

from .. import db
from ..models import Artist, Artwork
from ..schemas import artist_schema, artists_schema


artist_bp = Blueprint('artists', __name__)
artist_api = Api(artist_bp)

class ArtistList(Resource):
    def get(self):
        """
        Fetches all artists.
        """
        artists = Artist.query.order_by(Artist.name).all()
        return artists_schema.dump(artists), 200

    def post(self):
        """
        Creates a new artist.
        """

        json_data = request.get_json()
        if not json_data:
            return {"message": "No input data provided"}, 400

        try:
            new_artist = artist_schema.load(json_data, session=db.session)
        except ValidationError as err:
            return {"message": "Validation errors", "errors": err.messages}, 400
        except Exception as e:
            print(f"Unexpected error during artist schema load: {e}")
            abort(500, message="An internal error occurred during data processing.")


        try:
            db.session.add(new_artist)
            db.session.commit()
            return artist_schema.dump(new_artist), 201
        except Exception as e:
            db.session.rollback()
            print(f"Error creating artist in DB: {e}")
            abort(500, message="An error occurred while saving the artist.")

class ArtistDetail(Resource):
    def get(self, artist_id):
        """
        Fetches a single artist by UUID, including their artworks.
        """
        artist = Artist.query.options(
            joinedload(Artist.artworks)
        ).get_or_404(artist_id, description=f"Artist with ID {artist_id} not found.")

        return artist_schema.dump(artist), 200

    def patch(self, artist_id):
        """
        Updates an existing artist partially.
        """

        artist = Artist.query.get_or_404(artist_id, description=f"Artist with ID {artist_id} not found.")

        json_data = request.get_json()
        if not json_data:
            return {"message": "No input data provided"}, 400

        try:
            updated_artist = artist_schema.load(
                json_data,
                instance=artist,
                partial=True,
                session=db.session
            )
        except ValidationError as err:
            return {"message": "Validation errors", "errors": err.messages}, 400

        try:
            db.session.commit()
            return artist_schema.dump(updated_artist), 200
        except Exception as e:
            db.session.rollback()
            print(f"Error updating artist {artist_id}: {e}")
            abort(500, message="An error occurred while updating the artist.")

    def delete(self, artist_id):
        """
        Deletes an artist by UUID.
        Note: This will likely cascade delete associated artworks due to relationship setting.
        Consider consequences before enabling direct artist deletion.
        """

        artist = Artist.query.get_or_404(artist_id, description=f"Artist with ID {artist_id} not found.")


        try:
            db.session.delete(artist)
            db.session.commit()
            return '', 204
        except Exception as e:
            db.session.rollback()
            print(f"Error deleting artist {artist_id}: {e}")
            abort(500, message="An error occurred while deleting the artist.")


artist_api.add_resource(ArtistList, '/')
artist_api.add_resource(ArtistDetail, '/<string:artist_id>')

# === ./server/app/resources/order.py ===
from flask import request, Blueprint, jsonify
from flask_restful import Resource, Api, abort
from marshmallow import fields, Schema, ValidationError
from sqlalchemy.orm import joinedload
from decimal import Decimal

from .. import db, ma
from ..models import Order, OrderItem, User, Cart, Artwork, CartItem, Artist
from ..schemas import order_schema, orders_schema, artwork_schema

from flask_jwt_extended import jwt_required, get_jwt_identity
from ..utils.daraja_client import initiate_stk_push

order_bp = Blueprint('orders', __name__)
order_api = Api(order_bp)

pending_checkouts = {}

class CheckoutInputSchema(ma.Schema):
    phone_number = fields.Str(required=True, validate=lambda p: p.startswith('254') and len(p) == 12 and p.isdigit())

checkout_input_schema = CheckoutInputSchema()

class OrderList(Resource):
    @jwt_required()
    def get(self):
        """Fetches the current user's past orders, including artwork details."""
        user_id = get_jwt_identity()
        user_orders = Order.query.options(
            joinedload(Order.items).options(
                joinedload(OrderItem.artwork).joinedload(Artwork.artist)
            )
        ).filter_by(user_id=user_id).order_by(Order.created_at.desc()).all()
        return orders_schema.dump(user_orders), 200

    @jwt_required()
    def post(self):
        """
        Initiates the checkout process (triggers STK Push).
        Validates cart items (artwork stock) before proceeding.
        Does NOT create the order directly. This happens in the callback.
        """
        user_id = get_jwt_identity()

        json_data = request.get_json()
        if not json_data:
             abort(400, message="Missing checkout data (e.g., phone_number).")
        try:
            checkout_data = checkout_input_schema.load(json_data)
        except ValidationError as err:
            abort(400, message=err.messages)

        phone_number = checkout_data['phone_number']

        cart = Cart.query.filter_by(user_id=user_id).first()

        if cart:
            cart_items_with_artworks = CartItem.query.options(
                joinedload(CartItem.artwork)
            ).filter_by(cart_id=cart.id).all()
        else:
             cart_items_with_artworks = []


        if not cart or not cart_items_with_artworks:
            abort(400, message="Your cart is empty.")

        total_price = Decimal('0.0')
        item_details_for_pending = []

        for item in cart_items_with_artworks:
            if not item.artwork:
                 print(f"ERROR: Artwork data missing for cart item {item.id}. Cart ID: {cart.id}")
                 abort(500, message=f"Artwork data missing for an item in your cart.")

            if item.artwork.stock_quantity < item.quantity:
                abort(400, message=f"Insufficient stock for '{item.artwork.name}'. Available: {item.artwork.stock_quantity}")

            total_price += Decimal(item.artwork.price) * Decimal(item.quantity)
            item_details_for_pending.append({
                'artwork_id': item.artwork_id,
                'quantity': item.quantity,
                'price_at_purchase': float(item.artwork.price)
            })

        if total_price <= 0:
            abort(400, message="Cart total must be positive.")

        account_ref = f"CART_{cart.id[:8]}"
        amount = float(total_price)

        stk_response, status_code = initiate_stk_push(
            phone_number=phone_number,
            amount=amount,
            order_id=account_ref,
            description=f"Payment for Shoply Cart {cart.id[:8]}"
        )

        if status_code >= 400 or stk_response.get("ResponseCode", "1") != "0":
            error_msg = stk_response.get("errorMessage", "Failed to initiate STK push.")
            error_msg = stk_response.get("ResponseDescription", error_msg)
            print(f"STK Push Initiation Failed: Code {stk_response.get('ResponseCode', 'N/A')}, Desc: {error_msg}")
            abort(status_code if status_code >= 400 else 500, message=error_msg)

        checkout_request_id = stk_response.get('CheckoutRequestID')
        if not checkout_request_id:
             print("ERROR: STK Push initiated but CheckoutRequestID was missing in Daraja response.")
             abort(500, message="STK Push initiated but CheckoutRequestID was missing in response.")

        pending_checkouts[checkout_request_id] = {
            'user_id': user_id,
            'cart_id': cart.id,
            'total_price': float(total_price),
            'items': item_details_for_pending,
            'phone_number': phone_number
        }
        print(f"DEBUG: Stored pending checkout: {checkout_request_id} -> User {user_id}, Cart {cart.id}")

        return {
            "message": "STK Push initiated successfully. Please check your phone to authorize payment.",
            "CheckoutRequestID": checkout_request_id,
            "ResponseDescription": stk_response.get("ResponseDescription", "Success")
        }, 200


class OrderDetail(Resource):
    @jwt_required()
    def get(self, order_id):
        """Fetches details of a specific order belonging to the user, including artwork details."""
        user_id = get_jwt_identity()
        order = Order.query.options(
            joinedload(Order.items).options(
                joinedload(OrderItem.artwork).joinedload(Artwork.artist)
            )
        ).filter_by(id=order_id, user_id=user_id).first_or_404(
            description=f"Order with ID {order_id} not found or does not belong to user."
        )
        return order_schema.dump(order), 200

order_api.add_resource(OrderList, '/')
order_api.add_resource(OrderDetail, '/<string:order_id>')

# === ./server/app/resources/payment.py ===
from flask import request, Blueprint, jsonify
from flask_restful import Resource, Api, abort
from decimal import Decimal
from sqlalchemy.orm import joinedload
from sqlalchemy import select, update, delete

from .. import db
from ..models import Order, OrderItem, Artwork, Cart, CartItem, User

from .order import pending_checkouts


payment_bp = Blueprint('payments', __name__)
payment_api = Api(payment_bp)

class DarajaCallback(Resource):
    def post(self):
        """
        Handles the callback from Daraja after STK Push completion.
        Creates the Order, OrderItems, updates Artwork stock, and clears CartItems
        if the payment was successful and checkout data is found.
        """
        print("--- Daraja Callback Received ---")
        callback_data = request.get_json()
        print(f"Raw Callback Data: {callback_data}")

        if not callback_data or 'Body' not in callback_data or 'stkCallback' not in callback_data['Body']:
             print("ERROR: Invalid callback format received.")
             return {"ResultCode": 0, "ResultDesc": "Accepted"}, 200

        stk_callback = callback_data['Body']['stkCallback']
        result_code = stk_callback.get('ResultCode')
        checkout_request_id = stk_callback.get('CheckoutRequestID')
        result_desc = stk_callback.get('ResultDesc', 'No description provided')
        merchant_request_id = stk_callback.get('MerchantRequestID')

        if not checkout_request_id:
            print("ERROR: CheckoutRequestID missing in stkCallback.")
            return {"ResultCode": 0, "ResultDesc": "Accepted"}, 200

        print(f"Processing callback for CheckoutRequestID: {checkout_request_id}, ResultCode: {result_code}, MerchantRequestID: {merchant_request_id}")

        print(f"DEBUG: Current pending_checkouts keys: {list(pending_checkouts.keys())}")
        checkout_info = pending_checkouts.pop(checkout_request_id, None)

        if not checkout_info:
            print(f"WARNING: CheckoutRequestID {checkout_request_id} not found in pending checkouts or already processed.")
            return {"ResultCode": 0, "ResultDesc": "Accepted"}, 200

        user_id = checkout_info['user_id']
        cart_id_to_clear = checkout_info['cart_id']
        expected_total = Decimal(str(checkout_info['total_price']))
        items_to_order = checkout_info['items']

        print(f"DEBUG: Found pending checkout info for User {user_id}, Cart {cart_id_to_clear}, Expected Total: {expected_total}")

        if result_code == 0:
            print(f"SUCCESS: Payment reported successful for {checkout_request_id}. ResultDesc: {result_desc}")

            amount_paid = Decimal('0.00')
            mpesa_receipt = None
            phone_number_paid = None
            transaction_date_str = None

            if 'CallbackMetadata' in stk_callback and 'Item' in stk_callback['CallbackMetadata']:
                metadata = {item['Name']: item.get('Value') for item in stk_callback['CallbackMetadata']['Item']}
                amount_paid = Decimal(str(metadata.get('Amount', 0)))
                mpesa_receipt = metadata.get('MpesaReceiptNumber')
                phone_number_paid = metadata.get('PhoneNumber')
                transaction_date_str = metadata.get('TransactionDate')

            print(f"DEBUG: Amount Paid: {amount_paid}, Expected: {expected_total}, Receipt: {mpesa_receipt}, Phone: {phone_number_paid}, Date: {transaction_date_str}")

            if amount_paid < expected_total:
                 print(f"WARNING: Amount paid ({amount_paid}) is less than expected total ({expected_total}) for {checkout_request_id}. Order may not be created or marked as partially paid.")

            try:
                with db.session.begin_nested():
                    artworks_to_update_stock = {}
                    for item_data in items_to_order:
                        artwork_id = item_data['artwork_id']
                        quantity_ordered = item_data['quantity']

                        artwork = db.session.query(Artwork).filter_by(id=artwork_id).with_for_update().first()

                        if not artwork:
                            raise ValueError(f"Artwork ID {artwork_id} not found during final order creation.")
                        if artwork.stock_quantity < quantity_ordered:
                            raise ValueError(f"Insufficient stock for Artwork '{artwork.name}' (ID: {artwork_id}) during final order creation. Available: {artwork.stock_quantity}, Ordered: {quantity_ordered}")

                        artworks_to_update_stock[artwork_id] = quantity_ordered

                    new_order = Order(
                        user_id=user_id,
                        total_price=expected_total,
                        status='paid',
                        payment_gateway_ref=mpesa_receipt,
                    )
                    db.session.add(new_order)
                    db.session.flush()

                    for item_data in items_to_order:
                         order_item = OrderItem(
                             order_id=new_order.id,
                             artwork_id=item_data['artwork_id'],
                             quantity=item_data['quantity'],
                             price_at_purchase=Decimal(str(item_data['price_at_purchase']))
                         )
                         db.session.add(order_item)

                    for artwork_id, quantity_to_decrement in artworks_to_update_stock.items():
                         db.session.query(Artwork).filter_by(id=artwork_id).update({
                             'stock_quantity': Artwork.stock_quantity - quantity_to_decrement
                         })
                         print(f"DEBUG: Decremented stock for Artwork {artwork_id} by {quantity_to_decrement}")


                    deleted_count = db.session.query(CartItem).filter_by(cart_id=cart_id_to_clear).delete()
                    print(f"DEBUG: Deleted {deleted_count} items from Cart {cart_id_to_clear}")


                db.session.commit()
                print(f"SUCCESS: Order {new_order.id} created, stock updated, cart {cart_id_to_clear} cleared for User {user_id}.")

            except ValueError as ve:
                 db.session.rollback()
                 print(f"ERROR: Validation failed during final order creation for User {user_id}, Cart {cart_id_to_clear}. Reason: {ve}")
            except Exception as e:
                 db.session.rollback()
                 print(f"ERROR: Failed to commit order transaction for User {user_id}, Cart {cart_id_to_clear}. Error: {e}")


        else:
            print(f"FAILURE: Payment failed or cancelled for {checkout_request_id}. ResultCode: {result_code}, ResultDesc: {result_desc}")


        return {"ResultCode": 0, "ResultDesc": "Accepted"}, 200

payment_api.add_resource(DarajaCallback, '/callback')

# === ./server/app/resources/auth.py ===
from flask import request, jsonify, Blueprint
from flask_restful import Resource, Api
from marshmallow import ValidationError

from .. import db, bcrypt
from ..models import User
from ..schemas import user_schema

from flask_jwt_extended import create_access_token, jwt_required, get_jwt
from .. import BLOCKLIST

auth_bp = Blueprint('auth', __name__)
auth_api = Api(auth_bp)


class UserRegistration(Resource):
    def post(self):
        """
        Handles new user registration.
        """
        json_data = request.get_json()
        if not json_data:
            return {"message": "No input data provided"}, 400

        try:
            password = json_data.get('password')
            if not password:
                 return {'message': {'password': ['Missing data for required field.']}}, 400

            user_data = user_schema.load(json_data, session=db.session, unknown='EXCLUDE')

        except ValidationError as err:
            return {"message": "Validation errors", "errors": err.messages}, 400

        if User.query.filter_by(email=user_data.email).first():
            return {"message": "User with this email already exists"}, 409

        user = user_data

        user.set_password(password)

        try:
            db.session.add(user)
            db.session.commit()
            return {
                "message": "User created successfully",
                "user": user_schema.dump(user)
            }, 201
        except Exception as e:
            db.session.rollback()
            print(f"Error during registration: {e}")
            return {"message": "An error occurred during registration."}, 500


class UserLogin(Resource):
    def post(self):
       
        json_data = request.get_json()
        if not json_data:
            return {"message": "No input data provided"}, 400

        email = json_data.get('email')
        password = json_data.get('password')

        if not email or not password:
            return {"message": "Email and password are required"}, 400

        user = User.query.filter_by(email=email).first()

        if user and user.check_password(password):
            access_token = create_access_token(identity=user.id)
            return {"message": "Login successful", "access_token": access_token}, 200
        else:
            return {"message": "Invalid credentials"}, 401


class UserLogout(Resource):
    @jwt_required()
    def post(self):
        """
        Handles user logout by blocklisting the current JWT.
        """
        jti = get_jwt()["jti"]
        BLOCKLIST.add(jti)
        return {"message": "Successfully logged out"}, 200

auth_api.add_resource(UserRegistration, '/signup')
auth_api.add_resource(UserLogin, '/login')
auth_api.add_resource(UserLogout, '/logout')

# === ./server/app/resources/artwork.py ===
from flask import request, Blueprint, jsonify
from flask_restful import Resource, Api, abort
from marshmallow import ValidationError
from sqlalchemy.orm import joinedload

from .. import db
from ..models import Artwork, Artist
from ..schemas import artwork_schema, artworks_schema

artwork_bp = Blueprint('artworks', __name__)
artwork_api = Api(artwork_bp)


class ArtworkList(Resource):
    def get(self):
        """
        Fetches all artworks, including basic artist info.
        """
        artworks = Artwork.query.options(joinedload(Artwork.artist)).all()
        return artworks_schema.dump(artworks), 200

    def post(self):
        """
        Creates one OR multiple new artworks.
        Requires 'artist_id' in the input data for each artwork.
        Accepts either a single JSON object or a JSON array.
        """

        json_data = request.get_json()
        if not json_data:
            return {"message": "No input data provided"}, 400

        is_many = isinstance(json_data, list)

        try:
            if is_many:
                for item_data in json_data:
                    artist_id = item_data.get('artist_id')
                    if not artist_id or not Artist.query.get(artist_id):
                        abort(400, message=f"Invalid or missing artist_id: {artist_id}")
                new_artworks = artworks_schema.load(json_data, session=db.session)
            else:
                artist_id = json_data.get('artist_id')
                if not artist_id or not Artist.query.get(artist_id):
                    abort(400, message=f"Invalid or missing artist_id: {artist_id}")
                new_artworks = [artwork_schema.load(json_data, session=db.session)]
        except ValidationError as err:
            if 'artist_id' in err.messages:
                 return {"message": "Validation errors", "errors": err.messages}, 400
            return {"message": "Validation errors", "errors": err.messages}, 400
        except Exception as e:
             print(f"Unexpected error during schema load: {e}")
             abort(500, message="An internal error occurred during data processing.")


        if not new_artworks:
             return {"message": "No valid artwork data found after validation."}, 400

        try:
            db.session.add_all(new_artworks)
            db.session.commit()

            result = artworks_schema.dump(new_artworks) if is_many else artwork_schema.dump(new_artworks[0])
            return result, 201
        except Exception as e:
            db.session.rollback()
            print(f"Error creating artwork(s) in DB: {e}")
            if 'foreign key constraint fails' in str(e).lower() and 'artist_id' in str(e).lower():
                 abort(400, message="Invalid artist_id provided.")
            abort(500, message="An error occurred while saving the artwork(s) to the database.")


class ArtworkDetail(Resource):
    def get(self, artwork_id):
        """
        Fetches a single artwork by its UUID, including artist info.
        """
        artwork = Artwork.query.options(joinedload(Artwork.artist)).get_or_404(
            artwork_id, description=f"Artwork with ID {artwork_id} not found."
        )
        return artwork_schema.dump(artwork), 200

    def patch(self, artwork_id):
        """
        Updates an existing artwork partially.
        'artist_id' can be updated if provided.
        """

        artwork = Artwork.query.get_or_404(
            artwork_id, description=f"Artwork with ID {artwork_id} not found."
        )

        json_data = request.get_json()
        if not json_data:
            return {"message": "No input data provided"}, 400

        if 'artist_id' in json_data:
             artist_id = json_data.get('artist_id')
             if not artist_id or not Artist.query.get(artist_id):
                 abort(400, message=f"Invalid artist_id provided for update: {artist_id}")


        try:
            updated_artwork = artwork_schema.load(
                json_data,
                instance=artwork,
                partial=True,
                session=db.session
            )
        except ValidationError as err:
             if 'artist_id' in err.messages:
                 return {"message": "Validation errors", "errors": err.messages}, 400
             return {"message": "Validation errors", "errors": err.messages}, 400

        try:
            db.session.commit()
            refreshed_artwork = Artwork.query.options(joinedload(Artwork.artist)).get(artwork.id)
            return artwork_schema.dump(refreshed_artwork), 200
        except Exception as e:
            db.session.rollback()
            print(f"Error updating artwork {artwork_id}: {e}")
            if 'foreign key constraint fails' in str(e).lower() and 'artist_id' in str(e).lower():
                 abort(400, message="Invalid artist_id provided for update.")
            abort(500, message="An error occurred while updating the artwork.")

    def delete(self, artwork_id):
        """
        Deletes an artwork by its UUID.
        """

        artwork = Artwork.query.get_or_404(
             artwork_id, description=f"Artwork with ID {artwork_id} not found."
        )
        try:
            db.session.delete(artwork)
            db.session.commit()
            return '', 204
        except Exception as e:
            db.session.rollback()
            print(f"Error deleting artwork {artwork_id}: {e}")
            abort(500, message="An error occurred while deleting the artwork.")


artwork_api.add_resource(ArtworkList, '/')
artwork_api.add_resource(ArtworkDetail, '/<string:artwork_id>')

# === ./server/app/utils/daraja_client.py ===
import base64
import requests
from datetime import datetime
from flask import current_app, jsonify
import time

token_cache = {}

def get_daraja_access_token():
    """Fetches a new Daraja access token or returns a cached one."""
    global token_cache
    current_time = time.time()

    if token_cache and token_cache.get('expires_at', 0) > current_time:
        print("DEBUG: Using cached Daraja token")
        return token_cache['token']

    print("DEBUG: Fetching new Daraja token")
    consumer_key = current_app.config['DARAJA_CONSUMER_KEY']
    consumer_secret = current_app.config['DARAJA_CONSUMER_SECRET']
    auth_url = current_app.config['DARAJA_AUTH_URL']

    if not consumer_key or not consumer_secret:
        print("ERROR: Daraja consumer key or secret not configured.")
        return None

    try:
        response = requests.get(auth_url, auth=(consumer_key, consumer_secret))
        response.raise_for_status()
        token_data = response.json()

        expires_in = int(token_data.get('expires_in', 3599))
        token_cache = {
            'token': token_data['access_token'],
            'expires_at': current_time + expires_in - 60
        }
        print("DEBUG: Fetched and cached new Daraja token.")
        return token_data['access_token']
    except requests.exceptions.RequestException as e:
        print(f"ERROR: Failed to get Daraja access token: {e}")
        print(f"Response status: {response.status_code if 'response' in locals() else 'N/A'}")
        print(f"Response text: {response.text if 'response' in locals() else 'N/A'}")
        return None
    except KeyError:
        print(f"ERROR: 'access_token' or 'expires_in' not found in Daraja auth response: {token_data}")
        return None


def generate_daraja_password(shortcode, passkey, timestamp):
    """Generates the Base64 encoded password for Daraja API calls."""
    password_str = f"{shortcode}{passkey}{timestamp}"
    password_bytes = password_str.encode('utf-8')
    encoded_password = base64.b64encode(password_bytes).decode('utf-8')
    return encoded_password


def initiate_stk_push(phone_number, amount, order_id, description="Shoply Purchase"):
    """Initiates an STK Push request."""
    access_token = get_daraja_access_token()
    if not access_token:
        return {"error": "Failed to obtain Daraja access token"}, 500

    stk_push_url = current_app.config['DARAJA_STK_PUSH_URL']
    shortcode = current_app.config['DARAJA_SHORTCODE']
    passkey = current_app.config['DARAJA_PASSKEY']
    callback_url = current_app.config['DARAJA_CALLBACK_URL']
    transaction_type = current_app.config['DARAJA_TRANSACTION_TYPE']

    amount = int(round(float(amount)))
    if not phone_number.startswith('254') or not phone_number.isdigit() or len(phone_number) != 12:
         print(f"ERROR: Invalid phone number format: {phone_number}")
         return {"error": "Invalid phone number format. Use 254XXXXXXXXX."}, 400

    timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
    password = generate_daraja_password(shortcode, passkey, timestamp)

    headers = {
        'Authorization': f'Bearer {access_token}',
        'Content-Type': 'application/json'
    }

    payload = {
        "BusinessShortCode": shortcode,
        "Password": password,
        "Timestamp": timestamp,
        "TransactionType": transaction_type,
        "Amount": amount,
        "PartyA": phone_number,
        "PartyB": shortcode,
        "PhoneNumber": phone_number,
        "CallBackURL": callback_url,
        "AccountReference": str(order_id),
        "TransactionDesc": description
    }

    print(f"DEBUG: Initiating STK Push with payload: {payload}")

    try:
        response = requests.post(stk_push_url, json=payload, headers=headers)
        response.raise_for_status()
        response_data = response.json()
        print(f"DEBUG: STK Push Response: {response_data}")
        return response_data, 200
    except requests.exceptions.RequestException as e:
        print(f"ERROR: STK Push request failed: {e}")
        print(f"Response status: {response.status_code if 'response' in locals() else 'N/A'}")
        print(f"Response text: {response.text if 'response' in locals() else 'N/A'}")
        error_message = "Failed to initiate payment."
        try:
            error_details = response.json()
            error_message = error_details.get('errorMessage', error_message)
        except:
            pass
        return {"error": error_message}, getattr(response, 'status_code', 500)
    except Exception as e:
        print(f"ERROR: Unexpected error during STK Push: {e}")
        return {"error": "An unexpected error occurred during payment initiation."}, 500

# === ./server/media/artwork_images/rename.py ===
import os

def get_available_filename(base_name, extension):
    """Find the next available filename like art1.jpg, art2.jpg, etc."""
    counter = 1
    while True:
        new_name = f"{base_name}{counter}.{extension}"
        if not os.path.exists(new_name):
            return new_name
        counter += 1

def rename_images():
    images = [f for f in os.listdir('.') if f.lower().endswith('.jpg')]
    images.sort()

    for filename in images:
        new_name = get_available_filename("art", "jpg")
        os.rename(filename, new_name)
        print(f"Renamed '{filename}' to '{new_name}'")

if __name__ == "__main__":
    rename_images()

# === ./main/node_modules/flatted/python/flatted.py ===
# ISC License
#
# Copyright (c) 2018-2025, Andrea Giammarchi, @WebReflection
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
# INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
# LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
# OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
# PERFORMANCE OF THIS SOFTWARE.

import json as _json

class _Known:
    def __init__(self):
        self.key = []
        self.value = []

class _String:
    def __init__(self, value):
        self.value = value


def _array_keys(value):
    keys = []
    i = 0
    for _ in value:
        keys.append(i)
        i += 1
    return keys

def _object_keys(value):
    keys = []
    for key in value:
        keys.append(key)
    return keys

def _is_array(value):
    return isinstance(value, (list, tuple))

def _is_object(value):
    return isinstance(value, dict)

def _is_string(value):
    return isinstance(value, str)

def _index(known, input, value):
    input.append(value)
    index = str(len(input) - 1)
    known.key.append(value)
    known.value.append(index)
    return index

def _loop(keys, input, known, output):
    for key in keys:
        value = output[key]
        if isinstance(value, _String):
            _ref(key, input[int(value.value)], input, known, output)

    return output

def _ref(key, value, input, known, output):
    if _is_array(value) and value not in known:
        known.append(value)
        value = _loop(_array_keys(value), input, known, value)
    elif _is_object(value) and value not in known:
        known.append(value)
        value = _loop(_object_keys(value), input, known, value)

    output[key] = value

def _relate(known, input, value):
    if _is_string(value) or _is_array(value) or _is_object(value):
        try:
            return known.value[known.key.index(value)]
        except:
            return _index(known, input, value)

    return value

def _transform(known, input, value):
    if _is_array(value):
        output = []
        for val in value:
            output.append(_relate(known, input, val))
        return output

    if _is_object(value):
        obj = {}
        for key in value:
            obj[key] = _relate(known, input, value[key])
        return obj

    return value

def _wrap(value):
    if _is_string(value):
        return _String(value)

    if _is_array(value):
        i = 0
        for val in value:
            value[i] = _wrap(val)
            i += 1

    elif _is_object(value):
        for key in value:
            value[key] = _wrap(value[key])

    return value

def parse(value, *args, **kwargs):
    json = _json.loads(value, *args, **kwargs)
    wrapped = []
    for value in json:
        wrapped.append(_wrap(value))

    input = []
    for value in wrapped:
        if isinstance(value, _String):
            input.append(value.value)
        else:
            input.append(value)

    value = input[0]

    if _is_array(value):
        return _loop(_array_keys(value), input, [value], value)

    if _is_object(value):
        return _loop(_object_keys(value), input, [value], value)

    return value


def stringify(value, *args, **kwargs):
    known = _Known()
    input = []
    output = []
    i = int(_index(known, input, value))
    while i < len(input):
        output.append(_transform(known, input, input[i]))
        i += 1
    return _json.dumps(output, *args, **kwargs)
