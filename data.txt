# Extracted Python Code
# Date and Time: 2025-05-02 04:14:41
# Files Included: 14

# === ./server/run.py ===
from app import create_app

#creating flask app instance 
app = create_app()

if __name__ =='__main__':
    app.run(debug=True)

# === ./server/migrations/env.py ===
import logging
from logging.config import fileConfig

from flask import current_app

from alembic import context

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
fileConfig(config.config_file_name)
logger = logging.getLogger('alembic.env')


def get_engine():
    try:
        # this works with Flask-SQLAlchemy<3 and Alchemical
        return current_app.extensions['migrate'].db.get_engine()
    except (TypeError, AttributeError):
        # this works with Flask-SQLAlchemy>=3
        return current_app.extensions['migrate'].db.engine


def get_engine_url():
    try:
        return get_engine().url.render_as_string(hide_password=False).replace(
            '%', '%%')
    except AttributeError:
        return str(get_engine().url).replace('%', '%%')


# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
config.set_main_option('sqlalchemy.url', get_engine_url())
target_db = current_app.extensions['migrate'].db

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def get_metadata():
    if hasattr(target_db, 'metadatas'):
        return target_db.metadatas[None]
    return target_db.metadata


def run_migrations_offline():
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url, target_metadata=get_metadata(), literal_binds=True
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online():
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """

    # this callback is used to prevent an auto-migration from being generated
    # when there are no changes to the schema
    # reference: http://alembic.zzzcomputing.com/en/latest/cookbook.html
    def process_revision_directives(context, revision, directives):
        if getattr(config.cmd_opts, 'autogenerate', False):
            script = directives[0]
            if script.upgrade_ops.is_empty():
                directives[:] = []
                logger.info('No changes in schema detected.')

    conf_args = current_app.extensions['migrate'].configure_args
    if conf_args.get("process_revision_directives") is None:
        conf_args["process_revision_directives"] = process_revision_directives

    connectable = get_engine()

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=get_metadata(),
            **conf_args
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

# === ./server/migrations/versions/1ae97819e612_done.py ===
"""done

Revision ID: 1ae97819e612
Revises: 
Create Date: 2025-04-29 15:08:25.493463

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import mysql

# revision identifiers, used by Alembic.
revision = '1ae97819e612'
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('products',
    sa.Column('id', sa.String(length=36), nullable=False),
    sa.Column('name', sa.String(length=255), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('price', mysql.DECIMAL(precision=10, scale=2), nullable=False),
    sa.Column('stock_quantity', sa.Integer(), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.Column('image_url', sa.String(length=255), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('users',
    sa.Column('id', sa.String(length=36), nullable=False),
    sa.Column('email', sa.String(length=120), nullable=False),
    sa.Column('password_hash', sa.String(length=128), nullable=False),
    sa.Column('name', sa.String(length=100), nullable=True),
    sa.Column('address', sa.Text(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('email')
    )
    op.create_table('carts',
    sa.Column('id', sa.String(length=36), nullable=False),
    sa.Column('user_id', sa.String(length=36), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('user_id')
    )
    op.create_table('orders',
    sa.Column('id', sa.String(length=36), nullable=False),
    sa.Column('user_id', sa.String(length=36), nullable=False),
    sa.Column('total_price', mysql.DECIMAL(precision=10, scale=2), nullable=False),
    sa.Column('status', sa.String(length=50), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.Column('shipped_at', sa.DateTime(), nullable=True),
    sa.Column('shipping_address', sa.Text(), nullable=True),
    sa.Column('billing_address', sa.Text(), nullable=True),
    sa.Column('payment_gateway_ref', sa.String(length=255), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('cart_items',
    sa.Column('id', sa.String(length=36), nullable=False),
    sa.Column('cart_id', sa.String(length=36), nullable=False),
    sa.Column('product_id', sa.String(length=36), nullable=False),
    sa.Column('quantity', sa.Integer(), nullable=False),
    sa.ForeignKeyConstraint(['cart_id'], ['carts.id'], ),
    sa.ForeignKeyConstraint(['product_id'], ['products.id'], ),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('cart_id', 'product_id', name='_cart_product_uc')
    )
    op.create_table('order_items',
    sa.Column('id', sa.String(length=36), nullable=False),
    sa.Column('order_id', sa.String(length=36), nullable=False),
    sa.Column('product_id', sa.String(length=36), nullable=False),
    sa.Column('quantity', sa.Integer(), nullable=False),
    sa.Column('price_at_purchase', mysql.DECIMAL(precision=10, scale=2), nullable=False),
    sa.ForeignKeyConstraint(['order_id'], ['orders.id'], ),
    sa.ForeignKeyConstraint(['product_id'], ['products.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('order_items')
    op.drop_table('cart_items')
    op.drop_table('orders')
    op.drop_table('carts')
    op.drop_table('users')
    op.drop_table('products')
    # ### end Alembic commands ###

# === ./server/app/schemas.py ===
from marshmallow import fields, validate
from . import ma, db
from .models import User, Product, Cart, CartItem, Order, OrderItem


class UserSchema(ma.SQLAlchemyAutoSchema):
    password = fields.Str(required=True, load_only=True, validate=validate.Length(min=8))
    email = fields.Email(required=True)
    name = fields.Str()
    address = fields.Str()

    class Meta:
        model = User
        load_instance = True
        exclude = ('password_hash',)
        sqla_session = db.session

class ProductSchema(ma.SQLAlchemyAutoSchema):
    price = fields.Decimal(as_string=True, required=True, validate=validate.Range(min=0))
    stock_quantity = fields.Int(validate=validate.Range(min=0))

    class Meta:
        model = Product
        load_instance = True
        sqla_session = db.session

class CartItemSchema(ma.SQLAlchemyAutoSchema):
    product = fields.Nested(ProductSchema, only=('id', 'name', 'price', 'image_url'))
    quantity = fields.Int(required=True, validate=validate.Range(min=1))

    class Meta:
        model = CartItem
        load_instance = True
        sqla_session = db.session
        exclude = ('cart_id',)

class CartSchema(ma.SQLAlchemyAutoSchema):
    items = fields.Nested(CartItemSchema, many=True)

    class Meta:
        model = Cart
        load_instance = True
        sqla_session = db.session

class OrderItemSchema(ma.SQLAlchemyAutoSchema):
    product = fields.Nested(ProductSchema, only=('id', 'name', 'image_url'))
    price_at_purchase = fields.Decimal(as_string=True, dump_only=True)
    quantity = fields.Int(dump_only=True)

    class Meta:
        model = OrderItem
        load_instance = True
        sqla_session = db.session
        exclude = ('order_id',)

class OrderSchema(ma.SQLAlchemyAutoSchema):
    items = fields.Nested(OrderItemSchema, many=True, dump_only=True)
    total_price = fields.Decimal(as_string=True, dump_only=True)
    status = fields.Str(dump_only=True)

    class Meta:
        model = Order
        load_instance = True
        sqla_session = db.session


user_schema = UserSchema()
product_schema = ProductSchema()
cart_schema = CartSchema()
order_schema = OrderSchema()

users_schema = UserSchema(many=True)
products_schema = ProductSchema(many=True)
orders_schema = OrderSchema(many=True)

# === ./server/app/models.py ===
import uuid
from datetime import datetime
from sqlalchemy.dialects.mysql import DECIMAL

from . import db, bcrypt

def generate_uuid():
    return str(uuid.uuid4())

class User(db.Model):
    __tablename__ = 'users'

    id = db.Column(db.String(36), primary_key=True, default=generate_uuid)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.String(128), nullable=False)
    name = db.Column(db.String(100), nullable=True)
    address = db.Column(db.Text, nullable=True)
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)

    cart = db.relationship('Cart', back_populates='user', uselist=False, cascade="all, delete-orphan")
    orders = db.relationship('Order', back_populates='user', lazy=True, cascade="all, delete-orphan")

    def set_password(self, password):
        """Hashes the password and stores it."""
        self.password_hash = bcrypt.generate_password_hash(password).decode('utf-8')

    def check_password(self, password):
        """Checks if the provided password matches the stored hash."""
        return bcrypt.check_password_hash(self.password_hash, password)

    def __repr__(self):
        return f"<User {self.email}>"

class Product(db.Model):
    __tablename__ = 'products'

    id = db.Column(db.String(36), primary_key=True, default=generate_uuid)
    name = db.Column(db.String(255), nullable=False)
    description = db.Column(db.Text, nullable=True)
    price = db.Column(DECIMAL(precision=10, scale=2), nullable=False)
    stock_quantity = db.Column(db.Integer, nullable=False, default=0)
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)
    image_url = db.Column(db.String(255), nullable=True)
    cart_items = db.relationship('CartItem', back_populates='product', lazy=True)
    order_items = db.relationship('OrderItem', back_populates='product', lazy=True)

    def __repr__(self):
        return f"<Product {self.name}>"

class Cart(db.Model):
    __tablename__ = 'carts'

    id = db.Column(db.String(36), primary_key=True, default=generate_uuid)
    user_id = db.Column(db.String(36), db.ForeignKey('users.id'), unique=True, nullable=False)
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)

    user = db.relationship('User', back_populates='cart')
    items = db.relationship('CartItem', back_populates='cart', lazy='dynamic', cascade="all, delete-orphan")

    def __repr__(self):
        return f"<Cart {self.id} for User {self.user_id}>"

class CartItem(db.Model):
    __tablename__ = 'cart_items'

    id = db.Column(db.String(36), primary_key=True, default=generate_uuid)
    cart_id = db.Column(db.String(36), db.ForeignKey('carts.id'), nullable=False)
    product_id = db.Column(db.String(36), db.ForeignKey('products.id'), nullable=False)
    quantity = db.Column(db.Integer, nullable=False, default=1)

    __table_args__ = (db.UniqueConstraint('cart_id', 'product_id', name='_cart_product_uc'),)

    cart = db.relationship('Cart', back_populates='items')
    product = db.relationship('Product', back_populates='cart_items')

    def __repr__(self):
        return f"<CartItem Product {self.product_id} Qty {self.quantity} in Cart {self.cart_id}>"


class Order(db.Model):
    __tablename__ = 'orders'

    id = db.Column(db.String(36), primary_key=True, default=generate_uuid)
    user_id = db.Column(db.String(36), db.ForeignKey('users.id'), nullable=False)
    total_price = db.Column(DECIMAL(precision=10, scale=2), nullable=False)
    status = db.Column(db.String(50), nullable=False, default='pending')
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)
    shipped_at = db.Column(db.DateTime, nullable=True)
    shipping_address = db.Column(db.Text, nullable=True)
    billing_address = db.Column(db.Text, nullable=True)
    payment_gateway_ref = db.Column(db.String(255), nullable=True)

    user = db.relationship('User', back_populates='orders')
    items = db.relationship('OrderItem', back_populates='order', cascade="all, delete-orphan")

    def __repr__(self):
        return f"<Order {self.id} Status {self.status} by User {self.user_id}>"
    
class OrderItem(db.Model):
    __tablename__ = 'order_items'

    id = db.Column(db.String(36), primary_key=True, default=generate_uuid)
    order_id = db.Column(db.String(36), db.ForeignKey('orders.id'), nullable=False)
    product_id = db.Column(db.String(36), db.ForeignKey('products.id'), nullable=False)
    quantity = db.Column(db.Integer, nullable=False)
    price_at_purchase = db.Column(DECIMAL(precision=10, scale=2), nullable=False)

    order = db.relationship('Order', back_populates='items')
    product = db.relationship('Product', back_populates='order_items')

    def __repr__(self):
        return f"<OrderItem Product {self.product_id} Qty {self.quantity} Price {self.price_at_purchase} in Order {self.order_id}>"

# === ./server/app/config.py ===
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    SECRET_KEY = os.getenv('SECRET_KEY')
    JWT_SECRET_KEY = os.getenv('JWT_SECRET_KEY')
    SQLALCHEMY_TRACK_MODIFICATIONS = False

    DATABASE_USER = os.getenv('DATABASE_USER')
    DATABASE_PASSWORD = os.getenv('DATABASE_PASSWORD')
    DATABASE_HOST = os.getenv('DATABASE_HOST')
    DATABASE_PORT = os.getenv('DATABASE_PORT')
    DATABASE_NAME = os.getenv('DATABASE_NAME')
    SQLALCHEMY_DATABASE_URI = (
        f"mysql+pymysql://{DATABASE_USER}:{DATABASE_PASSWORD}@{DATABASE_HOST}:{DATABASE_PORT}/{DATABASE_NAME}"
    )

    JWT_BLACKLIST_ENABLED = True
    JWT_BLACKLIST_TOKEN_CHECKS = ['access']

    DARAJA_ENVIRONMENT = os.getenv('DARAJA_ENVIRONMENT', 'sandbox')
    DARAJA_CONSUMER_KEY = os.getenv('DARAJA_CONSUMER_KEY')
    DARAJA_CONSUMER_SECRET = os.getenv('DARAJA_CONSUMER_SECRET')
    DARAJA_SHORTCODE = os.getenv('DARAJA_SHORTCODE')
    DARAJA_PASSKEY = os.getenv('DARAJA_PASSKEY')
    DARAJA_TRANSACTION_TYPE = os.getenv('DARAJA_TRANSACTION_TYPE', 'CustomerPayBillOnline')
    DARAJA_CALLBACK_URL_BASE = os.getenv('DARAJA_CALLBACK_URL_BASE')

    if DARAJA_ENVIRONMENT == 'production':
        DARAJA_AUTH_URL = 'https://api.safaricom.co.ke/oauth/v1/generate?grant_type=client_credentials'
        DARAJA_STK_PUSH_URL = 'https://api.safaricom.co.ke/mpesa/stkpush/v1/processrequest'
    else:
        DARAJA_AUTH_URL = 'https://sandbox.safaricom.co.ke/oauth/v1/generate?grant_type=client_credentials'
        DARAJA_STK_PUSH_URL = 'https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest'

    DARAJA_CALLBACK_URL = f"{DARAJA_CALLBACK_URL_BASE.rstrip('/')}/api/payments/callback"


    if not all([DARAJA_CONSUMER_KEY, DARAJA_CONSUMER_SECRET, DARAJA_SHORTCODE, DARAJA_PASSKEY, DARAJA_CALLBACK_URL_BASE]):
        print("WARNING: Essential Daraja configuration missing in environment variables!")

# === ./server/app/__init__.py ===
import os
from flask import Flask, jsonify
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from flask_jwt_extended import JWTManager
from flask_bcrypt import Bcrypt
from flask_marshmallow import Marshmallow
from flask_cors import CORS
from .config import Config

db = SQLAlchemy()
migrate = Migrate()
jwt = JWTManager()
bcrypt = Bcrypt()
ma = Marshmallow()
cors = CORS()

BLOCKLIST = set()

@jwt.token_in_blocklist_loader
def check_if_token_in_blocklist(jwt_header, jwt_payload):
    jti = jwt_payload["jti"]
    return jti in BLOCKLIST


@jwt.unauthorized_loader
def missing_token_callback(error):
    return jsonify({"description": "Request does not contain an access token.", "error": "authorization_required"}), 401

def create_app(config_class=Config):
    app = Flask(__name__)
    app.config.from_object(config_class)

    print(f"DEBUG: Connecting to DB: {app.config['SQLALCHEMY_DATABASE_URI']}")

    db.init_app(app)
    migrate.init_app(app, db)
    jwt.init_app(app)
    bcrypt.init_app(app)
    ma.init_app(app)
    cors.init_app(app, resources={r"/api/*": {"origins": "*"}})

    from . import models

    from .resources.auth import auth_bp
    from .resources.product import product_bp
    from .resources.cart import cart_bp
    from .resources.order import order_bp
    from .resources.payment import payment_bp

    app.register_blueprint(auth_bp, url_prefix='/api/auth')
    app.register_blueprint(product_bp, url_prefix='/api/products')
    app.register_blueprint(cart_bp, url_prefix='/api/cart')
    app.register_blueprint(order_bp, url_prefix='/api/orders')
    app.register_blueprint(payment_bp, url_prefix='/api/payments')


    @app.route('/')
    def index():
        return "Shoply Backend is running!"

    return app

# === ./server/app/resources/cart.py ===
from flask import request, Blueprint, jsonify
from flask_restful import Resource, Api, abort
from marshmallow import ValidationError, fields
from sqlalchemy.orm import joinedload

from .. import db, ma
from ..models import Cart, CartItem, Product, User
from ..schemas import cart_schema

from flask_jwt_extended import jwt_required, get_jwt_identity

cart_bp = Blueprint('cart', __name__)
cart_api = Api(cart_bp)

def get_or_create_cart(user_id):
    """Finds the user's cart or creates one if it doesn't exist."""
    user = User.query.get(user_id)
    if not user:
        abort(404, message="User not found.")

    cart = Cart.query.filter_by(user_id=user_id).first()
    if not cart:
        cart = Cart(user_id=user_id)
        db.session.add(cart)
    return cart

class AddToCartSchema(ma.Schema):
    product_id = fields.Str(required=True)
    quantity = fields.Int(required=True, validate=lambda q: q > 0)

add_to_cart_schema = AddToCartSchema()


class CartResource(Resource):
    @jwt_required()
    def get(self):
        """
        Fetches the current user's cart contents.
        """
        user_id = get_jwt_identity()
        cart = get_or_create_cart(user_id)


        if cart.id is None:
             try:
                 db.session.commit()
             except Exception as e:
                 db.session.rollback()
                 print(f"Error committing new cart: {e}")
                 abort(500, message="Could not retrieve or create cart.")

        return cart_schema.dump(cart), 200

    @jwt_required()
    def post(self):
        """
        Adds a product to the current user's cart or updates its quantity.
        """
        user_id = get_jwt_identity()
        json_data = request.get_json()
        if not json_data:
            abort(400, message="No input data provided")

        try:
            data = add_to_cart_schema.load(json_data)
        except ValidationError as err:
            abort(400, message=err.messages)

        product_id = data['product_id']
        quantity_to_add = data['quantity']

        cart = get_or_create_cart(user_id)
        product = Product.query.get(product_id)

        if not product:
            abort(404, message=f"Product with ID {product_id} not found.")

        if product.stock_quantity < quantity_to_add:
             abort(400, message=f"Insufficient stock for Product ID {product_id}. Available: {product.stock_quantity}")

        cart_item = cart.items.filter_by(product_id=product_id).first()

        if cart_item:
            new_quantity = cart_item.quantity + quantity_to_add
            if product.stock_quantity < new_quantity:
                 abort(400, message=f"Insufficient stock to increase quantity for Product ID {product_id}. Available: {product.stock_quantity}, In Cart: {cart_item.quantity}")
            cart_item.quantity = new_quantity
        else:
            cart_item = CartItem(cart_id=cart.id, product_id=product_id, quantity=quantity_to_add)
            db.session.add(cart_item)
            if cart.id is None:
                try:
                    db.session.flush()
                    cart_item.cart_id = cart.id
                except Exception as e:
                     db.session.rollback()
                     print(f"Error flushing cart for item add: {e}")
                     abort(500, message="Error adding item to cart.")


        try:
            db.session.commit()
            cart_updated = Cart.query.options(
                joinedload(Cart.items).joinedload(CartItem.product)
            ).get(cart.id)
            return cart_schema.dump(cart_updated), 200
        except Exception as e:
            db.session.rollback()
            print(f"Error committing cart changes: {e}")
            if "UniqueViolation" in str(e) or "_cart_product_uc" in str(e):
                 abort(409, message="Item already exists in cart or concurrent modification error.")
            abort(500, message="An error occurred while updating the cart.")


class CartItemResource(Resource):

    @jwt_required()
    def put(self, item_id):
        """
        Updates the quantity of a specific item in the cart.
        """
        user_id = get_jwt_identity()
        cart = get_or_create_cart(user_id)

        json_data = request.get_json()
        if not json_data or 'quantity' not in json_data:
             abort(400, message="Quantity is required.")

        try:
            new_quantity = int(json_data['quantity'])
            if new_quantity <= 0:
                abort(400, message="Quantity must be positive.")
        except ValueError:
            abort(400, message="Quantity must be an integer.")

        cart_item = CartItem.query.filter_by(id=item_id, cart_id=cart.id).first()
        if not cart_item:
            abort(404, message=f"Cart item with ID {item_id} not found in your cart.")

        product = Product.query.get(cart_item.product_id)
        if not product:
             abort(404, message=f"Product associated with cart item not found.")

        if product.stock_quantity < new_quantity:
            abort(400, message=f"Insufficient stock for Product ID {product.id}. Available: {product.stock_quantity}")

        cart_item.quantity = new_quantity

        try:
            db.session.commit()
            cart_updated = Cart.query.options(
                joinedload(Cart.items).joinedload(CartItem.product)
            ).get(cart.id)
            return cart_schema.dump(cart_updated), 200
        except Exception as e:
            db.session.rollback()
            print(f"Error updating cart item: {e}")
            abort(500, message="An error occurred while updating the cart item.")


    @jwt_required()
    def delete(self, item_id):
        """
        Removes a specific item from the cart.
        """
        user_id = get_jwt_identity()
        cart = get_or_create_cart(user_id)

        cart_item = CartItem.query.filter_by(id=item_id, cart_id=cart.id).first()
        if not cart_item:
            abort(404, message=f"Cart item with ID {item_id} not found in your cart.")

        try:
            db.session.delete(cart_item)
            db.session.commit()
            cart_updated = Cart.query.options(
                joinedload(Cart.items).joinedload(CartItem.product)
            ).get(cart.id)
            return cart_schema.dump(cart_updated), 200
        except Exception as e:
            db.session.rollback()
            print(f"Error deleting cart item: {e}")
            abort(500, message="An error occurred while removing the item from the cart.")


cart_api.add_resource(CartResource, '/')
cart_api.add_resource(CartItemResource, '/items/<string:item_id>')

# === ./server/app/resources/order.py ===
from flask import request, Blueprint, jsonify
from flask_restful import Resource, Api, abort
from marshmallow import fields, Schema, ValidationError
from sqlalchemy.orm import joinedload
from decimal import Decimal

from .. import db, ma
from ..models import Order, OrderItem, User, Cart, Product, CartItem
from ..schemas import order_schema, orders_schema

from flask_jwt_extended import jwt_required, get_jwt_identity
from ..utils.daraja_client import initiate_stk_push

order_bp = Blueprint('orders', __name__)
order_api = Api(order_bp)

pending_checkouts = {}

class CheckoutInputSchema(ma.Schema):
    phone_number = fields.Str(required=True, validate=lambda p: p.startswith('254') and len(p) == 12 and p.isdigit())

checkout_input_schema = CheckoutInputSchema()

class OrderList(Resource):
    @jwt_required()
    def get(self):
        """Fetches the current user's past orders."""
        user_id = get_jwt_identity()
        user_orders = Order.query.options(
            joinedload(Order.items).joinedload(OrderItem.product)
        ).filter_by(user_id=user_id).order_by(Order.created_at.desc()).all()
        return orders_schema.dump(user_orders), 200

    @jwt_required()
    def post(self):
        """
        Initiates the checkout process (triggers STK Push).
        Does NOT create the order directly. This happens in the callback.
        """
        user_id = get_jwt_identity()

        json_data = request.get_json()
        if not json_data:
             abort(400, message="Missing checkout data (e.g., phone_number).")
        try:
            checkout_data = checkout_input_schema.load(json_data)
        except ValidationError as err:
            abort(400, message=err.messages)

        phone_number = checkout_data['phone_number']

        cart = Cart.query.filter_by(user_id=user_id).first()

        if not cart:
             abort(400, message="Your cart is empty.")

        cart_items_with_products = cart.items.options(
            joinedload(CartItem.product)
        ).all()

        if not cart_items_with_products:
            abort(400, message="Your cart is empty.")

        total_price = Decimal('0.0')

        for item in cart_items_with_products:
            if not item.product:
                 abort(500, message=f"Product data missing for cart item {item.id}.")

            if item.product.stock_quantity < item.quantity:
                abort(400, message=f"Insufficient stock for '{item.product.name}'. Available: {item.product.stock_quantity}")

            total_price += Decimal(item.product.price) * Decimal(item.quantity)


        if total_price <= 0:
            abort(400, message="Cart total must be positive.")

        account_ref = f"CART_{cart.id[:8]}"
        amount = float(total_price)

        stk_response, status_code = initiate_stk_push(
            phone_number=phone_number,
            amount=amount,
            order_id=account_ref,
            description=f"Payment for Shoply Cart {cart.id[:8]}"
        )

        if status_code >= 400 or stk_response.get("ResponseCode", "1") != "0":
            error_msg = stk_response.get("errorMessage", "Failed to initiate STK push.")
            error_msg = stk_response.get("ResponseDescription", error_msg)
            abort(status_code if status_code >= 400 else 500, message=error_msg)

        checkout_request_id = stk_response.get('CheckoutRequestID')
        if not checkout_request_id:
             abort(500, message="STK Push initiated but CheckoutRequestID was missing in response.")

        pending_checkouts[checkout_request_id] = {
            'user_id': user_id,
            'cart_id': cart.id,
            'total_price': float(total_price),
        }
        print(f"DEBUG: Stored pending checkout: {checkout_request_id} -> {pending_checkouts[checkout_request_id]}")

        return {
            "message": "STK Push initiated successfully. Please check your phone to authorize payment.",
            "CheckoutRequestID": checkout_request_id,
            "ResponseDescription": stk_response.get("ResponseDescription", "Success")
        }, 200


class OrderDetail(Resource):
    @jwt_required()
    def get(self, order_id):
        """Fetches details of a specific order belonging to the user."""
        user_id = get_jwt_identity()
        order = Order.query.options(
            joinedload(Order.items).joinedload(OrderItem.product)
        ).filter_by(id=order_id, user_id=user_id).first_or_404(
            description=f"Order with ID {order_id} not found or does not belong to user."
        )
        return order_schema.dump(order), 200

order_api.add_resource(OrderList, '/')
order_api.add_resource(OrderDetail, '/<string:order_id>')

# === ./server/app/resources/product.py ===
from flask import request, Blueprint, jsonify
from flask_restful import Resource, Api, abort
from marshmallow import ValidationError

from .. import db
from ..models import Product
from ..schemas import product_schema, products_schema

product_bp = Blueprint('products', __name__)
product_api = Api(product_bp)


class ProductList(Resource):
    def get(self):
        """
        Fetches all products.
        """
        products = Product.query.all()
        return products_schema.dump(products), 200

    def post(self):
        """
        Creates one OR multiple new products.
        Accepts either a single JSON object representing one product,
        or a JSON array containing multiple product objects.
        (Currently public, add admin check later if needed)
        """
        json_data = request.get_json()
        if not json_data:
            return {"message": "No input data provided"}, 400

        is_many = isinstance(json_data, list)

        try:
            if is_many:
                new_products = products_schema.load(json_data, session=db.session)
            else:
                new_products = [product_schema.load(json_data, session=db.session)]
        except ValidationError as err:
            return {"message": "Validation errors", "errors": err.messages}, 400
        except Exception as e:
             print(f"Unexpected error during schema load: {e}")
             abort(500, message="An internal error occurred during data processing.")


        if not new_products:
             return {"message": "No valid product data found after validation."}, 400

        try:
            db.session.add_all(new_products)
            db.session.commit()

            if is_many:
                return products_schema.dump(new_products), 201
            else:
                return product_schema.dump(new_products[0]), 201
        except Exception as e:
            db.session.rollback()
            print(f"Error creating product(s) in DB: {e}")
            abort(500, message="An error occurred while saving the product(s) to the database.")


class ProductDetail(Resource):
    def get(self, product_id):
        """
        Fetches a single product by its UUID.
        """
        product = Product.query.get_or_404(product_id, description=f"Product with ID {product_id} not found.")
        return product_schema.dump(product), 200

    def patch(self, product_id):
        """
        Updates an existing product partially.
        (Currently public, add admin check later if needed)
        """
        product = Product.query.get_or_404(product_id, description=f"Product with ID {product_id} not found.")

        json_data = request.get_json()
        if not json_data:
            return {"message": "No input data provided"}, 400

        try:
            updated_product = product_schema.load(
                json_data,
                instance=product,
                partial=True,
                session=db.session
            )
        except ValidationError as err:
            return {"message": "Validation errors", "errors": err.messages}, 400

        try:
            db.session.commit()
            return product_schema.dump(updated_product), 200
        except Exception as e:
            db.session.rollback()
            print(f"Error updating product {product_id}: {e}")
            abort(500, message="An error occurred while updating the product.")

    def delete(self, product_id):
        """
        Deletes a product by its UUID.
        (Currently public, add admin check later if needed)
        """
        product = Product.query.get_or_404(product_id, description=f"Product with ID {product_id} not found.")
        try:
            db.session.delete(product)
            db.session.commit()
            return '', 204
        except Exception as e:
            db.session.rollback()
            print(f"Error deleting product {product_id}: {e}")
            abort(500, message="An error occurred while deleting the product.")


product_api.add_resource(ProductList, '/')
product_api.add_resource(ProductDetail, '/<string:product_id>')

# === ./server/app/resources/payment.py ===
from flask import request, Blueprint, jsonify
from flask_restful import Resource, Api, abort
from decimal import Decimal
from sqlalchemy.orm import joinedload 

from .. import db
from ..models import Order, OrderItem, Product, Cart, CartItem

from .order import pending_checkouts


payment_bp = Blueprint('payments', __name__)
payment_api = Api(payment_bp)

class DarajaCallback(Resource):
    def post(self):
        """
        Handles the callback from Daraja after STK Push completion.
        This endpoint MUST be publicly accessible (use ngrok for dev).
        """
        print("--- Daraja Callback Received ---")
        callback_data = request.get_json()
        print(f"Callback Data: {callback_data}")

        if not callback_data or 'Body' not in callback_data or 'stkCallback' not in callback_data['Body']:
             print("ERROR: Invalid callback format")
             return {"ResultCode": 0, "ResultDesc": "Accepted"}, 200

        stk_callback = callback_data['Body']['stkCallback']
        result_code = stk_callback.get('ResultCode')
        checkout_request_id = stk_callback.get('CheckoutRequestID')
        result_desc = stk_callback.get('ResultDesc', 'No description')

        if not checkout_request_id:
            print("ERROR: CheckoutRequestID missing in callback.")
            return {"ResultCode": 0, "ResultDesc": "Accepted"}, 200

        print(f"DEBUG: Looking for CheckoutRequestID: {checkout_request_id} in pending_checkouts")
        checkout_info = pending_checkouts.pop(checkout_request_id, None)

        if not checkout_info:
            print(f"ERROR: CheckoutRequestID {checkout_request_id} not found in pending checkouts or already processed.")
            return {"ResultCode": 0, "ResultDesc": "Accepted"}, 200

        user_id = checkout_info['user_id']
        cart_id = checkout_info['cart_id']
        expected_total = Decimal(str(checkout_info['total_price']))

        print(f"DEBUG: Found checkout info for User {user_id}, Cart {cart_id}")

        if result_code == 0:
            print(f"SUCCESS: Payment successful for {checkout_request_id}. ResultDesc: {result_desc}")

            amount_paid = Decimal('0.00')
            mpesa_receipt = None
            phone_number_paid = None
            transaction_date = None
            if 'CallbackMetadata' in stk_callback and 'Item' in stk_callback['CallbackMetadata']:
                metadata = stk_callback['CallbackMetadata']['Item']
                for item in metadata:
                    if item.get('Name') == 'Amount':
                        amount_paid = Decimal(str(item.get('Value', 0)))
                    elif item.get('Name') == 'MpesaReceiptNumber':
                        mpesa_receipt = item.get('Value')
                    elif item.get('Name') == 'PhoneNumber':
                        phone_number_paid = item.get('Value')
                    elif item.get('Name') == 'TransactionDate':
                        transaction_date = item.get('Value')

            print(f"DEBUG: Amount Paid: {amount_paid}, Expected: {expected_total}, Receipt: {mpesa_receipt}")


            try:
                with db.session.begin_nested():
                    cart_items = CartItem.query.filter_by(cart_id=cart_id).options(
                        joinedload(CartItem.product)
                    ).all()

                    if not cart_items:
                         print(f"ERROR: No items found for Cart {cart_id} during callback processing.")
                         raise ValueError("Cart items missing during order creation.")


                    current_total_price = Decimal('0.00')
                    products_to_update = []
                    order_items_to_create = []

                    for item in cart_items:
                        if not item.product:
                             raise ValueError(f"Product data missing for cart item {item.id} during order creation.")
                        if item.product.stock_quantity < item.quantity:
                             raise ValueError(f"Insufficient stock for '{item.product.name}' during final order creation.")

                        current_total_price += item.product.price * item.quantity
                        products_to_update.append({'product': item.product, 'quantity': item.quantity})
                        order_items_to_create.append({
                             'product_id': item.product_id,
                             'quantity': item.quantity,
                             'price_at_purchase': item.product.price
                        })



                    new_order = Order(
                        user_id=user_id,
                        total_price=current_total_price,
                        status='paid',
                        payment_gateway_ref=mpesa_receipt
                    )
                    db.session.add(new_order)
                    db.session.flush()

                    for item_data in order_items_to_create:
                         order_item = OrderItem(
                             order_id=new_order.id,
                             product_id=item_data['product_id'],
                             quantity=item_data['quantity'],
                             price_at_purchase=item_data['price_at_purchase']
                         )
                         db.session.add(order_item)

                    for prod_data in products_to_update:
                         prod_data['product'].stock_quantity -= prod_data['quantity']

                    CartItem.query.filter_by(cart_id=cart_id).delete()

                db.session.commit()
                print(f"SUCCESS: Order {new_order.id} created successfully for User {user_id}.")

            except ValueError as ve:
                 db.session.rollback()
                 print(f"ERROR: Stock validation failed during final order creation for Cart {cart_id}. Reason: {ve}")
            except Exception as e:
                 db.session.rollback()
                 print(f"ERROR: Failed to create order or update stock for Cart {cart_id} / User {user_id}. Error: {e}")

        else:
            print(f"FAILURE: Payment failed for {checkout_request_id}. ResultCode: {result_code}, ResultDesc: {result_desc}")

        return {"ResultCode": 0, "ResultDesc": "Accepted"}, 200

payment_api.add_resource(DarajaCallback, '/callback')

# === ./server/app/resources/auth.py ===
from flask import request, jsonify, Blueprint
from flask_restful import Resource, Api
from marshmallow import ValidationError

from .. import db, bcrypt
from ..models import User
from ..schemas import user_schema

from flask_jwt_extended import create_access_token, jwt_required, get_jwt
from .. import BLOCKLIST

auth_bp = Blueprint('auth', __name__)
auth_api = Api(auth_bp)


class UserRegistration(Resource):
    def post(self):
        """
        Handles new user registration.
        """
        json_data = request.get_json()
        if not json_data:
            return {"message": "No input data provided"}, 400

        try:
            password = json_data.get('password')
            if not password:
                 return {'message': {'password': ['Missing data for required field.']}}, 400

            user_data = user_schema.load(json_data, session=db.session, unknown='EXCLUDE')

        except ValidationError as err:
            return {"message": "Validation errors", "errors": err.messages}, 400

        if User.query.filter_by(email=user_data.email).first():
            return {"message": "User with this email already exists"}, 409

        user = user_data

        user.set_password(password)

        try:
            db.session.add(user)
            db.session.commit()
            return {
                "message": "User created successfully",
                "user": user_schema.dump(user)
            }, 201
        except Exception as e:
            db.session.rollback()
            print(f"Error during registration: {e}")
            return {"message": "An error occurred during registration."}, 500


class UserLogin(Resource):
    def post(self):
       
        json_data = request.get_json()
        if not json_data:
            return {"message": "No input data provided"}, 400

        email = json_data.get('email')
        password = json_data.get('password')

        if not email or not password:
            return {"message": "Email and password are required"}, 400

        user = User.query.filter_by(email=email).first()

        if user and user.check_password(password):
            access_token = create_access_token(identity=user.id)
            return {"message": "Login successful", "access_token": access_token}, 200
        else:
            return {"message": "Invalid credentials"}, 401


class UserLogout(Resource):
    @jwt_required()
    def post(self):
        """
        Handles user logout by blocklisting the current JWT.
        """
        jti = get_jwt()["jti"]
        BLOCKLIST.add(jti)
        return {"message": "Successfully logged out"}, 200

auth_api.add_resource(UserRegistration, '/signup')
auth_api.add_resource(UserLogin, '/login')
auth_api.add_resource(UserLogout, '/logout')

# === ./server/app/utils/daraja_client.py ===
import base64
import requests
from datetime import datetime
from flask import current_app, jsonify
import time

token_cache = {}

def get_daraja_access_token():
    """Fetches a new Daraja access token or returns a cached one."""
    global token_cache
    current_time = time.time()

    if token_cache and token_cache.get('expires_at', 0) > current_time:
        print("DEBUG: Using cached Daraja token")
        return token_cache['token']

    print("DEBUG: Fetching new Daraja token")
    consumer_key = current_app.config['DARAJA_CONSUMER_KEY']
    consumer_secret = current_app.config['DARAJA_CONSUMER_SECRET']
    auth_url = current_app.config['DARAJA_AUTH_URL']

    if not consumer_key or not consumer_secret:
        print("ERROR: Daraja consumer key or secret not configured.")
        return None

    try:
        response = requests.get(auth_url, auth=(consumer_key, consumer_secret))
        response.raise_for_status()
        token_data = response.json()

        expires_in = int(token_data.get('expires_in', 3599))
        token_cache = {
            'token': token_data['access_token'],
            'expires_at': current_time + expires_in - 60
        }
        print("DEBUG: Fetched and cached new Daraja token.")
        return token_data['access_token']
    except requests.exceptions.RequestException as e:
        print(f"ERROR: Failed to get Daraja access token: {e}")
        print(f"Response status: {response.status_code if 'response' in locals() else 'N/A'}")
        print(f"Response text: {response.text if 'response' in locals() else 'N/A'}")
        return None
    except KeyError:
        print(f"ERROR: 'access_token' or 'expires_in' not found in Daraja auth response: {token_data}")
        return None


def generate_daraja_password(shortcode, passkey, timestamp):
    """Generates the Base64 encoded password for Daraja API calls."""
    password_str = f"{shortcode}{passkey}{timestamp}"
    password_bytes = password_str.encode('utf-8')
    encoded_password = base64.b64encode(password_bytes).decode('utf-8')
    return encoded_password


def initiate_stk_push(phone_number, amount, order_id, description="Shoply Purchase"):
    """Initiates an STK Push request."""
    access_token = get_daraja_access_token()
    if not access_token:
        return {"error": "Failed to obtain Daraja access token"}, 500

    stk_push_url = current_app.config['DARAJA_STK_PUSH_URL']
    shortcode = current_app.config['DARAJA_SHORTCODE']
    passkey = current_app.config['DARAJA_PASSKEY']
    callback_url = current_app.config['DARAJA_CALLBACK_URL']
    transaction_type = current_app.config['DARAJA_TRANSACTION_TYPE']

    amount = int(round(float(amount)))
    if not phone_number.startswith('254') or not phone_number.isdigit() or len(phone_number) != 12:
         print(f"ERROR: Invalid phone number format: {phone_number}")
         return {"error": "Invalid phone number format. Use 254XXXXXXXXX."}, 400

    timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
    password = generate_daraja_password(shortcode, passkey, timestamp)

    headers = {
        'Authorization': f'Bearer {access_token}',
        'Content-Type': 'application/json'
    }

    payload = {
        "BusinessShortCode": shortcode,
        "Password": password,
        "Timestamp": timestamp,
        "TransactionType": transaction_type,
        "Amount": amount,
        "PartyA": phone_number,
        "PartyB": shortcode,
        "PhoneNumber": phone_number,
        "CallBackURL": callback_url,
        "AccountReference": str(order_id),
        "TransactionDesc": description
    }

    print(f"DEBUG: Initiating STK Push with payload: {payload}")

    try:
        response = requests.post(stk_push_url, json=payload, headers=headers)
        response.raise_for_status()
        response_data = response.json()
        print(f"DEBUG: STK Push Response: {response_data}")
        return response_data, 200
    except requests.exceptions.RequestException as e:
        print(f"ERROR: STK Push request failed: {e}")
        print(f"Response status: {response.status_code if 'response' in locals() else 'N/A'}")
        print(f"Response text: {response.text if 'response' in locals() else 'N/A'}")
        error_message = "Failed to initiate payment."
        try:
            error_details = response.json()
            error_message = error_details.get('errorMessage', error_message)
        except:
            pass
        return {"error": error_message}, getattr(response, 'status_code', 500)
    except Exception as e:
        print(f"ERROR: Unexpected error during STK Push: {e}")
        return {"error": "An unexpected error occurred during payment initiation."}, 500

# === ./main/node_modules/flatted/python/flatted.py ===
# ISC License
#
# Copyright (c) 2018-2025, Andrea Giammarchi, @WebReflection
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
# INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
# LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
# OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
# PERFORMANCE OF THIS SOFTWARE.

import json as _json

class _Known:
    def __init__(self):
        self.key = []
        self.value = []

class _String:
    def __init__(self, value):
        self.value = value


def _array_keys(value):
    keys = []
    i = 0
    for _ in value:
        keys.append(i)
        i += 1
    return keys

def _object_keys(value):
    keys = []
    for key in value:
        keys.append(key)
    return keys

def _is_array(value):
    return isinstance(value, (list, tuple))

def _is_object(value):
    return isinstance(value, dict)

def _is_string(value):
    return isinstance(value, str)

def _index(known, input, value):
    input.append(value)
    index = str(len(input) - 1)
    known.key.append(value)
    known.value.append(index)
    return index

def _loop(keys, input, known, output):
    for key in keys:
        value = output[key]
        if isinstance(value, _String):
            _ref(key, input[int(value.value)], input, known, output)

    return output

def _ref(key, value, input, known, output):
    if _is_array(value) and value not in known:
        known.append(value)
        value = _loop(_array_keys(value), input, known, value)
    elif _is_object(value) and value not in known:
        known.append(value)
        value = _loop(_object_keys(value), input, known, value)

    output[key] = value

def _relate(known, input, value):
    if _is_string(value) or _is_array(value) or _is_object(value):
        try:
            return known.value[known.key.index(value)]
        except:
            return _index(known, input, value)

    return value

def _transform(known, input, value):
    if _is_array(value):
        output = []
        for val in value:
            output.append(_relate(known, input, val))
        return output

    if _is_object(value):
        obj = {}
        for key in value:
            obj[key] = _relate(known, input, value[key])
        return obj

    return value

def _wrap(value):
    if _is_string(value):
        return _String(value)

    if _is_array(value):
        i = 0
        for val in value:
            value[i] = _wrap(val)
            i += 1

    elif _is_object(value):
        for key in value:
            value[key] = _wrap(value[key])

    return value

def parse(value, *args, **kwargs):
    json = _json.loads(value, *args, **kwargs)
    wrapped = []
    for value in json:
        wrapped.append(_wrap(value))

    input = []
    for value in wrapped:
        if isinstance(value, _String):
            input.append(value.value)
        else:
            input.append(value)

    value = input[0]

    if _is_array(value):
        return _loop(_array_keys(value), input, [value], value)

    if _is_object(value):
        return _loop(_object_keys(value), input, [value], value)

    return value


def stringify(value, *args, **kwargs):
    known = _Known()
    input = []
    output = []
    i = int(_index(known, input, value))
    while i < len(input):
        output.append(_transform(known, input, input[i]))
        i += 1
    return _json.dumps(output, *args, **kwargs)
