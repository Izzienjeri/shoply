# Extracted Code (.ts, .tsx, .css)
# Date and Time: 2025-05-23 04:35:36
# Files Included: 20

# === lib/utils.ts ===
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}


export const formatPrice = (priceString: string | number): string => {
  const price = typeof priceString === 'string' ? parseFloat(priceString) : priceString;
  if (isNaN(price)) return 'N/A';
  return `Ksh ${price.toLocaleString('en-KE', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
}

# === lib/api.ts ===
import { getAuthToken, clearAuthToken } from '../contexts/AuthContext'

const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL;

interface RequestOptions extends RequestInit {
  needsAuth?: boolean;
  isFormData?: boolean;
}

async function request<T>(
  endpoint: string,
  options: RequestOptions = {}
): Promise<T | null> {
  const url = `${API_BASE_URL}${endpoint}`;
  const headers: HeadersInit = options.isFormData ? {} : { 'Content-Type': 'application/json' };
  let body = options.body;

  if (options.needsAuth) {
    const token = getAuthToken();
    if (token) {
      (headers as Record<string, string>)['Authorization'] = `Bearer ${token}`;
    } else {
      console.warn('Auth token needed but not found for', endpoint);
       throw new Error("Authentication required.");
    }
  }

  if (body && !options.isFormData && typeof body !== 'string') {
     body = JSON.stringify(body);
  }

  try {
    const response = await fetch(url, {
      ...options,
      headers,
      body,
    });

    if (!response.ok) {
      if (response.status === 401) {
         console.error('Unauthorized request to', endpoint);
      }
      let errorData;
      try {
         errorData = await response.json();
      } catch (parseError) {
         errorData = { message: response.statusText || `Request failed with status ${response.status}` };
      }
      console.error(`API Error (${response.status}):`, errorData);
      throw new Error(errorData?.message || `Request failed with status ${response.status}`);
    }

    if (response.status === 204) {
      return null;
    }

    return await response.json() as T;

  } catch (error) {
    console.error('Network or API request error:', error);
    throw error;
  }
}

export const apiClient = {
  get: <T>(endpoint: string, options: Omit<RequestOptions, 'method' | 'body'> = {}) =>
    request<T>(endpoint, { ...options, method: 'GET' }),

  post: <T>(endpoint: string, body: any, options: Omit<RequestOptions, 'method' | 'body'> = {}) =>
    request<T>(endpoint, { ...options, method: 'POST', body }),

  put: <T>(endpoint: string, body: any, options: Omit<RequestOptions, 'method' | 'body'> = {}) =>
    request<T>(endpoint, { ...options, method: 'PUT', body }),

  patch: <T>(endpoint: string, body: any, options: Omit<RequestOptions, 'method' | 'body'> = {}) =>
    request<T>(endpoint, { ...options, method: 'PATCH', body }),

  delete: <T = void>(endpoint: string, options: Omit<RequestOptions, 'method' | 'body'> = {}) =>
    request<T>(endpoint, { ...options, method: 'DELETE' }),
};

# === lib/types.ts ===
// === lib/types.ts ===
export interface Artist {
  id: string;
  name: string;
  bio?: string;
  created_at: string;
  updated_at: string;
  artworks?: Pick<Artwork, 'id' | 'name' | 'image_url' | 'price' | 'artist' | 'stock_quantity' | 'description'>[]; // For artist detail page
}

export interface Artwork {
  id: string;
  name: string;
  description?: string;
  price: string; // Keep as string, backend sends Decimal as_string=True
  stock_quantity: number;
  created_at: string;
  updated_at: string;
  image_url?: string | null;
  artist_id: string; // Received from backend, but mostly use nested artist object
  artist: Pick<Artist, 'id' | 'name'>; // Artist summary
}

export interface CartItem {
  id: string;
  artwork_id: string;
  quantity: number;
  artwork: Pick<Artwork, 'id' | 'name' | 'price' | 'image_url' | 'artist' | 'stock_quantity'>;
}
export interface Cart {
  id: string;
  user_id: string;
  created_at: string;
  updated_at: string;
  items: CartItem[];
  total_price?: string; // Calculated by backend schema
}

export interface OrderItem {
  id: string;
  artwork_id: string;
  quantity: number;
  price_at_purchase: string; // Backend sends Decimal as_string=True
  artwork: Pick<Artwork, 'id' | 'name' | 'image_url' | 'artist'>;
}

export interface Order {
  id: string;
  user_id: string;
  total_price: string; // Backend sends Decimal as_string=True
  status: 'pending' | 'paid' | 'shipped' | 'delivered' | 'cancelled';
  created_at: string;
  updated_at: string;
  shipped_at?: string | null;
  shipping_address?: string | null;
  billing_address?: string | null;
  payment_gateway_ref?: string | null;
  items: OrderItem[];
}

export interface User {
  id: string;
  email: string;
  name?: string;
  address?: string;
  created_at: string;
  // password_hash is not sent to frontend
}

export interface ApiErrorResponse {
    message: string;
    errors?: Record<string, string[]>; // For validation errors
}

export interface LoginResponse {
    message: string;
    access_token: string;
    // Backend does not send user object on login
}

export interface SignupResponse {
    message: string;
    user: User; // Backend sends user object on signup
}

export interface StkPushInitiationResponse {
  message: string;
  CheckoutRequestID: string;
  ResponseDescription: string;
}

// Type for user data fetched from a /me endpoint (if it existed)
export interface UserProfile extends User {}

# === app/globals.css ===
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --font-family-sans: var(--font-montserrat), sans-serif;
  --font-family-serif: var(--font-playfair), serif;
  --font-family-mono: var(--font-geist-mono), monospace;

  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

:root {

  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.147 0.004 49.25);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.147 0.004 49.25);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.147 0.004 49.25);
  --primary: oklch(0.216 0.006 56.043);
  --primary-foreground: oklch(0.985 0.001 106.423);
  --secondary: oklch(0.97 0.001 106.424);
  --secondary-foreground: oklch(0.216 0.006 56.043);
  --muted: oklch(0.97 0.001 106.424);
  --muted-foreground: oklch(0.553 0.013 58.071);
  --accent: oklch(0.97 0.001 106.424);
  --accent-foreground: oklch(0.216 0.006 56.043);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.923 0.003 48.717);
  --input: oklch(0.923 0.003 48.717);
  --ring: oklch(0.709 0.01 56.259);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0.001 106.423);
  --sidebar-foreground: oklch(0.147 0.004 49.25);
  --sidebar-primary: oklch(0.216 0.006 56.043);
  --sidebar-primary-foreground: oklch(0.985 0.001 106.423);
  --sidebar-accent: oklch(0.97 0.001 106.424);
  --sidebar-accent-foreground: oklch(0.216 0.006 56.043);
  --sidebar-border: oklch(0.923 0.003 48.717);
  --sidebar-ring: oklch(0.709 0.01 56.259);
}

.dark {
  --background: oklch(0.147 0.004 49.25);
  --foreground: oklch(0.985 0.001 106.423);
  --card: oklch(0.216 0.006 56.043);
  --card-foreground: oklch(0.985 0.001 106.423);
  --popover: oklch(0.216 0.006 56.043);
  --popover-foreground: oklch(0.985 0.001 106.423);
  --primary: oklch(0.923 0.003 48.717);
  --primary-foreground: oklch(0.216 0.006 56.043);
  --secondary: oklch(0.268 0.007 34.298);
  --secondary-foreground: oklch(0.985 0.001 106.423);
  --muted: oklch(0.268 0.007 34.298);
  --muted-foreground: oklch(0.709 0.01 56.259);
  --accent: oklch(0.268 0.007 34.298);
  --accent-foreground: oklch(0.985 0.001 106.423);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.553 0.013 58.071);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.216 0.006 56.043);
  --sidebar-foreground: oklch(0.985 0.001 106.423);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0.001 106.423);
  --sidebar-accent: oklch(0.268 0.007 34.298);
  --sidebar-accent-foreground: oklch(0.985 0.001 106.423);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.553 0.013 58.071);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground font-sans;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }
}

# === app/layout.tsx ===
import type { Metadata } from "next";
import "./globals.css";
import { Playfair_Display, Montserrat } from 'next/font/google';
import { cn } from "@/lib/utils";
import { AuthProvider } from "@/contexts/AuthContext";
import { CartProvider } from "@/contexts/CartContext";
import { Navbar } from "@/components/layout/Navbar";
import { Footer } from "@/components/layout/Footer";
import { Toaster } from "@/components/ui/sonner";

const montserrat = Montserrat({
  subsets: ['latin'],
  weight: ['300', '400', '500', '600', '700'],
  variable: '--font-montserrat'
});

const playfair = Playfair_Display({
  subsets: ['latin'],
  weight: ['400', '700'],
  variable: '--font-playfair'
});

export const metadata: Metadata = {
  title: "Artistry Haven",
  description: "Discover and purchase unique artwork online.",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body
        className={cn(
          "min-h-screen bg-background font-sans antialiased flex flex-col",
          montserrat.variable,
          playfair.variable
        )}
      >
        <AuthProvider>
          <CartProvider>
            <Navbar />
            <main className="flex-grow container mx-auto px-4 py-8">
              {children}
            </main>
            <Footer />
            <Toaster richColors position="top-right" />
          </CartProvider>
        </AuthProvider>
      </body>
    </html>
  );
}

# === app/page.tsx ===
import { Button } from "@/components/ui/button";
import Link from "next/link";

export default function Home() {
  return (
    <div className="flex flex-col items-center justify-center text-center space-y-6 min-h-[calc(100vh-theme(spacing.16)-theme(spacing.16)-theme(spacing.12))]">
      <h1 className="text-4xl font-bold font-serif tracking-tight lg:text-5xl text-primary">
        Welcome to Artistry Haven
      </h1>
      <p className="max-w-xl text-lg text-muted-foreground">
        Discover unique and captivating artwork from talented artists around the world. Find the perfect piece to inspire your space.
      </p>
      <div>
        <Link href="/artworks">
          <Button size="lg">Explore Artwork</Button>
        </Link>
      </div>
    </div>
  );
}

# === app/cart/page.tsx ===
// === main/src/app/cart/page.tsx ===
'use client';

import React, { useState, useEffect, useRef, useCallback } from 'react';
import Link from 'next/link';
import Image from 'next/image';
import { useRouter } from 'next/navigation';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod';
import { toast } from 'sonner';

import { useCart } from '@/contexts/CartContext';
import { useAuth } from '@/contexts/AuthContext';
import { formatPrice, cn } from '@/lib/utils';
import { ApiErrorResponse, CartItem as CartItemType, StkPushInitiationResponse } from '@/lib/types';
import { apiClient } from '@/lib/api';

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Separator } from "@/components/ui/separator";
import { Card, CardContent, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Skeleton } from "@/components/ui/skeleton";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";


import { ShoppingCart, Trash2, Minus, Plus, Loader2, ImageOff, Info, CheckCircle, XCircle } from 'lucide-react';

interface PaymentTransactionStatusResponse {
    status: 'initiated' | 'pending_stk_initiation' | 'pending_confirmation' | 'successful' | 'failed_stk_initiation' | 'failed_stk_missing_id' | 'failed_underpaid' | 'failed_processing_error' | 'cancelled_by_user' | 'failed_daraja' | 'failed_timeout' | 'failed_missing_receipt' | 'not_found';
    checkout_request_id: string | null;
    message: string;
    order_id?: string;
}

const checkoutSchema = z.object({
  phoneNumber: z.string()
    .min(1, "Phone number is required")
    .length(12, "Phone number must be 12 digits (e.g. 2547XXXXXXXX)")
    .startsWith("254", "Phone number must start with 254")
    .regex(/^[0-9]+$/, "Phone number must contain only digits"),
});
type CheckoutFormValues = z.infer<typeof checkoutSchema>;

interface CartItemProps {
  item: CartItemType;
  onUpdateQuantity: (itemId: string, newQuantity: number) => Promise<void>;
  onRemoveItem: (itemId: string) => Promise<void>;
  isUpdating: boolean;
}

function CartItem({ item, onUpdateQuantity, onRemoveItem, isUpdating }: CartItemProps) {
  const [isQuantityUpdating, setIsQuantityUpdating] = useState(false);
  const [isRemoving, setIsRemoving] = useState(false);

  const handleQuantityChange = async (newQuantity: number) => {
    if (newQuantity < 1 || isQuantityUpdating || isUpdating) return;
    if (newQuantity > item.artwork.stock_quantity) {
        toast.error(`Only ${item.artwork.stock_quantity} items available for "${item.artwork.name}".`);
        return;
    }
    setIsQuantityUpdating(true);
    try {
      await onUpdateQuantity(item.id, newQuantity);
    } finally {
      setIsQuantityUpdating(false);
    }
  };

  const handleRemove = async () => {
    if (isRemoving || isUpdating) return;
    setIsRemoving(true);
    try {
      await onRemoveItem(item.id);
    } finally {
      setIsRemoving(false);
    }
  };

  const placeholderImage = "/placeholder-image.svg";

  return (
    <div className="flex items-start sm:items-center space-x-3 sm:space-x-4 py-4 border-b last:border-b-0 flex-col sm:flex-row">
      <div className="relative h-20 w-20 sm:h-24 sm:w-24 flex-shrink-0 overflow-hidden rounded-md border bg-muted mb-2 sm:mb-0">
        <Image
          src={item.artwork.image_url || placeholderImage}
          alt={item.artwork.name}
          fill
          sizes="(max-width: 640px) 20vw, 96px"
          className="object-cover"
          onError={(e) => {
            (e.target as HTMLImageElement).srcset = placeholderImage;
            (e.target as HTMLImageElement).src = placeholderImage;
          }}
        />
         {!item.artwork.image_url && <ImageOff className="absolute inset-0 m-auto h-8 w-8 text-muted-foreground" />}
      </div>

      <div className="flex-1 space-y-1 min-w-0">
        <Link href={`/artworks/${item.artwork.id}`} className="font-medium hover:text-primary transition-colors text-base sm:text-lg line-clamp-2">
          {item.artwork.name}
        </Link>
        <p className="text-xs sm:text-sm text-muted-foreground">By: {item.artwork.artist.name}</p>
        <p className="text-xs sm:text-sm font-medium">{formatPrice(item.artwork.price)}</p>
      </div>

      <div className="flex flex-row sm:flex-col items-center sm:items-end space-x-2 sm:space-x-0 sm:space-y-1 mt-2 sm:mt-0">
         <div className="flex items-center border rounded-md">
            <Button
              variant="ghost"
              size="icon"
              className="h-7 w-7 sm:h-8 sm:w-8"
              onClick={() => handleQuantityChange(item.quantity - 1)}
              disabled={item.quantity <= 1 || isQuantityUpdating || isUpdating}
              aria-label="Decrease quantity"
            >
              <Minus className="h-3 w-3 sm:h-4 sm:w-4" />
            </Button>
            <span className="w-7 text-center text-xs sm:text-sm font-medium">
                {isQuantityUpdating ? <Loader2 className="h-3 w-3 sm:h-4 sm:w-4 animate-spin mx-auto" /> : item.quantity}
            </span>
            <Button
              variant="ghost"
              size="icon"
              className="h-7 w-7 sm:h-8 sm:w-8"
              onClick={() => handleQuantityChange(item.quantity + 1)}
              disabled={isQuantityUpdating || isUpdating || item.quantity >= item.artwork.stock_quantity}
              aria-label="Increase quantity"
            >
              <Plus className="h-3 w-3 sm:h-4 sm:w-4" />
            </Button>
         </div>
        {item.artwork.stock_quantity > 0 && item.artwork.stock_quantity < 5 && (
            <p className="text-xs text-orange-600 mt-1">Only {item.artwork.stock_quantity} left</p>
        )}
        {item.artwork.stock_quantity === 0 && !isQuantityUpdating && (
             <p className="text-xs text-red-600 mt-1">Out of stock</p>
        )}
      </div>

      <div className="font-medium text-sm sm:text-base w-full sm:w-auto text-right sm:text-left mt-2 sm:mt-0">
        {formatPrice(parseFloat(item.artwork.price) * item.quantity)}
      </div>

      <Button
        variant="ghost"
        size="icon"
        className="h-7 w-7 sm:h-8 sm:w-8 text-muted-foreground hover:text-destructive ml-auto sm:ml-0"
        onClick={handleRemove}
        disabled={isRemoving || isUpdating}
        aria-label="Remove item"
      >
        {isRemoving ? <Loader2 className="h-3 w-3 sm:h-4 sm:w-4 animate-spin"/> : <Trash2 className="h-3 w-3 sm:h-4 sm:w-4" />}
      </Button>
    </div>
  );
}

export default function CartPage() {
  const {
    cart,
    isLoading: cartIsLoading,
    itemCount,
    totalPrice,
    updateCartItem,
    removeFromCart,
    fetchCart,
  } = useCart();
  const { isAuthenticated, isLoading: authIsLoading, user } = useAuth();
  const router = useRouter();

  const [isStkFlowActive, setIsStkFlowActive] = useState(false);
  const [stkCheckoutId, setStkCheckoutId] = useState<string | null>(null);
  const [pollingMessage, setPollingMessage] = useState<string>("Please complete the M-Pesa payment on your phone.");
  const [paymentStatus, setPaymentStatus] = useState<PaymentTransactionStatusResponse['status'] | null>(null);

  const pollingIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const pollingAttemptsRef = useRef<number>(0);

  const MAX_POLLING_ATTEMPTS = 24; 
  const POLLING_INTERVAL_MS = 5000;


  const checkoutForm = useForm<CheckoutFormValues>({
    resolver: zodResolver(checkoutSchema),
    defaultValues: {
      phoneNumber: "",
    },
  });

   useEffect(() => {
    if (user?.address && !isStkFlowActive) { 
        const potentialPhone = user.address.replace(/\D/g, '');
        if (potentialPhone.startsWith("254") && potentialPhone.length === 12) {
             checkoutForm.setValue("phoneNumber", potentialPhone);
        }
    }
   }, [user, checkoutForm, isStkFlowActive]);

  const stopPolling = useCallback(() => {
    if (pollingIntervalRef.current) {
      clearInterval(pollingIntervalRef.current);
      pollingIntervalRef.current = null;
    }
    pollingAttemptsRef.current = 0;
  }, []);

  const handlePaymentSuccess = useCallback((orderId?: string) => {
    stopPolling();
    setPaymentStatus('successful');
    setPollingMessage("Payment successful! Your order has been placed.");
    toast.success("Order Placed Successfully!", {
        description: "You can pick up your order at Dynamic Mall, Shop M90, CBD, Nairobi.",
        duration: 15000,
        action: orderId ? { label: "View Order", onClick: () => router.push(`/orders/${orderId}`) } : 
                         { label: "My Orders", onClick: () => router.push(`/orders`) },
    });
    fetchCart(); 
  }, [stopPolling, router, fetchCart]);

  const handlePaymentFailure = useCallback((message: string, finalStatus?: PaymentTransactionStatusResponse['status']) => {
    stopPolling();
    setPaymentStatus(finalStatus || 'failed_daraja');
    const displayMessage = message || "Payment failed or was cancelled. Please try again.";
    setPollingMessage(displayMessage);
    toast.error(displayMessage, { duration: 10000 });
  }, [stopPolling]);


  const pollPaymentStatus = useCallback(async (checkoutIdToPoll: string) => {
    if (!checkoutIdToPoll) { 
        console.warn("pollPaymentStatus called without checkoutIdToPoll");
        handlePaymentFailure("Cannot check payment status: Missing transaction ID.", "failed_processing_error");
        return;
    }
    if (pollingAttemptsRef.current >= MAX_POLLING_ATTEMPTS) {
      handlePaymentFailure("Payment confirmation timed out. If you paid, please check 'My Orders' or contact support.", 'failed_timeout');
      return;
    }

    pollingAttemptsRef.current += 1;
    setPollingMessage(`Checking payment status (attempt ${pollingAttemptsRef.current} of ${MAX_POLLING_ATTEMPTS})...`);

    try {
      const statusResponse = await apiClient.get<PaymentTransactionStatusResponse>(`/orders/status/${checkoutIdToPoll}`, { needsAuth: true });
      if (statusResponse) {
        setPaymentStatus(statusResponse.status); 
        
        if (statusResponse.status === 'successful') {
          handlePaymentSuccess(statusResponse.order_id);
        } else if (['failed_stk_initiation', 'failed_stk_missing_id', 'failed_underpaid', 'failed_processing_error', 'cancelled_by_user', 'failed_daraja', 'failed_timeout', 'failed_missing_receipt'].includes(statusResponse.status)) {
          handlePaymentFailure(statusResponse.message || "Payment process encountered an issue.", statusResponse.status);
        } else if (statusResponse.status === 'not_found') {
           handlePaymentFailure("Transaction details not found. This could be a delay or an issue. Please contact support if payment was made.", 'not_found');
        } else { // Pending states
           setPollingMessage(statusResponse.message || "Awaiting M-Pesa confirmation...");
        }
      } else { // Should ideally not happen if apiClient throws on non-OK
        setPollingMessage("Could not retrieve payment status. Still trying...");
      }
    } catch (error: any) {
      console.error("Polling error:", error);
      if (error.message?.includes('404') || error.message?.toLowerCase().includes('not found')) {
        handlePaymentFailure("Could not find this transaction to check its status. If you paid, contact support.", 'not_found');
      } else {
        setPollingMessage("Error checking status. Retrying...");
      }
    }
  }, [handlePaymentSuccess, handlePaymentFailure]); // Dependencies for useCallback


  useEffect(() => {
    const isFinalSuccessState = paymentStatus === 'successful';
    const isFinalNonSuccessState = 
        paymentStatus === 'failed_stk_initiation' ||
        paymentStatus === 'failed_stk_missing_id' ||
        paymentStatus === 'failed_underpaid' ||
        paymentStatus === 'failed_processing_error' ||
        paymentStatus === 'cancelled_by_user' ||
        paymentStatus === 'failed_daraja' ||
        paymentStatus === 'failed_timeout' ||
        paymentStatus === 'failed_missing_receipt' ||
        paymentStatus === 'not_found';

    if (stkCheckoutId && isStkFlowActive && 
        !isFinalSuccessState && 
        !isFinalNonSuccessState &&
        !pollingIntervalRef.current) { 
          
      pollingAttemptsRef.current = 0;
      if (paymentStatus === null || paymentStatus === 'initiated' || paymentStatus === 'pending_stk_initiation') {
         setPollingMessage("Waiting for M-Pesa confirmation..."); 
      }
      
      pollPaymentStatus(stkCheckoutId);
      
      // After initial poll, re-check conditions to set interval
      // This logic needs to be careful not to miss the state update from the first pollPaymentStatus call
      // It's safer to let the interval start and let pollPaymentStatus handle stopping via final states.
      if (!pollingIntervalRef.current) { // Check again ensures it wasn't stopped by the first poll
        pollingIntervalRef.current = setInterval(() => {
            if (stkCheckoutId) { 
                 pollPaymentStatus(stkCheckoutId);
            } else {
                stopPolling(); 
            }
        }, POLLING_INTERVAL_MS);
      }
    } else if (isFinalSuccessState || isFinalNonSuccessState) {
        // If a final state is reached (possibly by an update outside this effect's direct initiation)
        stopPolling();
    }
    
    return () => {
      stopPolling();
    };
  }, [stkCheckoutId, isStkFlowActive, paymentStatus, pollPaymentStatus, stopPolling]);


  const handleInitiateCheckout = async (data: CheckoutFormValues) => {
    setIsStkFlowActive(true); 
    setStkCheckoutId(null);   
    setPaymentStatus('initiated'); 
    setPollingMessage("Initiating M-Pesa payment...");

    try {
      const response = await apiClient.post<StkPushInitiationResponse & { transaction_id?: string }>(
          '/orders/', 
          { phone_number: data.phoneNumber },
          { needsAuth: true }
      );

      if (response && response.CheckoutRequestID) {
        toast.info("STK Push sent! Please authorize payment on your phone.", { duration: 10000 });
        setStkCheckoutId(response.CheckoutRequestID); 
      } else {
        const message = response?.message || response?.ResponseDescription || "Failed to initiate payment. No Checkout ID received.";
        handlePaymentFailure(message, 'failed_stk_initiation');
      }
    } catch (error: any) {
        console.error("Checkout initiation failed:", error);
        handlePaymentFailure(error.message || "Failed to initiate M-Pesa payment.", 'failed_stk_initiation');
    }
  };

  // --- Render logic ---

  if (authIsLoading) { 
    return <div className="flex justify-center items-center p-10 min-h-[300px]"><Loader2 className="h-8 w-8 animate-spin text-primary"/></div>;
  }
  if (!isAuthenticated) { 
    return (
      <div className="text-center py-10 min-h-[300px] flex flex-col justify-center items-center">
        <ShoppingCart className="mx-auto h-12 w-12 text-muted-foreground" />
        <h2 className="mt-4 text-xl font-semibold">Your Cart is Empty</h2>
        <p className="mt-2 text-muted-foreground">Please log in to view or add items to your cart.</p>
        <Button asChild className="mt-4">
          <Link href="/login?redirect=/cart">Log In</Link>
        </Button>
      </div>
    );
  }

  if (isStkFlowActive) {
    let statusIcon = <Loader2 className="h-12 w-12 animate-spin text-primary" />;
    let statusTitle = "Processing Payment...";
    let alertVariantForComponent: "default" | "destructive" = "default"; 
    let successAlertClasses = ""; 

    if (paymentStatus === 'successful') {
        statusIcon = <CheckCircle className="h-12 w-12 text-green-600" />;
        statusTitle = "Payment Successful!";
        alertVariantForComponent = "default"; 
        successAlertClasses = "bg-green-50 border-green-500 text-green-700 dark:bg-green-900/20 dark:border-green-700 dark:text-green-400";
    } else if (paymentStatus && (paymentStatus.startsWith('failed') || paymentStatus === 'cancelled_by_user' || paymentStatus === 'not_found')) {
        statusIcon = <XCircle className="h-12 w-12 text-red-600" />;
        statusTitle = "Payment Issue";
        alertVariantForComponent = "destructive"; 
    } else if (stkCheckoutId || paymentStatus === 'initiated' || paymentStatus === 'pending_stk_initiation' || paymentStatus === 'pending_confirmation') { 
        statusTitle = "Waiting for M-Pesa Confirmation...";
        alertVariantForComponent = "default";
    }


    return (
        <div className="text-center py-10 flex flex-col items-center space-y-6 min-h-[calc(100vh-200px)] justify-center">
            {statusIcon}
            <h2 className="text-2xl font-semibold">
                {statusTitle}
            </h2>
            
            <Alert 
                variant={alertVariantForComponent} 
                className={cn("max-w-md text-left", successAlertClasses)}
            >
                {/* Conditionally render leading icon within Alert based on its structure */}
                {/* For shadcn, Alert > svg + AlertTitle + AlertDescription */}
                {paymentStatus === 'successful' && <CheckCircle className="h-4 w-4" />}
                {paymentStatus && (paymentStatus.startsWith('failed') || paymentStatus === 'cancelled_by_user' || paymentStatus === 'not_found') && <XCircle className="h-4 w-4" />}
                {/* Show loader if stkCheckoutId is present AND status is one of the loading states */}
                {stkCheckoutId && (paymentStatus === null || paymentStatus === 'pending_confirmation' || paymentStatus === 'initiated' || paymentStatus === 'pending_stk_initiation') && <Loader2 className="h-4 w-4 animate-spin" />}
                
                <AlertTitle className="capitalize">
                    {paymentStatus ? paymentStatus.replace(/_/g, ' ') : "Status"}
                 </AlertTitle>
                <AlertDescription>
                    {pollingMessage || "Please wait while we confirm your payment."}
                </AlertDescription>
            </Alert>

            {(paymentStatus === 'successful') && (
                <Card className={cn("mt-4 p-4 max-w-lg", successAlertClasses)}> 
                    <div className="flex items-start space-x-3">
                        <Info className={cn("h-5 w-5 flex-shrink-0 mt-0.5", paymentStatus === 'successful' ? "text-green-700 dark:text-green-400" : "")}/>
                        <div>
                            <p className="font-semibold">Order Confirmed! Pickup Information:</p>
                            <p className="text-sm">
                                You can pick up your order at: <br />
                                <strong>Dynamic Mall, Shop M90, CBD, Nairobi.</strong>
                            </p>
                        </div>
                    </div>
                </Card>
            )}
            
            <div className="flex space-x-4 pt-4">
              {paymentStatus !== 'successful' && (
                  <Button 
                    onClick={() => { 
                        stopPolling(); 
                        setIsStkFlowActive(false); 
                        setPaymentStatus(null); 
                        setStkCheckoutId(null);
                        checkoutForm.reset(); 
                    }} 
                    variant="outline"
                  >
                      { paymentStatus && (paymentStatus.startsWith('failed') || paymentStatus === 'cancelled_by_user' || paymentStatus === 'not_found') ? "Try Again / Back to Cart" : "Cancel & Back to Cart"}
                  </Button>
              )}
              <Button onClick={() => router.push('/orders')}>
                  {paymentStatus === 'successful' ? 'View My Orders' : 'Check My Orders'}
              </Button>
            </div>
        </div>
    );
  }

  if (cartIsLoading && !cart && !isStkFlowActive) { 
    return (
        <div>
             <h1 className="text-3xl font-bold tracking-tight mb-6 font-serif">Your Cart</h1>
             <div className="space-y-4">
                <Skeleton className="h-28 w-full" />
                <Skeleton className="h-28 w-full" />
             </div>
              <div className="mt-6">
                  <Skeleton className="h-10 w-1/3 ml-auto" />
                  <Skeleton className="h-12 w-full mt-4" />
              </div>
        </div>
    );
  }
  if ((!cart || itemCount === 0) && !isStkFlowActive) { 
     return (
      <div className="text-center py-10 min-h-[300px] flex flex-col justify-center items-center">
        <ShoppingCart className="mx-auto h-12 w-12 text-muted-foreground" />
        <h2 className="mt-4 text-xl font-semibold">Your Cart is Empty</h2>
        <p className="mt-2 text-muted-foreground">Add some amazing artwork to get started.</p>
        <Button asChild className="mt-4">
          <Link href="/artworks">Explore Artwork</Link>
        </Button>
      </div>
    );
  }

  return (
    <div>
      <h1 className="text-3xl font-bold tracking-tight mb-6 font-serif">Your Cart ({itemCount} {itemCount === 1 ? 'item' : 'items'})</h1>
      <div className="lg:grid lg:grid-cols-3 lg:gap-8">
        <div className="lg:col-span-2">
          <Card>
            <CardHeader>
              <CardTitle>Items in your cart</CardTitle>
            </CardHeader>
            <CardContent className="p-0">
              <div className="divide-y">
                 {cart?.items.map((item) => ( 
                   <div key={item.id} className="px-4 sm:px-6">
                       <CartItem
                         item={item}
                         onUpdateQuantity={updateCartItem}
                         onRemoveItem={removeFromCart}
                         isUpdating={cartIsLoading} 
                       />
                   </div>
                 ))}
              </div>
            </CardContent>
          </Card>
        </div>

        <div className="lg:col-span-1 mt-8 lg:mt-0">
          <Card>
            <CardHeader>
              <CardTitle>Order Summary</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="flex justify-between">
                <span>Subtotal</span>
                <span>{formatPrice(totalPrice)}</span>
              </div>
              <Separator />
              <div className="flex justify-between font-semibold text-lg">
                <span>Total</span>
                <span>{formatPrice(totalPrice)}</span>
              </div>
            </CardContent>
            <CardFooter className="flex-col items-stretch space-y-4">
                <h3 className="text-lg font-semibold">Checkout with M-Pesa</h3>
                 <Form {...checkoutForm}>
                    <form onSubmit={checkoutForm.handleSubmit(handleInitiateCheckout)} className="space-y-4">
                         <FormField
                            control={checkoutForm.control}
                            name="phoneNumber"
                            render={({ field }) => ( 
                              <FormItem>
                                <FormLabel>M-Pesa Phone Number</FormLabel>
                                <FormControl>
                                  <Input type="tel" placeholder="2547XXXXXXXX" {...field} />
                                </FormControl>
                                <FormMessage />
                              </FormItem>
                            )}
                          />
                         <Button type="submit" className="w-full" 
                                 disabled={isStkFlowActive || itemCount === 0 || cartIsLoading || authIsLoading}> 
                            {isStkFlowActive ? ( 
                                <>
                                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                                    Processing... 
                                </>
                            ) : (
                                "Place Order & Pay with M-Pesa"
                            )}
                         </Button>
                    </form>
                 </Form>
                 <p className="text-xs text-muted-foreground text-center">
                    Pickup at: <strong>Dynamic Mall, Shop M90, CBD, Nairobi.</strong>
                 </p>
            </CardFooter>
          </Card>
        </div>
      </div>
    </div>
  );
}

# === app/orders/page.tsx ===
// === app/orders/page.tsx ===
'use client';

import React, { useEffect, useState } from 'react';
import Link from 'next/link';
import Image from 'next/image';
import { Order as OrderType, OrderItem as OrderItemType } from '@/lib/types';
import { apiClient } from '@/lib/api';
import { useAuth } from '@/contexts/AuthContext';
import { formatPrice } from '@/lib/utils';

import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/ui/accordion";
import { Badge } from "@/components/ui/badge";
import { Skeleton } from "@/components/ui/skeleton";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Separator } from "@/components/ui/separator";
import { ListOrdered, Package, ShoppingBag, Loader2, ArrowLeft, ImageOff, Terminal } from 'lucide-react';
import { useRouter } from 'next/navigation';

function OrderItemCard({ item }: { item: OrderItemType }) {
  const placeholderImage = "/placeholder-image.svg";
  return (
    <div className="flex items-center space-x-4 py-3">
      <div className="relative h-16 w-16 flex-shrink-0 overflow-hidden rounded-md border bg-muted">
        <Image
          src={item.artwork.image_url || placeholderImage}
          alt={item.artwork.name}
          fill
          sizes="64px"
          className="object-cover"
          onError={(e) => {
            (e.target as HTMLImageElement).srcset = placeholderImage;
            (e.target as HTMLImageElement).src = placeholderImage;
          }}
        />
        {!item.artwork.image_url && <ImageOff className="absolute inset-0 m-auto h-6 w-6 text-muted-foreground" />}
      </div>
      <div className="flex-1 space-y-1">
        <h4 className="font-medium hover:underline text-sm">{item.artwork.name}</h4>
        <p className="text-xs text-muted-foreground">By {item.artwork.artist.name}</p>
        <p className="text-xs text-muted-foreground">
          Qty: {item.quantity} @ {formatPrice(item.price_at_purchase)}
        </p>
      </div>
      <div className="font-medium text-sm">{formatPrice(parseFloat(item.price_at_purchase) * item.quantity)}</div>
    </div>
  );
}

function OrderCardSkeleton() {
  return (
    <Card>
      <CardHeader>
        <Skeleton className="h-6 w-3/4" />
        <Skeleton className="h-4 w-1/2 mt-1" />
      </CardHeader>
      <CardContent className="space-y-3">
        <Skeleton className="h-4 w-full" />
        <Skeleton className="h-4 w-5/6" />
      </CardContent>
      <CardFooter>
        <Skeleton className="h-8 w-1/4" />
      </CardFooter>
    </Card>
  );
}


export default function OrdersPage() {
  const { isAuthenticated, isLoading: authIsLoading, user } = useAuth();
  const router = useRouter();
  const [orders, setOrders] = useState<OrderType[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (authIsLoading) return;

    if (!isAuthenticated) {
      router.replace('/login?redirect=/orders');
      return;
    }

    const fetchOrders = async () => {
      setIsLoading(true);
      setError(null);
      try {
        const fetchedOrders = await apiClient.get<OrderType[]>('/orders/', { needsAuth: true });
        setOrders(fetchedOrders || []);
      } catch (err: any) {
        console.error("Failed to fetch orders:", err);
        setError(err.message || "An unknown error occurred");
      } finally {
        setIsLoading(false);
      }
    };

    fetchOrders();
  }, [isAuthenticated, authIsLoading, router]);

  if (authIsLoading || (isLoading && orders.length === 0 && !error)) {
    return (
      <div>
        <h1 className="text-3xl font-bold tracking-tight mb-8 font-serif">My Orders</h1>
        <div className="space-y-6">
          {Array.from({ length: 3 }).map((_, index) => (
            <OrderCardSkeleton key={index} />
          ))}
        </div>
      </div>
    );
  }
  
  if (!isAuthenticated && !authIsLoading) {
      // This case should ideally be handled by the redirect, but as a fallback:
      return (
        <div className="text-center py-10">
          <Package className="mx-auto h-12 w-12 text-muted-foreground" />
          <h2 className="mt-4 text-xl font-semibold">Access Denied</h2>
          <p className="mt-2 text-muted-foreground">Please log in to view your orders.</p>
          <Button asChild className="mt-4">
            <Link href="/login?redirect=/orders">Log In</Link>
          </Button>
        </div>
      );
  }


  return (
    <div className="max-w-4xl mx-auto">
      <div className="flex items-center justify-between mb-8">
        <h1 className="text-3xl font-bold tracking-tight font-serif flex items-center">
            <ListOrdered className="mr-3 h-8 w-8 text-primary" /> My Orders
        </h1>
      </div>

      {error && (
        <Alert variant="destructive" className="mb-6">
          <Terminal className="h-4 w-4" />
          <AlertTitle>Error Fetching Orders</AlertTitle>
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      {isLoading && orders.length === 0 && !error && ( // Show skeletons if loading and no orders yet
         <div className="space-y-6">
            {Array.from({ length: 3 }).map((_, index) => (<OrderCardSkeleton key={index} />))}
         </div>
      )}


      {!isLoading && !error && orders.length === 0 && (
        <div className="text-center py-16 border-2 border-dashed border-gray-300 rounded-lg">
          <ShoppingBag className="mx-auto h-16 w-16 text-gray-400 mb-4" />
          <h2 className="text-2xl font-semibold text-gray-700 mb-2">No Orders Yet</h2>
          <p className="text-muted-foreground mb-6">
            You haven't placed any orders. Start exploring our artwork!
          </p>
          <Button asChild>
            <Link href="/artworks">Explore Artwork</Link>
          </Button>
        </div>
      )}

      {orders.length > 0 && (
        <Accordion type="single" collapsible className="w-full space-y-4">
          {orders.map((order) => (
            <AccordionItem value={order.id} key={order.id} className="bg-card border rounded-lg shadow-sm">
              <AccordionTrigger className="px-6 py-4 hover:no-underline">
                <div className="flex flex-col md:flex-row justify-between md:items-center w-full">
                    <div className="text-left">
                        <span className="font-medium text-primary">Order ID: {order.id.substring(0,8)}...</span>
                        <p className="text-xs text-muted-foreground mt-1">
                            Placed on: {new Date(order.created_at).toLocaleDateString()}
                        </p>
                    </div>
                    <div className="flex flex-col md:flex-row md:items-center md:space-x-4 mt-2 md:mt-0">
                         <Badge variant={
                            order.status === 'paid' || order.status === 'delivered' ? 'default' :
                            order.status === 'pending' ? 'secondary' :
                            order.status === 'shipped' ? 'outline' : // Needs custom color or use default
                            'destructive'
                         } className="capitalize mb-1 md:mb-0 w-fit md:w-auto">
                            {order.status}
                         </Badge>
                        <span className="font-semibold text-sm md:text-base">{formatPrice(order.total_price)}</span>
                    </div>
                </div>
              </AccordionTrigger>
              <AccordionContent className="px-6 pb-4 pt-0">
                <Separator className="mb-4" />
                <h3 className="text-sm font-semibold mb-2 text-muted-foreground">Items in this order:</h3>
                <div className="space-y-2 divide-y">
                  {order.items.map((item) => (
                    <OrderItemCard key={item.id} item={item} />
                  ))}
                </div>
                {order.shipping_address && (
                    <>
                        <Separator className="my-4" />
                        <div className="text-xs text-muted-foreground">
                            <p><strong>Shipping Address:</strong> {order.shipping_address}</p>
                            {order.payment_gateway_ref && <p><strong>M-Pesa Ref:</strong> {order.payment_gateway_ref}</p>}
                        </div>
                    </>
                )}
              </AccordionContent>
            </AccordionItem>
          ))}
        </Accordion>
      )}
    </div>
  );
}

# === app/login/page.tsx ===
'use client';

import React, { useState, useEffect } from 'react';
import Link from 'next/link';
import { useRouter } from 'next/navigation';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod';
import { toast } from 'sonner';

import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { useAuth } from '@/contexts/AuthContext';
import { ApiErrorResponse } from '@/lib/types';

const loginSchema = z.object({
  email: z.string().email({ message: "Invalid email address." }),
  password: z.string().min(1, { message: "Password is required." }),
});

type LoginFormValues = z.infer<typeof loginSchema>;

export default function LoginPage() {
  const router = useRouter();
  const { login, isAuthenticated, isLoading: isAuthLoading } = useAuth();
  const [isSubmitting, setIsSubmitting] = useState(false);

  const form = useForm<LoginFormValues>({
    resolver: zodResolver(loginSchema),
    defaultValues: {
      email: "",
      password: "",
    },
  });

  useEffect(() => {
    if (!isAuthLoading && isAuthenticated) {
        router.push('/');
    }
  }, [isAuthenticated, isAuthLoading, router]);

  const onSubmit = async (data: LoginFormValues) => {
    setIsSubmitting(true);
    try {
      await login(data.email, data.password);
      toast.success("Login successful!");
    } catch (error: any) {
        console.error("Login failed:", error);
        const errorMessage = (error as ApiErrorResponse)?.message || "An error occurred during login.";
        toast.error(errorMessage);
    } finally {
      setIsSubmitting(false);
    }
  };

  if (isAuthLoading || isAuthenticated) {
      return <div className="flex justify-center items-center min-h-[200px]">Loading...</div>;
  }

  return (
    <div className="flex items-center justify-center py-12">
      <Card className="w-full max-w-md">
        <CardHeader>
          <CardTitle>Login</CardTitle>
          <CardDescription>Access your Artistry Haven account.</CardDescription>
        </CardHeader>
        <CardContent>
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Email</FormLabel>
                    <FormControl>
                      <Input type="email" placeholder="you@example.com" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Password</FormLabel>
                    <FormControl>
                      <Input type="password" placeholder="••••••••" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit" className="w-full" disabled={isSubmitting}>
                {isSubmitting ? "Logging In..." : "Login"}
              </Button>
            </form>
          </Form>
        </CardContent>
        <CardFooter className="text-sm text-center block">
          Don't have an account?{" "}
          <Link href="/signup" className="underline hover:text-primary">
            Sign up
          </Link>
        </CardFooter>
      </Card>
    </div>
  );
}

# === app/signup/page.tsx ===
'use client';

import React, { useState } from 'react';
import Link from 'next/link';
import { useRouter } from 'next/navigation';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod';
import { toast } from 'sonner';

import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { useAuth } from '@/contexts/AuthContext';
import { ApiErrorResponse } from '@/lib/types';

const signupSchema = z.object({
  name: z.string().min(2, { message: "Name must be at least 2 characters." }).optional(),
  email: z.string().email({ message: "Invalid email address." }),
  password: z.string().min(8, { message: "Password must be at least 8 characters." }),
  address: z.string().optional(),
});

type SignupFormValues = z.infer<typeof signupSchema>;

export default function SignupPage() {
  const router = useRouter();
  const { signup } = useAuth();
  const [isLoading, setIsLoading] = useState(false);

  const form = useForm<SignupFormValues>({
    resolver: zodResolver(signupSchema),
    defaultValues: {
      name: "",
      email: "",
      password: "",
      address: "",
    },
  });

  const onSubmit = async (data: SignupFormValues) => {
    setIsLoading(true);
    try {
      await signup(data);
      toast.success("Signup successful! Please log in.");
      router.push('/login');
    } catch (error: any) {
        console.error("Signup failed:", error);
        const errorMessage = (error as ApiErrorResponse)?.message || "An error occurred during signup.";
        toast.error(errorMessage);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="flex items-center justify-center py-12">
      <Card className="w-full max-w-md">
        <CardHeader>
          <CardTitle>Sign Up</CardTitle>
          <CardDescription>Create your Artistry Haven account.</CardDescription>
        </CardHeader>
        <CardContent>
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
              <FormField
                control={form.control}
                name="name"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Name (Optional)</FormLabel>
                    <FormControl>
                      <Input placeholder="Your Name" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Email</FormLabel>
                    <FormControl>
                      <Input type="email" placeholder="you@example.com" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Password</FormLabel>
                    <FormControl>
                      <Input type="password" placeholder="••••••••" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
               <FormField
                control={form.control}
                name="address"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Address (Optional)</FormLabel>
                    <FormControl>
                      <Input placeholder="123 Art Street" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit" className="w-full" disabled={isLoading}>
                {isLoading ? "Signing Up..." : "Sign Up"}
              </Button>
            </form>
          </Form>
        </CardContent>
        <CardFooter className="text-sm text-center block">
          Already have an account?{" "}
          <Link href="/login" className="underline hover:text-primary">
            Log in
          </Link>
        </CardFooter>
      </Card>
    </div>
  );
}

# === app/artists/page.tsx ===
// === app/artists/page.tsx ===
'use client';

import React, { useState, useEffect } from 'react';
import Link from 'next/link';
import { Artist } from '@/lib/types';
import { apiClient } from '@/lib/api';

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Skeleton } from "@/components/ui/skeleton";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Terminal, UserIcon } from "lucide-react";

interface ArtistCardProps {
  artist: Artist;
}

function ArtistCard({ artist }: ArtistCardProps) {
  return (
    <Link href={`/artists/${artist.id}`} className="block group"> {/* Removed legacyBehavior */}
      <Card className="h-full hover:shadow-lg transition-shadow duration-200">
        <CardHeader className="flex flex-row items-center space-x-4 pb-2">
          <div className="p-3 rounded-full bg-muted group-hover:bg-primary/10 transition-colors">
              <UserIcon className="h-6 w-6 text-muted-foreground group-hover:text-primary transition-colors" />
          </div>
          <CardTitle className="text-xl group-hover:text-primary transition-colors">{artist.name}</CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-sm text-muted-foreground line-clamp-3">
            {artist.bio || "No biography available."}
          </p>
        </CardContent>
      </Card>
    </Link>
  );
}

function ArtistCardSkeleton() {
  return (
    <Card>
      <CardHeader className="flex flex-row items-center space-x-4 pb-2">
        <Skeleton className="h-12 w-12 rounded-full" />
        <Skeleton className="h-6 w-3/5" />
      </CardHeader>
      <CardContent>
        <Skeleton className="h-4 w-full mb-2" />
        <Skeleton className="h-4 w-4/5" />
      </CardContent>
    </Card>
  );
}

export default function ArtistsPage() {
  const [artists, setArtists] = useState<Artist[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchArtists = async () => {
      setIsLoading(true);
      setError(null);
      try {
        const fetchedArtists = await apiClient.get<Artist[]>('/artists/');
        setArtists(fetchedArtists || []);
      } catch (err: any) {
        console.error("Failed to fetch artists:", err);
        setError(err.message || "An unknown error occurred");
      } finally {
        setIsLoading(false);
      }
    };

    fetchArtists();
  }, []);

  return (
    <div>
      <h1 className="text-3xl font-bold tracking-tight mb-8 font-serif">
        Discover Our Artists
      </h1>

      {error && (
        <Alert variant="destructive" className="mb-6">
          <Terminal className="h-4 w-4" />
          <AlertTitle>Error Fetching Artists</AlertTitle>
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
        {isLoading ? (
          Array.from({ length: 6 }).map((_, index) => (
            <ArtistCardSkeleton key={index} />
          ))
        ) : artists.length > 0 ? (
          artists.map((artist) => (
            <ArtistCard key={artist.id} artist={artist} />
          ))
        ) : (
          !error && (
            <div className="col-span-full text-center py-10 text-muted-foreground">
              <UserIcon className="h-16 w-16 mx-auto mb-4 text-gray-400" />
              <p className="text-xl">No artists found at the moment.</p>
              <p>Check back later to discover talented creators.</p>
            </div>
          )
        )}
      </div>
    </div>
  );
}

# === app/artists/[id]/page.tsx ===
// === app/artists/[id]/page.tsx ===
'use client';

import React, { useEffect, useState } from 'react';
import { useParams, useRouter } from 'next/navigation';
import { Artist as ArtistType, Artwork as ArtworkType } from '@/lib/types'; // ArtistType includes optional artworks
import { apiClient } from '@/lib/api';

import { ArtworkCard, ArtworkCardSkeleton } from '@/components/artwork/ArtworkCard';
import { Skeleton } from '@/components/ui/skeleton';
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Button } from '@/components/ui/button';
import { ArrowLeft, Palette, Terminal, UserCircle2 } from 'lucide-react';
import { Separator } from '@/components/ui/separator';

function ArtistDetailSkeleton() {
  return (
    <div className="space-y-8">
      <div className="flex flex-col md:flex-row items-start md:items-center gap-6">
        <Skeleton className="h-32 w-32 rounded-full bg-muted" />
        <div className="space-y-3 flex-grow">
          <Skeleton className="h-10 w-3/4" /> {/* Name */}
          <Skeleton className="h-5 w-full" /> {/* Bio line 1 */}
          <Skeleton className="h-5 w-full" /> {/* Bio line 2 */}
          <Skeleton className="h-5 w-2/3" /> {/* Bio line 3 */}
        </div>
      </div>
      <Separator />
      <div>
        <Skeleton className="h-8 w-1/3 mb-6" /> {/* Artworks Title */}
        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
          {Array.from({ length: 4 }).map((_, index) => (
            <ArtworkCardSkeleton key={index} />
          ))}
        </div>
      </div>
    </div>
  );
}


export default function ArtistDetailPage() {
  const params = useParams();
  const router = useRouter();
  const artistId = params.id as string;

  const [artist, setArtist] = useState<ArtistType | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (artistId) {
      const fetchArtist = async () => {
        setIsLoading(true);
        setError(null);
        try {
          // This assumes the Artist type might include an 'artworks' array
          const fetchedArtist = await apiClient.get<ArtistType>(`/artists/${artistId}`);
          setArtist(fetchedArtist);
        } catch (err: any) {
          console.error("Failed to fetch artist details:", err);
          setError(err.message || "An unknown error occurred");
        } finally {
          setIsLoading(false);
        }
      };
      fetchArtist();
    }
  }, [artistId]);

  if (isLoading) {
    return <ArtistDetailSkeleton />;
  }

  if (error) {
    return (
      <div className="text-center py-10">
        <Alert variant="destructive" className="max-w-lg mx-auto">
          <Terminal className="h-4 w-4" />
          <AlertTitle>Error Fetching Artist</AlertTitle>
          <AlertDescription>{error}</AlertDescription>
        </Alert>
        <Button variant="outline" onClick={() => router.back()} className="mt-6">
          <ArrowLeft className="mr-2 h-4 w-4" /> Go Back
        </Button>
      </div>
    );
  }

  if (!artist) {
    return (
        <div className="text-center py-10">
            <p className="text-xl text-muted-foreground">Artist not found.</p>
            <Button variant="outline" onClick={() => router.push('/artists')} className="mt-6">
                View Other Artists
            </Button>
        </div>
    );
  }

  const artworksByArtist = artist.artworks || [];

  return (
    <div className="container mx-auto px-4 py-8">
      <Button variant="outline" size="sm" onClick={() => router.back()} className="mb-8">
        <ArrowLeft className="mr-2 h-4 w-4" /> Back to Artists
      </Button>

      <header className="mb-10">
        <div className="flex flex-col md:flex-row items-start md:items-center gap-6 mb-6">
            <div className="flex-shrink-0">
                <UserCircle2 className="h-32 w-32 text-muted-foreground" /> {/* Placeholder Icon */}
            </div>
            <div>
                <h1 className="text-4xl lg:text-5xl font-bold font-serif text-primary tracking-tight mb-2">
                    {artist.name}
                </h1>
                <p className="text-muted-foreground leading-relaxed max-w-2xl">
                    {artist.bio || "This artist has not provided a biography yet."}
                </p>
            </div>
        </div>
      </header>
      
      <Separator className="my-10"/>

      <div>
        <h2 className="text-3xl font-semibold font-serif mb-8 flex items-center">
            <Palette className="mr-3 h-7 w-7 text-primary" />
            Artworks by {artist.name}
        </h2>
        {artworksByArtist.length > 0 ? (
          <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-x-6 gap-y-8">
            {artworksByArtist.map((artwork) => (
              <ArtworkCard key={artwork.id} artwork={artwork as ArtworkType} />
            ))}
          </div>
        ) : (
          <div className="text-center py-10 text-muted-foreground col-span-full">
             <Palette className="h-16 w-16 mx-auto mb-4 text-gray-400" />
            <p className="text-xl">No artworks found for this artist at the moment.</p>
          </div>
        )}
         {!artist.artworks && !isLoading && ( // Explicit check if artworks array is missing from response
            <Alert variant="default" className="mt-6">
                <Terminal className="h-4 w-4" />
                <AlertTitle>Artwork Information</AlertTitle>
                <AlertDescription>
                    Detailed artwork listings for this artist are not available in the current view.
                    This might be due to the API response structure.
                </AlertDescription>
            </Alert>
        )}
      </div>
    </div>
  );
}

# === app/artworks/page.tsx ===
'use client';

import React, { useState, useEffect } from 'react';
import { Artwork } from '@/lib/types';
import { apiClient } from '@/lib/api';
import { ArtworkCard, ArtworkCardSkeleton } from '@/components/artwork/ArtworkCard';
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Palette, Terminal } from "lucide-react";

export default function ArtworksPage() {
  const [artworks, setArtworks] = useState<Artwork[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchArtworks = async () => {
      setIsLoading(true);
      setError(null);
      try {
        const fetchedArtworks = await apiClient.get<Artwork[]>('/artworks/');
        setArtworks(fetchedArtworks || []);
      } catch (err: any) {
        console.error("Failed to fetch artworks:", err);
        setError(err.message || "An unknown error occurred");
      } finally {
        setIsLoading(false);
      }
    };

    fetchArtworks();
  }, []);

  return (
    <div>
      <h1 className="text-3xl font-bold tracking-tight mb-6 font-serif">
        Explore Our Artwork
      </h1>

      {error && (
        <Alert variant="destructive" className="mb-6">
          <Terminal className="h-4 w-4" />
          <AlertTitle>Error Fetching Artwork</AlertTitle>
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
        {isLoading ? (
          Array.from({ length: 8 }).map((_, index) => (
            <ArtworkCardSkeleton key={index} />
          ))
        ) : artworks.length > 0 ? (
          artworks.map((artwork, index) => (
            <ArtworkCard key={artwork.id} artwork={artwork} isPriority={index < 4} />
          ))
        ) : (
          !error && (
            <div className="col-span-full text-center py-10 text-muted-foreground">
                <Palette className="h-16 w-16 mx-auto mb-4 text-gray-400" />
                <p className="text-xl">No artwork found.</p>
                <p>Our gallery is currently empty. Please check back soon!</p>
            </div>
          )
        )}
      </div>
    </div>
  );
}

# === app/artworks/[id]/page.tsx ===
// === app/artworks/[id]/page.tsx ===
'use client';

import React, { useEffect, useState } from 'react';
import { useParams, useRouter } from 'next/navigation';
import Image from 'next/image';
import Link from 'next/link';
import { Artwork as ArtworkType } from '@/lib/types';
import { apiClient } from '@/lib/api';
import { formatPrice } from '@/lib/utils';
import { useCart } from '@/contexts/CartContext';

import { Button } from '@/components/ui/button';
import { AspectRatio } from '@/components/ui/aspect-ratio';
import { Skeleton } from '@/components/ui/skeleton';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { Separator } from '@/components/ui/separator';
import { ArrowLeft, ImageOff, Loader2, ShoppingCart, CheckCircle, Terminal } from 'lucide-react'; // Added Terminal

function ArtworkDetailSkeleton() {
  return (
    <div className="grid md:grid-cols-2 gap-8 lg:gap-12 items-start">
      <Skeleton className="w-full">
        <AspectRatio ratio={1 / 1} className="bg-muted" />
      </Skeleton>
      <div className="space-y-6">
        <Skeleton className="h-10 w-3/4" />
        <Skeleton className="h-6 w-1/2" />
        <Skeleton className="h-8 w-1/3" />
        <div className="space-y-2">
          <Skeleton className="h-4 w-full" />
          <Skeleton className="h-4 w-full" />
          <Skeleton className="h-4 w-5/6" />
        </div>
        <Skeleton className="h-12 w-40" />
        <Skeleton className="h-5 w-1/4" />
      </div>
    </div>
  );
}

export default function ArtworkDetailPage() {
  const params = useParams();
  const router = useRouter();
  const artworkId = params.id as string;

  const [artwork, setArtwork] = useState<ArtworkType | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isAddingToCart, setIsAddingToCart] = useState(false);

  const { addToCart, cart } = useCart();
  const placeholderImage = "/placeholder-image.svg";

  useEffect(() => {
    if (artworkId) {
      const fetchArtwork = async () => {
        setIsLoading(true);
        setError(null);
        try {
          const fetchedArtwork = await apiClient.get<ArtworkType>(`/artworks/${artworkId}`);
          setArtwork(fetchedArtwork);
        } catch (err: any) {
          console.error("Failed to fetch artwork:", err);
          setError(err.message || "An unknown error occurred");
        } finally {
          setIsLoading(false);
        }
      };
      fetchArtwork();
    }
  }, [artworkId]);

  const handleAddToCart = async () => {
    if (!artwork) return;
    setIsAddingToCart(true);
    try {
      await addToCart(artwork.id, 1);
    } catch (err) {
      console.error("Add to cart failed from ArtworkDetail page (already handled in context):", err);
    } finally {
      setIsAddingToCart(false);
    }
  };

  const isInCart = cart?.items.some(item => item.artwork_id === artwork?.id);

  if (isLoading) {
    return <ArtworkDetailSkeleton />;
  }

  if (error) {
    return (
      <div className="text-center py-10">
        <Alert variant="destructive" className="max-w-lg mx-auto">
          <Terminal className="h-4 w-4" /> {/* Added Terminal icon */}
          <AlertTitle>Error Fetching Artwork</AlertTitle>
          <AlertDescription>{error}</AlertDescription>
        </Alert>
        <Button variant="outline" onClick={() => router.back()} className="mt-6">
          <ArrowLeft className="mr-2 h-4 w-4" /> Go Back
        </Button>
      </div>
    );
  }

  if (!artwork) {
    return (
      <div className="text-center py-10">
        <p className="text-xl text-muted-foreground">Artwork not found.</p>
        <Button variant="outline" onClick={() => router.push('/artworks')} className="mt-6">
           Explore Other Artworks
        </Button>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <Button variant="outline" size="sm" onClick={() => router.back()} className="mb-6">
        <ArrowLeft className="mr-2 h-4 w-4" /> Back to Artworks
      </Button>
      <div className="grid md:grid-cols-2 gap-8 lg:gap-12 items-start">
        <div className="w-full bg-muted rounded-lg overflow-hidden border">
          <AspectRatio ratio={1 / 1}>
            <Image
              src={artwork.image_url || placeholderImage}
              alt={artwork.name}
              fill
              className="object-cover"
              sizes="(max-width: 768px) 100vw, 50vw"
              priority // Added priority for LCP
              onError={(e) => {
                const target = e.target as HTMLImageElement;
                target.srcset = placeholderImage;
                target.src = placeholderImage;
              }}
            />
             {!artwork.image_url && (
                <div className="absolute inset-0 flex items-center justify-center bg-muted/50">
                    <ImageOff className="h-24 w-24 text-gray-400" />
                </div>
            )}
          </AspectRatio>
        </div>

        <div className="space-y-6">
          <div>
            <h1 className="text-3xl lg:text-4xl font-bold font-serif text-primary tracking-tight">
              {artwork.name}
            </h1>
            <Link href={`/artists/${artwork.artist.id}`} className="text-lg text-muted-foreground hover:text-primary transition-colors"> {/* Removed legacyBehavior */}
              By {artwork.artist.name}
            </Link>
          </div>

          <p className="text-2xl font-semibold text-primary">
            {formatPrice(artwork.price)}
          </p>

          <Separator />

          <div>
            <h2 className="text-xl font-semibold mb-2">Description</h2>
            <p className="text-muted-foreground leading-relaxed">
              {artwork.description || "No description provided."}
            </p>
          </div>

          <Separator />
          
          <div className="space-y-4">
            {artwork.stock_quantity > 0 ? (
              <Button
                size="lg"
                className="w-full md:w-auto"
                onClick={handleAddToCart}
                disabled={isAddingToCart || isInCart}
              >
                {isAddingToCart ? (
                  <Loader2 className="mr-2 h-5 w-5 animate-spin" />
                ) : isInCart ? (
                  <CheckCircle className="mr-2 h-5 w-5" />
                ) : (
                  <ShoppingCart className="mr-2 h-5 w-5" />
                )}
                {isAddingToCart ? 'Adding...' : isInCart ? 'Added to Cart' : 'Add to Cart'}
              </Button>
            ) : (
              <Button size="lg" className="w-full md:w-auto" disabled>
                Out of Stock
              </Button>
            )}
            {artwork.stock_quantity > 0 && artwork.stock_quantity < 5 && (
              <p className="text-sm text-orange-600">
                Only {artwork.stock_quantity} left in stock!
              </p>
            )}
             {artwork.stock_quantity === 0 && (
              <p className="text-sm text-red-600">
                This item is currently out of stock.
              </p>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}

# === contexts/AuthContext.tsx ===
// === contexts/AuthContext.tsx ===
'use client';

import React, { createContext, useState, useContext, useEffect, ReactNode, useCallback } from 'react';
import { User, ApiErrorResponse, SignupResponse, LoginResponse, UserProfile } from '@/lib/types';
import { apiClient } from '@/lib/api';

export const getAuthToken = (): string | null => {
   if (typeof window === 'undefined') return null;
   try {
      return localStorage.getItem('authToken');
   } catch (error) {
      console.error("Failed to read auth token from localStorage:", error);
      return null;
   }
};

const setAuthToken = (token: string | null): void => {
   if (typeof window === 'undefined') return;
   try {
      if (token) {
         localStorage.setItem('authToken', token);
      } else {
         localStorage.removeItem('authToken');
      }
   } catch (error) {
      console.error("Failed to update auth token in localStorage:", error);
   }
};

export const clearAuthToken = (): void => setAuthToken(null);


interface AuthContextType {
  user: UserProfile | null;
  token: string | null;
  isLoading: boolean;
  isAuthenticated: boolean;
  login: (email: string, password: string) => Promise<void>;
  signup: (userData: Omit<User, 'id'|'created_at'> & {password: string}) => Promise<void>;
  logout: () => Promise<void>;
  fetchUser: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider = ({ children }: { children: ReactNode }) => {
  const [user, setUser] = useState<UserProfile | null>(null);
  const [token, setToken] = useState<string | null>(() => getAuthToken());
  const [isLoading, setIsLoading] = useState<boolean>(true); // Start true to load token and potentially user

  const fetchUser = useCallback(async () => {
    const currentToken = getAuthToken();
    if (!currentToken) {
       setToken(null);
       setUser(null);
       setIsLoading(false);
       return;
    }

    // If token exists, but user is not loaded, set token and try to fetch user
    if (currentToken && !user) {
        setToken(currentToken); // Ensure token state is up-to-date
    }

    setIsLoading(true);
    try {
       // IMPORTANT: The backend currently does NOT have a `/api/auth/me` endpoint.
       // This is a placeholder for if one is added.
       // If this endpoint doesn't exist, this call will fail, and user will remain null.
       const fetchedUser = await apiClient.get<UserProfile>('/auth/me', { needsAuth: true });
       if (fetchedUser) {
          setUser(fetchedUser);
       } else {
          // If /auth/me exists but returns no user for a valid token (unlikely but possible)
          setUser(null);
          // Potentially clear token if it's deemed invalid by this response
          // clearAuthToken(); setToken(null);
       }
    } catch (error: any) {
       console.warn("Failed to fetch user (e.g., /auth/me endpoint might not exist or token is invalid):", error.message);
       // Don't clear token here if it's just that /me doesn't exist.
       // If it's a 401, the apiClient might handle it, or we might need to.
       // For now, assume a failed fetch means user data isn't available.
       setUser(null);
       if (error.message?.includes("401") || error.message?.includes("Unauthorized")) {
            clearAuthToken();
            setToken(null);
       }
    } finally {
       setIsLoading(false);
    }
  }, [user]); // Added user to dependency array to avoid re-fetching if user is already loaded

  useEffect(() => {
     // Only run fetchUser on initial mount or if token changes and user isn't loaded
     const currentToken = getAuthToken();
     if (currentToken && !user) {
         fetchUser();
     } else {
         setIsLoading(false); // No token, or user already loaded
     }
  }, [fetchUser, user]);


  const login = async (email: string, password: string) => {
     // No need to setIsLoading(true) here, as page loading state should not be affected
     // Individual components can handle their own submit loading state
     try {
         const response = await apiClient.post<LoginResponse>('/auth/login', { email, password });

         if (response && typeof response.access_token === 'string') {
             setAuthToken(response.access_token);
             setToken(response.access_token);
             // Backend login doesn't return user object, so call fetchUser
             await fetchUser(); // This will attempt /auth/me
         } else {
             console.error("Login failed: Invalid response structure from server.", response);
             throw new Error("Login failed: Received an invalid response from the server.");
         }
     } catch (error) {
         console.error("Login failed:", error);
         clearAuthToken();
         setToken(null);
         setUser(null);
         throw error; // Re-throw for the form to handle
     }
  };

 const signup = async (userData: Omit<User, 'id'|'created_at'> & {password: string}) => {
    // No need to setIsLoading(true) here
     try {
         const response = await apiClient.post<SignupResponse>('/auth/signup', userData);
         if (response && response.user) {
            // Signup on backend does not auto-login or return a token.
            // It just creates the user. User needs to login separately.
            // If backend auto-logged in and returned a token:
            // setAuthToken(response.access_token);
            // setToken(response.access_token);
            // setUser(response.user);
         } else {
            throw new Error("Signup response did not include user data.");
         }
     } catch (error) {
         console.error("Signup failed:", error);
         throw error; // Re-throw for the form to handle
     }
 };

  const logout = async () => {
     // setIsLoading(true); // Not for global loading, component can handle its own
     const currentToken = getAuthToken();
     try {
        if (currentToken) {
           await apiClient.post('/auth/logout', {}, { needsAuth: true });
        }
     } catch (error) {
         console.warn("Logout API call failed (continuing client-side logout):", error);
     } finally {
        clearAuthToken();
        setToken(null);
        setUser(null);
        // setIsLoading(false);
        // Force reload or redirect to ensure all states are cleared, and cart context also updates
        window.location.href = '/';
     }
  };

  // Derived state: isAuthenticated depends on token, user, and loading status
  // Considered authenticated if not loading, and token is present.
  // User object might still be null if /me endpoint is not available.
  const isAuthenticated = !isLoading && !!token;

  return (
    <AuthContext.Provider value={{ user, token, isLoading, isAuthenticated, login, signup, logout, fetchUser }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

# === contexts/CartContext.tsx ===
'use client';

import React, { createContext, useState, useContext, useEffect, ReactNode, useCallback } from 'react';
import { Cart, CartItem, Artwork } from '@/lib/types';
import { apiClient } from '@/lib/api';
import { useAuth } from './AuthContext';
import { toast } from 'sonner';

interface CartContextType {
  cart: Cart | null;
  isLoading: boolean;
  itemCount: number;
  totalPrice: number;
  fetchCart: () => Promise<void>;
  addToCart: (artworkId: string, quantity: number) => Promise<void>;
  updateCartItem: (itemId: string, quantity: number) => Promise<void>;
  removeFromCart: (itemId: string) => Promise<void>;
  clearCart: () => void;
}

const CartContext = createContext<CartContextType | undefined>(undefined);

export const CartProvider = ({ children }: { children: ReactNode }) => {
  const { isAuthenticated, isLoading: isAuthLoading } = useAuth();
  const [cart, setCart] = useState<Cart | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(false);

  const fetchCart = useCallback(async () => {
    if (!isAuthenticated) {
        setCart(null);
        return;
    }
    if (isLoading) return;
    setIsLoading(true);
    try {
      const fetchedCart = await apiClient.get<Cart>('/cart', { needsAuth: true });
      setCart(fetchedCart);
    } catch (error) {
      console.error("Failed to fetch cart:", error);
      toast.error("Could not load your cart.");
    } finally {
      setIsLoading(false);
    }
  }, [isAuthenticated, isLoading]);

  useEffect(() => {
    if (!isAuthLoading && isAuthenticated) {
      fetchCart();
    } else if (!isAuthLoading && !isAuthenticated) {
      setCart(null);
    }
  }, [isAuthenticated, isAuthLoading]);


  const updateLocalCart = (updatedCart: Cart | null) => {
      setCart(updatedCart);
  };

  const addToCart = async (artworkId: string, quantity: number) => {
      if (!isAuthenticated) {
          toast.error("Please log in to add items to cart.");
          throw new Error("Please log in to add items to cart.");
      }
      setIsLoading(true);
      try {
          const updatedCart = await apiClient.post<Cart>(
              '/cart',
              { artwork_id: artworkId, quantity },
              { needsAuth: true }
          );
          if (updatedCart) {
              updateLocalCart(updatedCart);
              toast.success("Item added to cart!");
          } else {
            await fetchCart();
            toast.success("Item added to cart!");
          }
      } catch (error: any) {
          console.error("Failed to add to cart:", error);
          toast.error(error.message || "Failed to add item to cart.");
          throw error;
      } finally {
          setIsLoading(false);
      }
  };

  const updateCartItem = async (itemId: string, quantity: number) => {
      if (!isAuthenticated) {
          toast.error("Authentication error.");
          throw new Error("Authentication error.");
      }
      setIsLoading(true);
      try {
          const updatedCart = await apiClient.put<Cart>(`/cart/items/${itemId}`, { quantity }, { needsAuth: true });
          if (updatedCart) {
              updateLocalCart(updatedCart);
              toast.success("Cart updated.");
          } else {
            await fetchCart();
            toast.success("Cart updated.");
          }
      } catch (error: any) {
          console.error("Failed to update cart item:", error);
          toast.error(error.message || "Failed to update item quantity.");
          throw error;
      } finally {
          setIsLoading(false);
      }
  };

  const removeFromCart = async (itemId: string) => {
      if (!isAuthenticated) {
          toast.error("Authentication error.");
          throw new Error("Authentication error.");
      }
      setIsLoading(true);
      try {
          const updatedCart = await apiClient.delete<Cart | null>(`/cart/items/${itemId}`, { needsAuth: true });
           if (updatedCart) {
               updateLocalCart(updatedCart);
               toast.success("Item removed from cart.");
           } else {
               await fetchCart();
               toast.success("Item removed from cart.");
           }
      } catch (error: any) {
          console.error("Failed to remove cart item:", error);
           toast.error(error.message || "Failed to remove item from cart.");
          throw error;
      } finally {
          setIsLoading(false);
      }
  };

  const clearCart = () => {
      setCart(null);
  }

  const itemCount = cart?.items.reduce((sum, item) => sum + item.quantity, 0) ?? 0;
  const totalPrice = cart?.items.reduce((sum, item) => {
       const price = parseFloat(item.artwork.price) || 0;
       return sum + (price * item.quantity);
  }, 0) ?? 0;


  return (
    <CartContext.Provider value={{ cart, isLoading, fetchCart, addToCart, updateCartItem, removeFromCart, clearCart, itemCount, totalPrice }}>
      {children}
    </CartContext.Provider>
  );
};

export const useCart = (): CartContextType => {
  const context = useContext(CartContext);
  if (context === undefined) {
    throw new Error('useCart must be used within a CartProvider');
  }
  return context;
};

# === hooks/use-mobile.ts ===
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}

# === components/artwork/ArtworkCard.tsx ===
// === components/artwork/ArtworkCard.tsx ===
import React from 'react';
import Link from 'next/link';
import Image from 'next/image';
import { Artwork } from '@/lib/types';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { AspectRatio } from "@/components/ui/aspect-ratio";
import { useCart } from '@/contexts/CartContext';
import { formatPrice } from '@/lib/utils';
import { ImageOff, ShoppingCartIcon } from 'lucide-react';

interface ArtworkCardProps {
  artwork: Artwork;
  isPriority?: boolean; // For LCP optimization
}

export function ArtworkCard({ artwork, isPriority }: ArtworkCardProps) {
  const { addToCart, isLoading: isCartLoading, cart } = useCart();
  const placeholderImage = "/placeholder-image.svg";

  const handleAddToCart = async () => {
    try {
      await addToCart(artwork.id, 1);
    } catch (error) {
      console.error("Add to cart failed from ArtworkCard (already handled in context):", error);
    }
  };

  const isInCart = cart?.items.some(item => item.artwork_id === artwork.id);

  return (
    <Card className="overflow-hidden flex flex-col h-full group border shadow-sm hover:shadow-lg transition-shadow duration-300">
       <CardHeader className="p-0 border-b">
         <Link href={`/artworks/${artwork.id}`} className="block"> {/* Removed legacyBehavior and <a> */}
           <AspectRatio ratio={1 / 1} className="bg-muted overflow-hidden">
             <Image
               src={artwork.image_url || placeholderImage}
               alt={artwork.name}
               fill
               className="object-cover transition-transform duration-300 group-hover:scale-105"
               sizes="(max-width: 640px) 100vw, (max-width: 768px) 50vw, (max-width: 1024px) 33vw, 25vw"
               priority={isPriority || false} // Use the isPriority prop
               onError={(e) => {
                  const target = e.target as HTMLImageElement;
                  target.srcset = placeholderImage;
                  target.src = placeholderImage;
               }}
             />
             {!artwork.image_url && (
                <div className="absolute inset-0 flex items-center justify-center bg-muted/50">
                  <ImageOff className="h-12 w-12 text-gray-400" />
                </div>
              )}
           </AspectRatio>
         </Link>
       </CardHeader>
       <CardContent className="p-4 flex-grow">
         <Link href={`/artworks/${artwork.id}`} className="block"> {/* Removed legacyBehavior and <a> */}
           <CardTitle className="text-lg font-medium hover:text-primary transition-colors line-clamp-2 mb-1">
             {artwork.name}
           </CardTitle>
         </Link>
         <Link href={`/artists/${artwork.artist.id}`} className="text-sm text-muted-foreground hover:text-primary transition-colors"> {/* Removed legacyBehavior and <a> */}
           {artwork.artist.name}
         </Link>
         <p className="text-sm text-muted-foreground mt-2 line-clamp-3 h-[3.75rem]">
            {artwork.description || "No description available."}
         </p>
       </CardContent>
       <CardFooter className="p-4 pt-0 flex justify-between items-center mt-auto">
         <span className="text-lg font-semibold text-primary">
           {formatPrice(artwork.price)}
         </span>
         <Button
            size="sm"
            variant={artwork.stock_quantity === 0 ? "outline" : "default"}
            onClick={handleAddToCart}
            disabled={isCartLoading || artwork.stock_quantity === 0 || isInCart}
            aria-label={artwork.stock_quantity === 0 ? 'Out of Stock' : isInCart ? 'Already in Cart' : 'Add to Cart'}
         >
            {artwork.stock_quantity === 0 ? (
                'Out of Stock'
            ) : isInCart ? (
                'In Cart'
            ) : (
                <>
                    <ShoppingCartIcon className="mr-2 h-4 w-4" /> Add to Cart
                </>
            )}
         </Button>
       </CardFooter>
    </Card>
  );
}

export function ArtworkCardSkeleton() {
  return (
    <Card className="overflow-hidden flex flex-col h-full">
      <AspectRatio ratio={1 / 1} className="bg-muted animate-pulse" />
      <CardContent className="p-4 flex-grow">
        <div className="h-5 w-3/4 bg-muted rounded animate-pulse mb-2"></div>
        <div className="h-4 w-1/2 bg-muted rounded animate-pulse mb-3"></div>
        <div className="h-4 w-full bg-muted rounded animate-pulse mb-1"></div>
        <div className="h-4 w-full bg-muted rounded animate-pulse mb-1"></div>
        <div className="h-4 w-2/3 bg-muted rounded animate-pulse"></div>
      </CardContent>
      <CardFooter className="p-4 pt-0 flex justify-between items-center mt-auto">
        <div className="h-6 w-1/3 bg-muted rounded animate-pulse"></div>
        <div className="h-9 w-28 bg-muted rounded animate-pulse"></div>
      </CardFooter>
    </Card>
  );
}

# === components/layout/Footer.tsx ===
import React from 'react';

export function Footer() {
  return (
    <footer className="bg-muted text-muted-foreground border-t border-border mt-12 py-6">
      <div className="container mx-auto px-4 text-center text-sm">
        © {new Date().getFullYear()} Artistry Haven by izzie
      </div>
    </footer>
  );
}

# === components/layout/Navbar.tsx ===
// === components/layout/Navbar.tsx ===
'use client'; // Needs to be a client component to use hooks later

import Link from 'next/link';
import { Button } from '@/components/ui/button';
import { ShoppingCart } from 'lucide-react'; // Removed User import as it wasn't used
import { useAuth } from '@/contexts/AuthContext';
import { useCart } from '@/contexts/CartContext';
import { Badge } from '@/components/ui/badge';


export function Navbar() {
   const { isAuthenticated, isLoading, logout, user } = useAuth();
   const { itemCount } = useCart();

  return (
    <nav className="bg-card border-b border-border sticky top-0 z-50">
      <div className="container mx-auto px-4 h-16 flex items-center justify-between">
        {/* Logo/Brand Name */}
        <Link href="/" className="text-xl font-bold font-serif text-primary">
          Artistry Haven
        </Link>

        {/* Navigation Links */}
        <div className="hidden md:flex items-center space-x-6">
          {/* UPDATED: Link to artworks page */}
          <Link href="/artworks" className="text-sm font-medium text-muted-foreground hover:text-primary transition-colors">
            Artwork
          </Link>
          {/* Optional: Add link to Artists page */}
          <Link href="/artists" className="text-sm font-medium text-muted-foreground hover:text-primary transition-colors">
            Artists
          </Link>
        </div>

        {/* Actions: Auth & Cart */}
        <div className="flex items-center space-x-4">
          <Link href="/cart" aria-label="View Cart">
             <Button variant="ghost" size="icon" className="relative">
                <ShoppingCart className="h-5 w-5" />
                {isAuthenticated && itemCount > 0 && (
                   <Badge variant="destructive" className="absolute -top-1 -right-1 h-4 w-4 min-w-4 p-0 flex items-center justify-center text-xs">
                      {itemCount > 9 ? '9+' : itemCount} {/* Handle counts > 9 */}
                   </Badge>
                )}
             </Button>
          </Link>

          {isLoading ? (
             <Button variant="ghost" size="sm" disabled>Loading...</Button>
          ) : isAuthenticated ? (
             <>
              <Link href="/orders">
                <Button variant="ghost" size="sm">My Orders</Button>
              </Link>
              <Button variant="outline" size="sm" onClick={logout}>Logout</Button>
             </>
          ) : (
             <>
             <Link href="/login">
                <Button variant="ghost" size="sm">Login</Button>
             </Link>
             <Link href="/signup">
                <Button size="sm">Sign Up</Button>
             </Link>
             </>
          )}
        </div>
      </div>
    </nav>
  );
}
