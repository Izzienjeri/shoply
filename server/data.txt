# Extracted Python Code
# Date and Time: 2025-05-23 05:11:46
# Files Included: 18

# === ./seed.py ===
# === ./seed.py ===

import os
import random
from decimal import Decimal
from faker import Faker
from app import create_app, db
from app.models import User, Artist, Artwork, Cart, CartItem, Order, OrderItem, DeliveryOption, PaymentTransaction # Added DeliveryOption

NUM_ARTISTS = 10
NUM_USERS = 5
ARTWORK_IMAGE_FOLDER_RELATIVE = 'artwork_images'
IMAGES_BASE_NAME = 'art'
NUM_IMAGES = 48
DEFAULT_PASSWORD = "pass123"

try:
    fake = Faker()
except ImportError:
    print("Faker not installed. Using basic placeholder data. (pip install Faker)")
    fake = None

KENYAN_NAMES = [
    "Wanjiku", "Omondi", "Achieng", "Kamau", "Otieno", "Njeri", "Mwangi", "Kiplagat", "Cherono", "Nyambura"
]

KENYAN_LOCATIONS = [
    "Westlands, Nairobi", "Kisumu CBD", "Mombasa Island", "Eldoret Town", "Thika Road, Nairobi",
    "Nyali, Mombasa", "Kasarani, Nairobi", "Lang'ata, Nairobi", "Kakamega", "Machakos Town",
    "Kikuyu, Kiambu", "Ngong Road, Nairobi", "Rongai", "Meru Town", "Kitale"
]

def get_image_path(image_index):
    return f"{ARTWORK_IMAGE_FOLDER_RELATIVE}/{IMAGES_BASE_NAME}{image_index}.jpg"

def clear_data():
    print("Clearing existing data...")
    # Clear in order of dependencies to avoid FK constraint errors
    db.session.query(OrderItem).delete()
    # Order has FK to PaymentTransaction and DeliveryOption. PaymentTransaction has FK to Cart and DeliveryOption.
    # So Order, then PaymentTransaction, then CartItem, then Cart.
    # DeliveryOption can be cleared before or after PaymentTransaction/Order if those FKs are nullable.
    # Let's clear Order and PaymentTransaction before DeliveryOption just to be safe.
    db.session.query(Order).delete() 
    db.session.query(PaymentTransaction).delete() 
    db.session.query(CartItem).delete()
    db.session.query(Cart).delete()
    db.session.query(Artwork).delete()
    db.session.query(DeliveryOption).delete() # Clear DeliveryOption
    db.session.query(User).delete()
    db.session.query(Artist).delete()
    db.session.commit()
    print("Data cleared.")

def seed_artists(num_artists):
    print(f"Seeding {num_artists} artists...")
    artists = []
    for i in range(num_artists):
        first_name = fake.first_name() if fake else f"John"
        kenyan_last_name = random.choice(KENYAN_NAMES)
        artist_name = f"{first_name} {kenyan_last_name}"
        artist_bio = fake.paragraph(nb_sentences=3) if fake else f"This is the biography for {artist_name}."
        artist = Artist(name=artist_name, bio=artist_bio)
        artists.append(artist)
    db.session.add_all(artists)
    db.session.commit()
    print("Artists seeded.")
    return artists

def seed_artworks(artists, num_images_available, media_folder_base):
    if not artists:
        print("No artists available to assign artworks to. Skipping artwork seeding.")
        return

    print(f"Seeding artworks (up to {num_images_available} based on image files)...")
    artworks = []
    image_folder_full_path = os.path.join(media_folder_base, ARTWORK_IMAGE_FOLDER_RELATIVE)
    print(f"Checking for images in: {image_folder_full_path}")

    one_shilling_added = False

    for i in range(1, num_images_available + 1):
        image_filename = f"{IMAGES_BASE_NAME}{i}.jpg"
        image_full_path = os.path.join(image_folder_full_path, image_filename)
        relative_image_url = get_image_path(i)

        if not os.path.exists(image_full_path):
            print(f"Warning: Image file not found: {image_full_path}. Skipping artwork {i}.")
            continue

        artwork_name = fake.catch_phrase() if fake else f"Artwork {i}"
        description = fake.text(max_nb_chars=200) if fake else f"A beautiful piece numbered {i}."

        if not one_shilling_added: # Ensure at least one item is Ksh 1 for testing STK push
            price = Decimal(1)  # Corrected if this was an issue
            one_shilling_added = True
        else:
            price = Decimal(random.randint(500, 15000))

        stock_quantity = random.randint(0, 10)
        assigned_artist = random.choice(artists)

        artwork = Artwork(
            name=artwork_name,
            description=description,
            price=price,
            stock_quantity=stock_quantity,
            artist_id=assigned_artist.id,
            image_url=relative_image_url
        )
        artworks.append(artwork)

    if artworks:
        db.session.add_all(artworks)
        db.session.commit()
        print(f"{len(artworks)} artworks seeded.")
    else:
        print("No artworks were seeded.")


def seed_users(num_users):
    print(f"Seeding {num_users} users...")
    users = []
    for i in range(num_users):
        user_email = fake.email() if fake else f"user{i+1}@example.com"
        user_name = fake.name() if fake else f"Test User {i+1}"
        user_address = random.choice(KENYAN_LOCATIONS) # Default address

        if User.query.filter_by(email=user_email).first():
            print(f"User with email {user_email} already exists, skipping.")
            continue

        user = User(
            email=user_email,
            name=user_name,
            address=user_address
        )
        user.set_password(DEFAULT_PASSWORD)
        users.append(user)
        print(f"Created user: {user_email}, Address: {user_address}")

    if users:
        db.session.add_all(users)
        db.session.commit()
        print(f"{len(users)} users seeded (default password: '{DEFAULT_PASSWORD}').")
    else:
        print("No new users were seeded.")
    return users

def seed_delivery_options():
    print("Seeding delivery options...")
    options_data = [
        {"name": "In Store Pick Up", "price": "0.00", "is_pickup": True, "active": True, "sort_order": 0, "description": "Collect your order from Dynamic Mall, Shop M90, CBD, Nairobi."},
        {"name": "Diaspora (Kitengela Via Rembo)", "price": "200.00", "is_pickup": False, "active": True, "sort_order": 10},
        {"name": "Nairobi CBD", "price": "200.00", "is_pickup": False, "active": True, "sort_order": 20},
        {"name": "Zone 1 (Upper-Hill, Statehouse, etc. - 6km Proximity)", "price": "300.00", "is_pickup": False, "active": True, "sort_order": 30, "description": "Upper-Hill, Statehouse, Rhapta Road, Parklands, Pangani, City Stadium"},
        {"name": "Zone 2 (N/West, Madaraka, South B/C, etc.)", "price": "400.00", "is_pickup": False, "active": True, "sort_order": 40, "description": "N/ West, Madaraka, South B/C, Mbagathi, Kilimani, Riara Road, Jamhuri, Yaya, Prestige, Kileleshwa, Westlands"},
        {"name": "The Central Region", "price": "450.00", "is_pickup": False, "active": True, "sort_order": 50},
        {"name": "The Coastal Region", "price": "450.00", "is_pickup": False, "active": True, "sort_order": 51},
        {"name": "The Eastern Region", "price": "450.00", "is_pickup": False, "active": True, "sort_order": 52},
        {"name": "The North Eastern Region", "price": "450.00", "is_pickup": False, "active": True, "sort_order": 53},
        {"name": "The Nyanza Region", "price": "450.00", "is_pickup": False, "active": True, "sort_order": 54},
        {"name": "The Rift Valley Region", "price": "450.00", "is_pickup": False, "active": True, "sort_order": 55},
        {"name": "The Western Region", "price": "450.00", "is_pickup": False, "active": True, "sort_order": 56},
        {"name": "Zone 3 (Kikuyu, Kinoo, Kahawa, JKIA, etc.)", "price": "500.00", "is_pickup": False, "active": True, "sort_order": 60, "description": "Kikuyu, Kinoo, Muthiga, Kahawa Sukari, Kahawa West, KU, Nyayo Estate, Kayole, Nasra Garden, JKIA, Kerarapon-Karen"},
        {"name": "Zone 4 (Kiambu Town, Ruiru, Utawala, etc.)", "price": "700.00", "is_pickup": False, "active": True, "sort_order": 70, "description": "Kiambu Town ,Ruiru,Kimbo,Utawala"},
        {"name": "To Door Couriers (G4S/Fargo)", "price": "1000.00", "is_pickup": False, "active": True, "sort_order": 80},
        {"name": "Zone 5 (Ngong Town, Rongai)", "price": "1000.00", "is_pickup": False, "active": True, "sort_order": 90},
    ]

    options_to_add = []
    for opt_data in options_data:
        if not DeliveryOption.query.filter_by(name=opt_data["name"]).first():
            option = DeliveryOption(
                name=opt_data["name"],
                price=Decimal(opt_data["price"]),
                is_pickup=opt_data.get("is_pickup", False),
                active=opt_data.get("active", True),
                sort_order=opt_data.get("sort_order", 0),
                description=opt_data.get("description")
            )
            options_to_add.append(option)
    
    if options_to_add:
        db.session.add_all(options_to_add)
        db.session.commit()
        print(f"{len(options_to_add)} new delivery options seeded.")
    else:
        print("All delivery options already exist.")


def run_seed():
    app = create_app()
    with app.app_context():
        media_folder = app.config.get('MEDIA_FOLDER')
        if not media_folder or not os.path.isdir(media_folder):
            print(f"ERROR: MEDIA_FOLDER ('{media_folder}') is not configured correctly or does not exist.")
            print("Ensure MEDIA_FOLDER is set in your Flask app config and the directory exists.")
            return

        clear_data()
        seed_delivery_options() # Seed delivery options first
        created_artists = seed_artists(NUM_ARTISTS)
        seed_artworks(created_artists, NUM_IMAGES, media_folder)
        seed_users(NUM_USERS)
        print("-" * 20)
        print("Seeding process completed!")
        print("-" * 20)

if __name__ == '__main__': # Allows running seed.py directly
    run_seed()

# === ./run.py ===
from app import create_app
from seed import run_seed

app = create_app()

@app.cli.command("seed")
def seed_db():
    """Populates the database with initial data."""
    run_seed()

if __name__ =='__main__':
    app.run(debug=True)

# === ./migrations/env.py ===
import logging
from logging.config import fileConfig

from flask import current_app

from alembic import context

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
fileConfig(config.config_file_name)
logger = logging.getLogger('alembic.env')


def get_engine():
    try:
        # this works with Flask-SQLAlchemy<3 and Alchemical
        return current_app.extensions['migrate'].db.get_engine()
    except (TypeError, AttributeError):
        # this works with Flask-SQLAlchemy>=3
        return current_app.extensions['migrate'].db.engine


def get_engine_url():
    try:
        return get_engine().url.render_as_string(hide_password=False).replace(
            '%', '%%')
    except AttributeError:
        return str(get_engine().url).replace('%', '%%')


# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
config.set_main_option('sqlalchemy.url', get_engine_url())
target_db = current_app.extensions['migrate'].db

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def get_metadata():
    if hasattr(target_db, 'metadatas'):
        return target_db.metadatas[None]
    return target_db.metadata


def run_migrations_offline():
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url, target_metadata=get_metadata(), literal_binds=True
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online():
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """

    # this callback is used to prevent an auto-migration from being generated
    # when there are no changes to the schema
    # reference: http://alembic.zzzcomputing.com/en/latest/cookbook.html
    def process_revision_directives(context, revision, directives):
        if getattr(config.cmd_opts, 'autogenerate', False):
            script = directives[0]
            if script.upgrade_ops.is_empty():
                directives[:] = []
                logger.info('No changes in schema detected.')

    conf_args = current_app.extensions['migrate'].configure_args
    if conf_args.get("process_revision_directives") is None:
        conf_args["process_revision_directives"] = process_revision_directives

    connectable = get_engine()

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=get_metadata(),
            **conf_args
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

# === ./migrations/versions/fc9079f1c17f_ensure_payment_transaction_id_in_orders.py ===
"""Ensure payment_transaction_id_in_orders

Revision ID: fc9079f1c17f
Revises: 
Create Date: 2025-05-23 04:27:46.596190

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import mysql

# revision identifiers, used by Alembic.
revision = 'fc9079f1c17f'
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('artists',
    sa.Column('id', sa.String(length=36), nullable=False),
    sa.Column('name', sa.String(length=150), nullable=False),
    sa.Column('bio', sa.Text(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('users',
    sa.Column('id', sa.String(length=36), nullable=False),
    sa.Column('email', sa.String(length=120), nullable=False),
    sa.Column('password_hash', sa.String(length=128), nullable=False),
    sa.Column('name', sa.String(length=100), nullable=True),
    sa.Column('address', sa.Text(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('email')
    )
    op.create_table('artworks',
    sa.Column('id', sa.String(length=36), nullable=False),
    sa.Column('name', sa.String(length=255), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('price', mysql.DECIMAL(precision=10, scale=2), nullable=False),
    sa.Column('stock_quantity', sa.Integer(), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.Column('image_url', sa.String(length=255), nullable=True),
    sa.Column('artist_id', sa.String(length=36), nullable=False),
    sa.ForeignKeyConstraint(['artist_id'], ['artists.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('carts',
    sa.Column('id', sa.String(length=36), nullable=False),
    sa.Column('user_id', sa.String(length=36), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('user_id')
    )
    op.create_table('cart_items',
    sa.Column('id', sa.String(length=36), nullable=False),
    sa.Column('cart_id', sa.String(length=36), nullable=False),
    sa.Column('artwork_id', sa.String(length=36), nullable=False),
    sa.Column('quantity', sa.Integer(), nullable=False),
    sa.ForeignKeyConstraint(['artwork_id'], ['artworks.id'], ),
    sa.ForeignKeyConstraint(['cart_id'], ['carts.id'], ),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('cart_id', 'artwork_id', name='_cart_artwork_uc')
    )
    op.create_table('payment_transactions',
    sa.Column('id', sa.String(length=36), nullable=False),
    sa.Column('checkout_request_id', sa.String(length=100), nullable=True),
    sa.Column('user_id', sa.String(length=36), nullable=False),
    sa.Column('cart_id', sa.String(length=36), nullable=True),
    sa.Column('amount', mysql.DECIMAL(precision=10, scale=2), nullable=False),
    sa.Column('phone_number', sa.String(length=15), nullable=True),
    sa.Column('status', sa.String(length=50), nullable=False),
    sa.Column('daraja_response_description', sa.Text(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.Column('_cart_items_snapshot', sa.Text(), nullable=True),
    sa.ForeignKeyConstraint(['cart_id'], ['carts.id'], ),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    with op.batch_alter_table('payment_transactions', schema=None) as batch_op:
        batch_op.create_index(batch_op.f('ix_payment_transactions_checkout_request_id'), ['checkout_request_id'], unique=True)

    op.create_table('orders',
    sa.Column('id', sa.String(length=36), nullable=False),
    sa.Column('user_id', sa.String(length=36), nullable=False),
    sa.Column('total_price', mysql.DECIMAL(precision=10, scale=2), nullable=False),
    sa.Column('status', sa.String(length=50), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.Column('shipped_at', sa.DateTime(), nullable=True),
    sa.Column('shipping_address', sa.Text(), nullable=True),
    sa.Column('billing_address', sa.Text(), nullable=True),
    sa.Column('payment_gateway_ref', sa.String(length=255), nullable=True),
    sa.Column('payment_transaction_id', sa.String(length=36), nullable=True),
    sa.ForeignKeyConstraint(['payment_transaction_id'], ['payment_transactions.id'], ),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    with op.batch_alter_table('orders', schema=None) as batch_op:
        batch_op.create_index(batch_op.f('ix_orders_payment_transaction_id'), ['payment_transaction_id'], unique=False)

    op.create_table('order_items',
    sa.Column('id', sa.String(length=36), nullable=False),
    sa.Column('order_id', sa.String(length=36), nullable=False),
    sa.Column('artwork_id', sa.String(length=36), nullable=False),
    sa.Column('quantity', sa.Integer(), nullable=False),
    sa.Column('price_at_purchase', mysql.DECIMAL(precision=10, scale=2), nullable=False),
    sa.ForeignKeyConstraint(['artwork_id'], ['artworks.id'], ),
    sa.ForeignKeyConstraint(['order_id'], ['orders.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('order_items')
    with op.batch_alter_table('orders', schema=None) as batch_op:
        batch_op.drop_index(batch_op.f('ix_orders_payment_transaction_id'))

    op.drop_table('orders')
    with op.batch_alter_table('payment_transactions', schema=None) as batch_op:
        batch_op.drop_index(batch_op.f('ix_payment_transactions_checkout_request_id'))

    op.drop_table('payment_transactions')
    op.drop_table('cart_items')
    op.drop_table('carts')
    op.drop_table('artworks')
    op.drop_table('users')
    op.drop_table('artists')
    # ### end Alembic commands ###

# === ./migrations/versions/90275cf6dcbf_ensure_payment_transaction_id_in_orders.py ===
"""Ensure payment_transaction_id_in_orders

Revision ID: 90275cf6dcbf
Revises: fc9079f1c17f
Create Date: 2025-05-23 04:59:38.814120

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import mysql

# revision identifiers, used by Alembic.
revision = '90275cf6dcbf'
down_revision = 'fc9079f1c17f'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('delivery_options',
    sa.Column('id', sa.String(length=36), nullable=False),
    sa.Column('name', sa.String(length=255), nullable=False),
    sa.Column('price', mysql.DECIMAL(precision=10, scale=2), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('is_pickup', sa.Boolean(), nullable=False),
    sa.Column('active', sa.Boolean(), nullable=False),
    sa.Column('sort_order', sa.Integer(), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('name')
    )
    with op.batch_alter_table('orders', schema=None) as batch_op:
        batch_op.add_column(sa.Column('delivery_option_id', sa.String(length=36), nullable=True))
        batch_op.add_column(sa.Column('delivery_fee', mysql.DECIMAL(precision=10, scale=2), nullable=False))
        batch_op.create_foreign_key(None, 'delivery_options', ['delivery_option_id'], ['id'])

    with op.batch_alter_table('payment_transactions', schema=None) as batch_op:
        batch_op.add_column(sa.Column('selected_delivery_option_id', sa.String(length=36), nullable=True))
        batch_op.add_column(sa.Column('applied_delivery_fee', mysql.DECIMAL(precision=10, scale=2), nullable=True))
        batch_op.create_foreign_key(None, 'delivery_options', ['selected_delivery_option_id'], ['id'])

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('payment_transactions', schema=None) as batch_op:
        batch_op.drop_constraint(None, type_='foreignkey')
        batch_op.drop_column('applied_delivery_fee')
        batch_op.drop_column('selected_delivery_option_id')

    with op.batch_alter_table('orders', schema=None) as batch_op:
        batch_op.drop_constraint(None, type_='foreignkey')
        batch_op.drop_column('delivery_fee')
        batch_op.drop_column('delivery_option_id')

    op.drop_table('delivery_options')
    # ### end Alembic commands ###

# === ./app/schemas.py ===
# === ./app/schemas.py ===

from marshmallow import fields, validate, post_dump, exceptions as marshmallow_exceptions
from flask import url_for, current_app
from decimal import Decimal, InvalidOperation

from . import ma, db
from .models import User, Artist, Artwork, Cart, CartItem, Order, OrderItem, DeliveryOption # Added DeliveryOption

class UserSchema(ma.SQLAlchemyAutoSchema):
    password = fields.Str(required=True, load_only=True, validate=validate.Length(min=8))
    email = fields.Email(required=True)
    name = fields.Str()
    address = fields.Str()

    class Meta:
        model = User
        load_instance = True
        exclude = ('password_hash',)
        sqla_session = db.session

class ArtistSchema(ma.SQLAlchemyAutoSchema):
    name = fields.Str(required=True)
    bio = fields.Str()
    artworks = fields.Nested("ArtworkSchema", many=True, dump_only=True)

    class Meta:
        model = Artist
        load_instance = True
        sqla_session = db.session

class ArtworkSchema(ma.SQLAlchemyAutoSchema):
    price = fields.Decimal(as_string=True, required=True, validate=validate.Range(min=0))
    stock_quantity = fields.Int(validate=validate.Range(min=0))
    image_url = fields.String(dump_only=True, required=False, allow_none=True)
    artist = fields.Nested("ArtistSchema", only=('id', 'name'), dump_only=True)
    artist_id = fields.Str(required=True, load_only=True)

    class Meta:
        model = Artwork
        load_instance = True
        sqla_session = db.session

    @post_dump
    def make_image_url_absolute(self, data, **kwargs):
        relative_path = data.get('image_url')
        if relative_path:
            try:
                if current_app:
                    absolute_url = url_for('serve_media', filename=relative_path, _external=True)
                    data['image_url'] = absolute_url
                else:
                    current_app.logger.error(f"No Flask app context available for generating URL for '{relative_path}'.")
                    data['image_url'] = None
            except RuntimeError as e:
                print(f"Could not generate URL for '{relative_path}'. Is app context available? Error: {e}")
                data['image_url'] = None
            except Exception as e:
                print(f"Unexpected error generating URL for '{relative_path}': {e}")
                data['image_url'] = None
        else:
            data['image_url'] = None
        return data

class CartItemSchema(ma.SQLAlchemyAutoSchema):
    artwork = fields.Nested(
        "ArtworkSchema",
        only=('id', 'name', 'price', 'image_url', 'artist', 'stock_quantity')
    )
    quantity = fields.Int(required=True, validate=validate.Range(min=1))

    class Meta:
        model = CartItem
        load_instance = True
        sqla_session = db.session
        exclude = ('cart_id',)

class CartSchema(ma.SQLAlchemyAutoSchema):
    items = fields.Nested(CartItemSchema, many=True)
    total_price = fields.Method("calculate_total", dump_only=True) # This is cart subtotal

    def calculate_total(self, cart):
        total = Decimal('0.00')
        items_iterable = []
        if hasattr(cart, 'items'):
            try:
                items_iterable = cart.items.all() if callable(getattr(cart.items, 'all', None)) else cart.items
            except Exception as e:
                print(f"Could not iterate cart items for cart {getattr(cart, 'id', 'N/A')}: {e}")
                items_iterable = []

        for item in items_iterable:
            if (hasattr(item, 'artwork') and item.artwork and
                hasattr(item.artwork, 'price') and item.artwork.price is not None and
                hasattr(item, 'quantity')):
                try:
                    item_price = Decimal(item.artwork.price)
                    total += item_price * Decimal(item.quantity)
                except (TypeError, ValueError, InvalidOperation) as e:
                    print(f"Could not calculate price for item {getattr(item, 'id', 'N/A')}, artwork {getattr(item.artwork, 'id', 'N/A')}. Price: '{item.artwork.price}', Qty: {item.quantity}. Error: {e}")
                    continue
            else:
                print(f"Artwork data (price/quantity) missing or incomplete for cart item {getattr(item, 'id', 'N/A')} in cart {getattr(cart, 'id', 'N/A')}. Cannot calculate total accurately.")
        return str(total)

    class Meta:
        model = Cart
        load_instance = True
        sqla_session = db.session

class OrderItemSchema(ma.SQLAlchemyAutoSchema):
    artwork = fields.Nested("ArtworkSchema", only=('id', 'name', 'image_url', 'artist'))
    price_at_purchase = fields.Decimal(as_string=True, dump_only=True)
    quantity = fields.Int(dump_only=True)

    class Meta:
        model = OrderItem
        load_instance = True
        sqla_session = db.session
        exclude = ('order_id',)

class DeliveryOptionSchema(ma.SQLAlchemyAutoSchema):
    price = fields.Decimal(as_string=True, required=True)
    name = fields.Str(required=True)
    description = fields.Str(allow_none=True)
    is_pickup = fields.Bool(required=True)
    id = fields.Str(dump_only=True) # Ensure ID is dump_only if auto-generated

    class Meta:
        model = DeliveryOption
        load_instance = True # if you ever load into this schema
        sqla_session = db.session
        # exclude = ('created_at', 'updated_at', 'active', 'sort_order') # if you don't want to send these by default

delivery_option_schema = DeliveryOptionSchema()
delivery_options_schema = DeliveryOptionSchema(many=True)


class OrderSchema(ma.SQLAlchemyAutoSchema):
    items = fields.Nested(OrderItemSchema, many=True, dump_only=True)
    total_price = fields.Decimal(as_string=True, dump_only=True) # This is the grand total
    status = fields.Str(dump_only=True)
    user_id = fields.String(dump_only=True)
    created_at = fields.DateTime(dump_only=True)
    updated_at = fields.DateTime(dump_only=True)
    shipped_at = fields.DateTime(dump_only=True, allow_none=True)
    shipping_address = fields.Str(dump_only=True, allow_none=True)
    billing_address = fields.Str(dump_only=True, allow_none=True)
    payment_gateway_ref = fields.Str(dump_only=True, allow_none=True)

    # --- NEW DELIVERY FIELDS FOR ORDER RESPONSE ---
    delivery_fee = fields.Decimal(as_string=True, dump_only=True)
    delivery_option_details = fields.Nested(DeliveryOptionSchema, dump_only=True, only=("id", "name", "price", "is_pickup", "description"))

    class Meta:
        model = Order
        load_instance = True
        sqla_session = db.session

# Instantiate schemas
user_schema = UserSchema()
artist_schema = ArtistSchema()
artwork_schema = ArtworkSchema()
cart_schema = CartSchema()
order_schema = OrderSchema() # Uses updated OrderSchema

users_schema = UserSchema(many=True)
artists_schema = ArtistSchema(many=True)
artworks_schema = ArtworkSchema(many=True)
orders_schema = OrderSchema(many=True) # Uses updated OrderSchema

# === ./app/models.py ===
import uuid
from datetime import datetime
from sqlalchemy.dialects.mysql import DECIMAL
import json
from flask import current_app

from . import db, bcrypt

def generate_uuid():
    return str(uuid.uuid4())

class Artist(db.Model):
    __tablename__ = 'artists'

    id = db.Column(db.String(36), primary_key=True, default=generate_uuid)
    name = db.Column(db.String(150), nullable=False)
    bio = db.Column(db.Text, nullable=True)
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)

    artworks = db.relationship('Artwork', back_populates='artist', cascade="all, delete-orphan")

    def __repr__(self):
        return f"<Artist {self.name}>"

class User(db.Model):
    __tablename__ = 'users'

    id = db.Column(db.String(36), primary_key=True, default=generate_uuid)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.String(128), nullable=False)
    name = db.Column(db.String(100), nullable=True)
    address = db.Column(db.Text, nullable=True)
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)

    cart = db.relationship('Cart', back_populates='user', uselist=False, cascade="all, delete-orphan")
    orders = db.relationship('Order', back_populates='user', lazy='dynamic', cascade="all, delete-orphan")
    payment_transactions = db.relationship('PaymentTransaction', back_populates='user', lazy='dynamic')


    def set_password(self, password):
        self.password_hash = bcrypt.generate_password_hash(password).decode('utf-8')

    def check_password(self, password):
        return bcrypt.check_password_hash(self.password_hash, password)

    def __repr__(self):
        return f"<User {self.email}>"

class Artwork(db.Model):
    __tablename__ = 'artworks'

    id = db.Column(db.String(36), primary_key=True, default=generate_uuid)
    name = db.Column(db.String(255), nullable=False)
    description = db.Column(db.Text, nullable=True)
    price = db.Column(DECIMAL(precision=10, scale=2), nullable=False)
    stock_quantity = db.Column(db.Integer, nullable=False, default=1)
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)
    image_url = db.Column(db.String(255), nullable=True)

    artist_id = db.Column(db.String(36), db.ForeignKey('artists.id'), nullable=False)

    artist = db.relationship('Artist', back_populates='artworks')
    cart_items = db.relationship('CartItem', back_populates='artwork', lazy='dynamic')
    order_items = db.relationship('OrderItem', back_populates='artwork', lazy='dynamic')

    def __repr__(self):
        return f"<Artwork {self.name} by Artist {self.artist_id}>"

class Cart(db.Model):
    __tablename__ = 'carts'

    id = db.Column(db.String(36), primary_key=True, default=generate_uuid)
    user_id = db.Column(db.String(36), db.ForeignKey('users.id'), unique=True, nullable=False)
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)

    user = db.relationship('User', back_populates='cart')
    items = db.relationship('CartItem', back_populates='cart', cascade="all, delete-orphan", lazy='joined')

    def __repr__(self):
        return f"<Cart {self.id} for User {self.user_id}>"

class CartItem(db.Model):
    __tablename__ = 'cart_items'

    id = db.Column(db.String(36), primary_key=True, default=generate_uuid)
    cart_id = db.Column(db.String(36), db.ForeignKey('carts.id'), nullable=False)
    artwork_id = db.Column(db.String(36), db.ForeignKey('artworks.id'), nullable=False)
    quantity = db.Column(db.Integer, nullable=False, default=1)

    __table_args__ = (db.UniqueConstraint('cart_id', 'artwork_id', name='_cart_artwork_uc'),)

    cart = db.relationship('Cart', back_populates='items')
    artwork = db.relationship('Artwork', back_populates='cart_items', lazy='joined')

    def __repr__(self):
        return f"<CartItem Artwork {self.artwork_id} Qty {self.quantity} in Cart {self.cart_id}>"

class DeliveryOption(db.Model):
    __tablename__ = 'delivery_options'

    id = db.Column(db.String(36), primary_key=True, default=generate_uuid)
    name = db.Column(db.String(255), nullable=False, unique=True)
    price = db.Column(DECIMAL(precision=10, scale=2), nullable=False, default=0.00)
    description = db.Column(db.Text, nullable=True)
    is_pickup = db.Column(db.Boolean, default=False, nullable=False)
    active = db.Column(db.Boolean, default=True, nullable=False)
    sort_order = db.Column(db.Integer, default=0, nullable=False)
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)

    def __repr__(self):
        return f"<DeliveryOption {self.name} Price: {self.price}>"

class Order(db.Model):
    __tablename__ = 'orders'

    id = db.Column(db.String(36), primary_key=True, default=generate_uuid)
    user_id = db.Column(db.String(36), db.ForeignKey('users.id'), nullable=False)
    total_price = db.Column(DECIMAL(precision=10, scale=2), nullable=False)
    status = db.Column(db.String(50), nullable=False, default='pending')
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)
    shipped_at = db.Column(db.DateTime, nullable=True)
    shipping_address = db.Column(db.Text, nullable=True)
    billing_address = db.Column(db.Text, nullable=True)
    payment_gateway_ref = db.Column(db.String(255), nullable=True)

    delivery_option_id = db.Column(db.String(36), db.ForeignKey('delivery_options.id'), nullable=True)
    delivery_fee = db.Column(DECIMAL(precision=10, scale=2), nullable=False, default=0.00)

    user = db.relationship('User', back_populates='orders')
    items = db.relationship('OrderItem', back_populates='order', cascade="all, delete-orphan", lazy='joined')
    
    payment_transaction_id = db.Column(db.String(36), db.ForeignKey('payment_transactions.id'), nullable=True, index=True)
    payment_transaction = db.relationship('PaymentTransaction', backref=db.backref('order_record', uselist=False))
    
    delivery_option_details = db.relationship('DeliveryOption', lazy='joined')

    def __repr__(self):
        return f"<Order {self.id} Status {self.status} User {self.user_id} Total {self.total_price}>"

class OrderItem(db.Model):
    __tablename__ = 'order_items'

    id = db.Column(db.String(36), primary_key=True, default=generate_uuid)
    order_id = db.Column(db.String(36), db.ForeignKey('orders.id'), nullable=False)
    artwork_id = db.Column(db.String(36), db.ForeignKey('artworks.id'), nullable=False)
    quantity = db.Column(db.Integer, nullable=False)
    price_at_purchase = db.Column(DECIMAL(precision=10, scale=2), nullable=False)

    order = db.relationship('Order', back_populates='items')
    artwork = db.relationship('Artwork', back_populates='order_items', lazy='joined')

    def __repr__(self):
        return f"<OrderItem Artwork {self.artwork_id} Qty {self.quantity} Price {self.price_at_purchase} in Order {self.order_id}>"

class PaymentTransaction(db.Model):
    __tablename__ = 'payment_transactions'

    id = db.Column(db.String(36), primary_key=True, default=generate_uuid)
    checkout_request_id = db.Column(db.String(100), unique=True, nullable=True, index=True)
    user_id = db.Column(db.String(36), db.ForeignKey('users.id'), nullable=False)
    cart_id = db.Column(db.String(36), db.ForeignKey('carts.id'), nullable=True) 
    amount = db.Column(DECIMAL(precision=10, scale=2), nullable=False)
    phone_number = db.Column(db.String(15), nullable=True)
    status = db.Column(db.String(50), nullable=False, default='initiated') 
    daraja_response_description = db.Column(db.Text, nullable=True)
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)

    _cart_items_snapshot = db.Column(db.Text, nullable=True)

    selected_delivery_option_id = db.Column(db.String(36), db.ForeignKey('delivery_options.id'), nullable=True)
    applied_delivery_fee = db.Column(DECIMAL(precision=10, scale=2), nullable=True)

    user = db.relationship('User', back_populates='payment_transactions')


    @property
    def cart_items_snapshot(self):
        if self._cart_items_snapshot:
            try:
                return json.loads(self._cart_items_snapshot)
            except json.JSONDecodeError:
                current_app.logger.error(f"Failed to decode cart_items_snapshot for PaymentTransaction {self.id}")
                return None
        return None

    @cart_items_snapshot.setter
    def cart_items_snapshot(self, value):
        if value:
            self._cart_items_snapshot = json.dumps(value)
        else:
            self._cart_items_snapshot = None
            
    def __repr__(self):
        return f"<PaymentTransaction {self.id} CRID: {self.checkout_request_id} Status: {self.status} Amount: {self.amount}>"

# === ./app/config.py ===
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    SECRET_KEY = os.getenv('SECRET_KEY')
    JWT_SECRET_KEY = os.getenv('JWT_SECRET_KEY')
    SQLALCHEMY_TRACK_MODIFICATIONS = False

    DATABASE_USER = os.getenv('DATABASE_USER')
    DATABASE_PASSWORD = os.getenv('DATABASE_PASSWORD')
    DATABASE_HOST = os.getenv('DATABASE_HOST')
    DATABASE_PORT = os.getenv('DATABASE_PORT')
    DATABASE_NAME = os.getenv('DATABASE_NAME')
    SQLALCHEMY_DATABASE_URI = (
        f"mysql+pymysql://{DATABASE_USER}:{DATABASE_PASSWORD}@{DATABASE_HOST}:{DATABASE_PORT}/{DATABASE_NAME}"
    )

    JWT_BLACKLIST_ENABLED = True
    JWT_BLACKLIST_TOKEN_CHECKS = ['access']

    DARAJA_ENVIRONMENT = os.getenv('DARAJA_ENVIRONMENT', 'sandbox')
    DARAJA_CONSUMER_KEY = os.getenv('DARAJA_CONSUMER_KEY')
    DARAJA_CONSUMER_SECRET = os.getenv('DARAJA_CONSUMER_SECRET')
    DARAJA_SHORTCODE = os.getenv('DARAJA_SHORTCODE')
    DARAJA_PASSKEY = os.getenv('DARAJA_PASSKEY')
    DARAJA_TRANSACTION_TYPE = os.getenv('DARAJA_TRANSACTION_TYPE', 'CustomerPayBillOnline')
    DARAJA_CALLBACK_URL_BASE = os.getenv('DARAJA_CALLBACK_URL_BASE')

    if DARAJA_ENVIRONMENT == 'production':
        DARAJA_AUTH_URL = 'https://api.safaricom.co.ke/oauth/v1/generate?grant_type=client_credentials'
        DARAJA_STK_PUSH_URL = 'https://api.safaricom.co.ke/mpesa/stkpush/v1/processrequest'
    else:
        DARAJA_AUTH_URL = 'https://sandbox.safaricom.co.ke/oauth/v1/generate?grant_type=client_credentials'
        DARAJA_STK_PUSH_URL = 'https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest'

    DARAJA_CALLBACK_URL = f"{DARAJA_CALLBACK_URL_BASE.rstrip('/')}/api/payments/callback"


    if not all([DARAJA_CONSUMER_KEY, DARAJA_CONSUMER_SECRET, DARAJA_SHORTCODE, DARAJA_PASSKEY, DARAJA_CALLBACK_URL_BASE]):
        print("WARNING: Essential Daraja configuration missing in environment variables!")

# === ./app/__init__.py ===
# === ./app/__init__.py ===

import os
from flask import Flask, jsonify, send_from_directory, abort, current_app
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from flask_jwt_extended import JWTManager
from flask_bcrypt import Bcrypt
from flask_marshmallow import Marshmallow
from flask_cors import CORS
from .config import Config

db = SQLAlchemy()
migrate = Migrate()
jwt = JWTManager()
bcrypt = Bcrypt()
ma = Marshmallow()
cors = CORS()

BLOCKLIST = set()

@jwt.token_in_blocklist_loader
def check_if_token_in_blocklist(jwt_header, jwt_payload):
    jti = jwt_payload["jti"]
    return jti in BLOCKLIST

@jwt.unauthorized_loader
def missing_token_callback(error):
    return jsonify({"description": "Request does not contain an access token.", "error": "authorization_required"}), 401

def create_app(config_class=Config):
    app = Flask(__name__) # Corrected: __name__
    app.config.from_object(config_class)

    print(f"DEBUG: Connecting to DB: {app.config['SQLALCHEMY_DATABASE_URI']}")

    MEDIA_FOLDER = os.path.join(app.root_path, '..', 'media')
    app.config['MEDIA_FOLDER'] = MEDIA_FOLDER
    print(f"DEBUG: Media folder (base) set to: {app.config['MEDIA_FOLDER']}")

    db.init_app(app)
    migrate.init_app(app, db)
    jwt.init_app(app)
    bcrypt.init_app(app)
    ma.init_app(app)
    cors.init_app(app, resources={r"/api/*": {"origins": "*"}, r"/media/*": {"origins": "*"}})

    from . import models # Import models after db is initialized and configured

    @app.route('/media/<path:filename>')
    def serve_media(filename):
        print(f"Attempting to serve media file: {filename}")
        media_folder = current_app.config.get('MEDIA_FOLDER')
        if not media_folder:
            print("ERROR: MEDIA_FOLDER not configured in Flask app.")
            abort(500)
        try:
            return send_from_directory(media_folder, filename)
        except FileNotFoundError:
            full_path = os.path.join(media_folder, filename)
            print(f"ERROR: File not found: {full_path}")
            abort(404)
        except Exception as e:
            print(f"ERROR: Unexpected error serving file {filename}: {e}")
            abort(500)


    from .resources.auth import auth_bp
    from .resources.artwork import artwork_bp
    from .resources.artist import artist_bp
    from .resources.cart import cart_bp
    from .resources.order import order_bp
    from .resources.payment import payment_bp
    from .resources.delivery import delivery_bp # <--- IMPORT NEW BLUEPRINT

    app.register_blueprint(auth_bp, url_prefix='/api/auth')
    app.register_blueprint(artwork_bp, url_prefix='/api/artworks')
    app.register_blueprint(artist_bp, url_prefix='/api/artists')
    app.register_blueprint(cart_bp, url_prefix='/api/cart')
    app.register_blueprint(order_bp, url_prefix='/api/orders')
    app.register_blueprint(payment_bp, url_prefix='/api/payments')
    app.register_blueprint(delivery_bp, url_prefix='/api/delivery') # <--- REGISTER NEW BLUEPRINT


    @app.route('/')
    def index():
        return "Shoply Artwork Backend is running!"

    return app

# === ./app/resources/cart.py ===
from flask import request, Blueprint, jsonify
from flask_restful import Resource, Api, abort
from marshmallow import ValidationError, fields
from sqlalchemy.orm import joinedload

from .. import db, ma
from ..models import Cart, CartItem, Artwork, User
from ..schemas import cart_schema

from flask_jwt_extended import jwt_required, get_jwt_identity

cart_bp = Blueprint('cart', __name__)
cart_api = Api(cart_bp)

def get_or_create_cart(user_id):
    """Finds the user's cart or creates one if it doesn't exist."""
    user = User.query.get(user_id)
    if not user:
        abort(404, message="User not found.")

    cart = Cart.query.options(
        joinedload(Cart.items).options(
            joinedload(CartItem.artwork).joinedload(Artwork.artist)
        )
    ).filter_by(user_id=user_id).first()

    if not cart:
        cart = Cart(user_id=user_id)
        db.session.add(cart)
        try:
            db.session.commit()
        except Exception as e:
            db.session.rollback()
            print(f"Error creating new cart: {e}")
            abort(500, message="Could not create cart.")
        cart = Cart.query.options(
            joinedload(Cart.items).options(
                joinedload(CartItem.artwork).joinedload(Artwork.artist)
            )
        ).filter_by(user_id=user_id).first()

    return cart

class AddToCartSchema(ma.Schema):
    artwork_id = fields.Str(required=True)
    quantity = fields.Int(required=True, validate=lambda q: q > 0)

add_to_cart_schema = AddToCartSchema()


class CartResource(Resource):
    @jwt_required()
    def get(self):
        """
        Fetches the current user's cart contents, including artwork and artist details.
        """
        user_id = get_jwt_identity()
        cart = get_or_create_cart(user_id)

        return cart_schema.dump(cart), 200

    @jwt_required()
    def post(self):
        """
        Adds an artwork to the current user's cart or updates its quantity.
        """
        user_id = get_jwt_identity()
        json_data = request.get_json()
        if not json_data:
            abort(400, message="No input data provided")

        try:
            data = add_to_cart_schema.load(json_data)
        except ValidationError as err:
            abort(400, message=err.messages)

        artwork_id = data['artwork_id']
        quantity_to_add = data['quantity']

        cart = get_or_create_cart(user_id)
        if cart.id is None:
            abort(500, message="Failed to retrieve or initialize cart.")

        artwork = Artwork.query.get(artwork_id)

        if not artwork:
            abort(404, message=f"Artwork with ID {artwork_id} not found.")

        if artwork.stock_quantity < quantity_to_add:
             abort(400, message=f"Insufficient stock for Artwork ID {artwork_id}. Available: {artwork.stock_quantity}")

        cart_item = next((item for item in cart.items if item.artwork_id == artwork_id), None)
        if cart_item is None:
             cart_item = CartItem.query.filter_by(cart_id=cart.id, artwork_id=artwork_id).first()


        if cart_item:
            new_quantity = cart_item.quantity + quantity_to_add
            if artwork.stock_quantity < new_quantity:
                 abort(400, message=f"Insufficient stock to increase quantity for Artwork ID {artwork_id}. Available: {artwork.stock_quantity}, In Cart: {cart_item.quantity}")
            cart_item.quantity = new_quantity
        else:
            cart_item = CartItem(cart_id=cart.id, artwork_id=artwork_id, quantity=quantity_to_add)
            db.session.add(cart_item)

        try:
            db.session.commit()
            cart_updated = Cart.query.options(
                 joinedload(Cart.items).options(
                     joinedload(CartItem.artwork).joinedload(Artwork.artist)
                 )
            ).get(cart.id)
            return cart_schema.dump(cart_updated), 200
        except Exception as e:
            db.session.rollback()
            print(f"Error committing cart changes: {e}")
            if "UniqueViolation" in str(e) or "_cart_artwork_uc" in str(e):
                 abort(409, message="Item already exists in cart or concurrent modification error.")
            abort(500, message="An error occurred while updating the cart.")


class CartItemResource(Resource):

    @jwt_required()
    def put(self, item_id):
        """
        Updates the quantity of a specific item in the cart.
        """
        user_id = get_jwt_identity()
        cart = get_or_create_cart(user_id)

        json_data = request.get_json()
        if not json_data or 'quantity' not in json_data:
             abort(400, message="Quantity is required.")

        try:
            new_quantity = int(json_data['quantity'])
            if new_quantity <= 0:
                abort(400, message="Quantity must be positive. Use DELETE to remove item.")
        except ValueError:
            abort(400, message="Quantity must be an integer.")

        cart_item = CartItem.query.filter_by(id=item_id, cart_id=cart.id).first()
        if not cart_item:
            abort(404, message=f"Cart item with ID {item_id} not found in your cart.")

        artwork = Artwork.query.get(cart_item.artwork_id)
        if not artwork:
             abort(404, message=f"Artwork associated with cart item not found.")

        if artwork.stock_quantity < new_quantity:
            abort(400, message=f"Insufficient stock for Artwork ID {artwork.id}. Available: {artwork.stock_quantity}")

        cart_item.quantity = new_quantity

        try:
            db.session.commit()
            cart_updated = Cart.query.options(
                 joinedload(Cart.items).options(
                     joinedload(CartItem.artwork).joinedload(Artwork.artist)
                 )
            ).get(cart.id)
            return cart_schema.dump(cart_updated), 200
        except Exception as e:
            db.session.rollback()
            print(f"Error updating cart item: {e}")
            abort(500, message="An error occurred while updating the cart item.")


    @jwt_required()
    def delete(self, item_id):
        """
        Removes a specific item from the cart.
        """
        user_id = get_jwt_identity()
        cart = get_or_create_cart(user_id)

        cart_item = CartItem.query.filter_by(id=item_id, cart_id=cart.id).first()
        if not cart_item:
            abort(404, message=f"Cart item with ID {item_id} not found in your cart.")

        try:
            db.session.delete(cart_item)
            db.session.commit()
            cart_updated = Cart.query.options(
                 joinedload(Cart.items).options(
                     joinedload(CartItem.artwork).joinedload(Artwork.artist)
                 )
            ).get(cart.id)
            return cart_schema.dump(cart_updated), 200
        except Exception as e:
            db.session.rollback()
            print(f"Error deleting cart item: {e}")
            abort(500, message="An error occurred while removing the item from the cart.")


cart_api.add_resource(CartResource, '/', '')
cart_api.add_resource(CartItemResource, '/items/<string:item_id>')

# === ./app/resources/artist.py ===
from flask import request, Blueprint, jsonify
from flask_restful import Resource, Api, abort
from marshmallow import ValidationError
from sqlalchemy.orm import joinedload

from .. import db
from ..models import Artist, Artwork
from ..schemas import artist_schema, artists_schema


artist_bp = Blueprint('artists', __name__)
artist_api = Api(artist_bp)

class ArtistList(Resource):
    def get(self):
        """
        Fetches all artists.
        """
        artists = Artist.query.order_by(Artist.name).all()
        return artists_schema.dump(artists), 200

    def post(self):
        """
        Creates a new artist.
        """

        json_data = request.get_json()
        if not json_data:
            return {"message": "No input data provided"}, 400

        try:
            new_artist = artist_schema.load(json_data, session=db.session)
        except ValidationError as err:
            return {"message": "Validation errors", "errors": err.messages}, 400
        except Exception as e:
            print(f"Unexpected error during artist schema load: {e}")
            abort(500, message="An internal error occurred during data processing.")


        try:
            db.session.add(new_artist)
            db.session.commit()
            return artist_schema.dump(new_artist), 201
        except Exception as e:
            db.session.rollback()
            print(f"Error creating artist in DB: {e}")
            abort(500, message="An error occurred while saving the artist.")

class ArtistDetail(Resource):
    def get(self, artist_id):
        """
        Fetches a single artist by UUID, including their artworks.
        """
        artist = Artist.query.options(
            joinedload(Artist.artworks)
        ).get_or_404(artist_id, description=f"Artist with ID {artist_id} not found.")

        return artist_schema.dump(artist), 200

    def patch(self, artist_id):
        """
        Updates an existing artist partially.
        """

        artist = Artist.query.get_or_404(artist_id, description=f"Artist with ID {artist_id} not found.")

        json_data = request.get_json()
        if not json_data:
            return {"message": "No input data provided"}, 400

        try:
            updated_artist = artist_schema.load(
                json_data,
                instance=artist,
                partial=True,
                session=db.session
            )
        except ValidationError as err:
            return {"message": "Validation errors", "errors": err.messages}, 400

        try:
            db.session.commit()
            return artist_schema.dump(updated_artist), 200
        except Exception as e:
            db.session.rollback()
            print(f"Error updating artist {artist_id}: {e}")
            abort(500, message="An error occurred while updating the artist.")

    def delete(self, artist_id):
        """
        Deletes an artist by UUID.
        Note: This will likely cascade delete associated artworks due to relationship setting.
        Consider consequences before enabling direct artist deletion.
        """

        artist = Artist.query.get_or_404(artist_id, description=f"Artist with ID {artist_id} not found.")


        try:
            db.session.delete(artist)
            db.session.commit()
            return '', 204
        except Exception as e:
            db.session.rollback()
            print(f"Error deleting artist {artist_id}: {e}")
            abort(500, message="An error occurred while deleting the artist.")


artist_api.add_resource(ArtistList, '/')
artist_api.add_resource(ArtistDetail, '/<string:artist_id>')

# === ./app/resources/order.py ===
# === ./app/resources/order.py ===

from flask import request, Blueprint, jsonify, current_app
from flask_restful import Resource, Api, abort
from marshmallow import fields, Schema, ValidationError, validate
from sqlalchemy.orm import joinedload
from decimal import Decimal
import json
from datetime import datetime

from .. import db, ma
from ..models import Order, OrderItem, User, Cart, Artwork, CartItem, Artist, PaymentTransaction, DeliveryOption
from ..schemas import order_schema, orders_schema # delivery_option_schema not directly used for input here

from flask_jwt_extended import jwt_required, get_jwt_identity
from ..utils.daraja_client import initiate_stk_push

order_bp = Blueprint('orders', __name__)
order_api = Api(order_bp)

class CheckoutInputSchema(ma.Schema):
    phone_number = fields.Str(
        required=True,
        validate=validate.Regexp(
            r'^254\d{9}$',
            error="Phone number must be 12 digits and start with 254 (e.g., 2547XXXXXXXX)."
        )
    )
    delivery_option_id = fields.Str(required=True) # ID of the chosen DeliveryOption
    # delivery_address = fields.Str(required=False, allow_none=True) # Future: If allowing custom address different from user.address

checkout_input_schema = CheckoutInputSchema()

class OrderList(Resource):
    @jwt_required()
    def get(self):
        user_id = get_jwt_identity()
        user_orders = Order.query.options(
            joinedload(Order.items).options(
                joinedload(OrderItem.artwork).joinedload(Artwork.artist)
            ),
            joinedload(Order.delivery_option_details) # Eager load delivery option details with the order
        ).filter_by(user_id=user_id).order_by(Order.created_at.desc()).all()
        return orders_schema.dump(user_orders), 200

    @jwt_required()
    def post(self): # This is the STK Initiation endpoint
        user_id = get_jwt_identity()
        current_user = User.query.get(user_id)
        if not current_user:
            abort(401, message="User not found or invalid token.")

        json_data = request.get_json()
        if not json_data:
            abort(400, message="Missing checkout data (e.g., phone_number, delivery_option_id).")
        try:
            checkout_data = checkout_input_schema.load(json_data)
        except ValidationError as err:
            abort(400, message=err.messages)

        phone_number = checkout_data['phone_number']
        selected_delivery_option_id = checkout_data['delivery_option_id']
        # custom_delivery_address = checkout_data.get('delivery_address') # If implemented for custom address

        cart = Cart.query.options(
            joinedload(Cart.items).joinedload(CartItem.artwork) # Ensure artwork is loaded with cart items
        ).filter_by(user_id=user_id).first()
        
        if not cart or not cart.items:
            abort(400, message="Your cart is empty.")

        # Fetch the selected delivery option
        delivery_option = DeliveryOption.query.get(selected_delivery_option_id)
        if not delivery_option or not delivery_option.active:
            abort(400, message="Invalid or inactive delivery option selected.")
        
        applied_delivery_fee = delivery_option.price

        # Recalculate cart subtotal and prepare item snapshot
        cart_subtotal_decimal = Decimal('0.0')
        item_details_for_transaction_snapshot = []
        
        for item in cart.items:
            if not item.artwork: 
                current_app.logger.error(f"Critical: Artwork data missing for cart item {item.id} during checkout. Cart ID: {cart.id}")
                abort(500, message="Error processing cart. An artwork is missing details.")
            
            if item.artwork.stock_quantity < item.quantity:
                abort(400, message=f"Insufficient stock for '{item.artwork.name}'. Available: {item.artwork.stock_quantity}, Requested: {item.quantity}")
            
            cart_subtotal_decimal += Decimal(item.artwork.price) * Decimal(item.quantity)
            item_details_for_transaction_snapshot.append({
                'artwork_id': item.artwork.id,
                'name': item.artwork.name,
                'quantity': item.quantity,
                'price_at_purchase': str(item.artwork.price) 
            })
        
        if cart_subtotal_decimal < Decimal('0.0'): # Should ideally be >= 0
            abort(400, message="Cart subtotal cannot be negative.")
        
        # Grand total for payment
        grand_total_for_payment = cart_subtotal_decimal + applied_delivery_fee
        if grand_total_for_payment <= Decimal('0.0'): # Mpesa STK needs > 0
            abort(400, message="Total amount for payment (including delivery) must be greater than zero.")


        # Create PaymentTransaction record
        transaction = PaymentTransaction(
            user_id=user_id,
            cart_id=cart.id,
            amount=grand_total_for_payment, 
            phone_number=phone_number,
            status='pending_stk_initiation',
            _cart_items_snapshot=json.dumps(item_details_for_transaction_snapshot),
            selected_delivery_option_id=selected_delivery_option_id,
            applied_delivery_fee=applied_delivery_fee
        )
        try:
            db.session.add(transaction)
            db.session.commit() # Commit to get transaction.id
            current_app.logger.info(f"Created PaymentTransaction {transaction.id} for user {user_id}, cart {cart.id}, amount {grand_total_for_payment} (subtotal: {cart_subtotal_decimal}, delivery: {applied_delivery_fee})")
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Failed to create PaymentTransaction for user {user_id}: {e}", exc_info=True)
            abort(500, message="Error preparing payment. Please try again.")

        daraja_account_ref = transaction.id 
        amount_for_daraja = int(round(float(grand_total_for_payment))) # Daraja STK usually wants whole number

        stk_response, status_code = initiate_stk_push(
            phone_number=phone_number,
            amount=amount_for_daraja,
            order_id=daraja_account_ref, 
            description=f"Artistry Haven Order {transaction.id[:8]}"
        )

        if status_code >= 400 or str(stk_response.get("ResponseCode", "1")) != "0":
            error_msg = stk_response.get("errorMessage", stk_response.get("ResponseDescription", "Failed to initiate STK push."))
            current_app.logger.error(f"STK Push Initiation Failed for user {user_id}, Transaction {transaction.id}: Code {stk_response.get('ResponseCode', 'N/A')}, Desc: {error_msg}")
            transaction.status = 'failed_stk_initiation'
            transaction.daraja_response_description = error_msg
            db.session.commit()
            abort(status_code if status_code >= 400 else 500, message=error_msg)

        checkout_request_id_from_daraja = stk_response.get('CheckoutRequestID')
        if not checkout_request_id_from_daraja:
            current_app.logger.error(f"STK Push initiated but CheckoutRequestID missing. User: {user_id}, Transaction: {transaction.id}")
            transaction.status = 'failed_stk_missing_id'
            transaction.daraja_response_description = "CheckoutRequestID missing from Daraja response."
            db.session.commit()
            abort(500, message="Payment initiation incomplete. Please contact support if debited.")
        
        transaction.checkout_request_id = checkout_request_id_from_daraja
        transaction.status = 'pending_confirmation' 
        transaction.daraja_response_description = stk_response.get("ResponseDescription")
        db.session.commit()

        current_app.logger.info(f"STK Push successful for Transaction {transaction.id}. Daraja CheckoutRequestID: {checkout_request_id_from_daraja}")

        return {
            "message": "STK Push initiated successfully. Please check your phone to authorize payment.",
            "CheckoutRequestID": checkout_request_id_from_daraja,
            "transaction_id": transaction.id, 
            "ResponseDescription": stk_response.get("ResponseDescription", "Success")
        }, 200

class OrderDetail(Resource):
    @jwt_required()
    def get(self, order_id):
        user_id = get_jwt_identity()
        order = Order.query.options(
            joinedload(Order.items).options(
                joinedload(OrderItem.artwork).joinedload(Artwork.artist)
            ),
            joinedload(Order.delivery_option_details) # Eager load delivery option details
        ).filter_by(id=order_id, user_id=user_id).first_or_404(
            description=f"Order with ID {order_id} not found or does not belong to user."
        )
        return order_schema.dump(order), 200

class PaymentStatus(Resource):
    @jwt_required()
    def get(self, checkout_request_id_from_url):
        user_id = get_jwt_identity()
        transaction = PaymentTransaction.query.filter_by(
            checkout_request_id=checkout_request_id_from_url,
            user_id=user_id
        ).first()

        if not transaction:
            current_app.logger.warning(f"PaymentStatus GET: Transaction not found for CRID {checkout_request_id_from_url} and user {user_id}")
            return {"status": "not_found", "message": "Transaction not found or still processing initial STK push."}, 404

        response_data = {
            "status": transaction.status,
            "checkout_request_id": transaction.checkout_request_id,
            "message": transaction.daraja_response_description or transaction.status.replace('_', ' ').title()
        }
        
        if transaction.status == 'successful' and transaction.order_record:
            response_data["order_id"] = transaction.order_record.id
        
        return response_data, 200

order_api.add_resource(OrderList, '/')
order_api.add_resource(OrderDetail, '/<string:order_id>') # Ensure string type hint for path param
order_api.add_resource(PaymentStatus, '/status/<string:checkout_request_id_from_url>') # Ensure string type hint

# === ./app/resources/delivery.py ===
# === ./app/resources/delivery.py ===

from flask import Blueprint
from flask_restful import Resource, Api, current_app

from ..models import DeliveryOption
from ..schemas import delivery_options_schema, delivery_option_schema # delivery_option_schema might not be used here

delivery_bp = Blueprint('delivery', __name__)
delivery_api = Api(delivery_bp)

class DeliveryOptionList(Resource):
    def get(self):
        """Fetches all active delivery options, ordered by sort_order then name."""
        try:
            options = DeliveryOption.query.filter_by(active=True).order_by(DeliveryOption.sort_order, DeliveryOption.name).all()
            return delivery_options_schema.dump(options), 200
        except Exception as e:
            current_app.logger.error(f"Error fetching delivery options: {e}")
            return {"message": "Could not retrieve delivery options"}, 500

delivery_api.add_resource(DeliveryOptionList, '/options') # Route for GET /api/delivery/options

# === ./app/resources/payment.py ===
# === ./app/resources/payment.py ===

from flask import request, Blueprint, jsonify, current_app
from flask_restful import Resource, Api, abort
from decimal import Decimal
import json

from .. import db
from ..models import Order, OrderItem, Artwork, Cart, CartItem, User, PaymentTransaction, DeliveryOption # Added DeliveryOption

payment_bp = Blueprint('payments', __name__)
payment_api = Api(payment_bp)

class DarajaCallback(Resource):
    def post(self):
        current_app.logger.info("--- Daraja Callback Received ---")
        try:
            callback_data = request.get_json()
            if not callback_data:
                current_app.logger.error("Daraja Callback: Received empty JSON body.")
                return {"ResultCode": 0, "ResultDesc": "Accepted empty body"}, 200
        except Exception as e:
            current_app.logger.error(f"Daraja Callback: Failed to parse JSON body: {e}. Raw data: {request.data}")
            return {"ResultCode": 0, "ResultDesc": "Accepted invalid JSON"}, 200

        current_app.logger.info(f"Daraja Callback - Raw Data: {json.dumps(callback_data)}")

        if 'Body' not in callback_data or 'stkCallback' not in callback_data['Body']:
            current_app.logger.error("Daraja Callback ERROR: Invalid format. Missing 'Body' or 'stkCallback'.")
            return {"ResultCode": 0, "ResultDesc": "Accepted format error"}, 200

        stk_callback = callback_data['Body']['stkCallback']
        result_code_from_daraja = str(stk_callback.get('ResultCode', '-1'))
        checkout_request_id = stk_callback.get('CheckoutRequestID')
        daraja_result_desc = stk_callback.get('ResultDesc', 'No ResultDesc from Daraja.')
        daraja_merchant_request_id = stk_callback.get('MerchantRequestID')

        current_app.logger.info(f"Daraja Callback - Processing: CRID: {checkout_request_id}, Daraja_MRID: {daraja_merchant_request_id}, ResultCode: {result_code_from_daraja}, ResultDesc: {daraja_result_desc}")

        if not checkout_request_id:
            current_app.logger.error("Daraja Callback ERROR: CheckoutRequestID missing from Daraja. Cannot process.")
            return {"ResultCode": 0, "ResultDesc": "Accepted missing CheckoutRequestID"}, 200
        
        transaction = PaymentTransaction.query.filter_by(checkout_request_id=checkout_request_id).first()

        if not transaction:
            current_app.logger.warning(f"Daraja Callback WARNING: PaymentTransaction for CRID {checkout_request_id} not found in DB. Daraja MerchantRequestID was {daraja_merchant_request_id}.")
            return {"ResultCode": 0, "ResultDesc": "Accepted, transaction not found by CRID"}, 200

        current_app.logger.info(f"Daraja Callback: Found internal PaymentTransaction {transaction.id} with status {transaction.status} for CRID {checkout_request_id}.")

        final_states = ['successful', 'failed_daraja', 'cancelled_by_user', 'failed_processing_error', 'failed_underpaid', 'failed_missing_receipt', 'failed_timeout']
        if transaction.status in final_states:
            current_app.logger.info(f"Daraja Callback INFO: Transaction {transaction.id} (CRID: {checkout_request_id}) already in a final state: {transaction.status}. Ignoring callback.")
            return {"ResultCode": 0, "ResultDesc": "Accepted, already processed"}, 200

        transaction.daraja_response_description = daraja_result_desc

        if result_code_from_daraja == "0":
            current_app.logger.info(f"Daraja Callback SUCCESS: Payment successful for Transaction {transaction.id} (CRID: {checkout_request_id}).")

            metadata_items = stk_callback.get('CallbackMetadata', {}).get('Item', [])
            metadata = {item['Name']: item.get('Value') for item in metadata_items if 'Name' in item and 'Value' in item}
            
            amount_paid_str = str(metadata.get('Amount', "0.00"))
            mpesa_receipt = metadata.get('MpesaReceiptNumber')
            
            current_app.logger.info(f"Transaction {transaction.id}: Amount Paid (Daraja): {amount_paid_str}, Expected: {transaction.amount}, M-Pesa Receipt: {mpesa_receipt}")

            if not mpesa_receipt:
                current_app.logger.error(f"Transaction {transaction.id}: MpesaReceiptNumber is MISSING from Daraja callback (ResultCode 0). Marking as processing error.")
                transaction.status = 'failed_missing_receipt'
                transaction.daraja_response_description = "MpesaReceiptNumber missing from successful Daraja callback."
                try:
                    db.session.commit()
                except Exception as e_commit:
                    db.session.rollback()
                    current_app.logger.error(f"Transaction {transaction.id}: DB Error committing 'failed_missing_receipt' status: {e_commit}")
                return {"ResultCode": 0, "ResultDesc": "Accepted, MpesaReceiptNumber missing"}, 200
            
            try:
                amount_paid_decimal = Decimal(amount_paid_str)
            except Exception as e_decimal:
                current_app.logger.error(f"Transaction {transaction.id}: Could not convert Daraja Amount '{amount_paid_str}' to Decimal: {e_decimal}. Marking as processing error.")
                transaction.status = 'failed_processing_error'
                transaction.daraja_response_description = f"Invalid amount format from Daraja: {amount_paid_str}"
                try:
                    db.session.commit()
                except Exception as e_commit:
                    db.session.rollback()
                    current_app.logger.error(f"Transaction {transaction.id}: DB Error committing status for invalid amount: {e_commit}")
                return {"ResultCode": 0, "ResultDesc": "Accepted, invalid amount format"}, 200

            if amount_paid_decimal < transaction.amount:
                current_app.logger.warning(f"Transaction {transaction.id}: Amount paid ({amount_paid_decimal}) is less than expected ({transaction.amount}). Marking as underpaid.")
                transaction.status = 'failed_underpaid'
                try:
                    db.session.commit()
                except Exception as e_commit:
                    db.session.rollback()
                    current_app.logger.error(f"Transaction {transaction.id}: DB Error committing 'failed_underpaid' status: {e_commit}")
            else:
                try:
                    user = User.query.get(transaction.user_id)
                    
                    chosen_delivery_option = DeliveryOption.query.get(transaction.selected_delivery_option_id)
                    shipping_addr = "Error: Delivery Option details not found."
                    if chosen_delivery_option:
                        if chosen_delivery_option.is_pickup:
                            shipping_addr = chosen_delivery_option.description or "In Store Pick Up: Dynamic Mall, Shop M90, CBD, Nairobi"
                        else:
                            shipping_addr = user.address if user and user.address else "Delivery Address Not Specified by User"
                            if not user.address and not chosen_delivery_option.is_pickup:
                                current_app.logger.warning(f"Transaction {transaction.id}: Delivery option chosen but user has no default address. Shipping address set to generic.")
                    else:
                        current_app.logger.error(f"Transaction {transaction.id}: selected_delivery_option_id {transaction.selected_delivery_option_id} did not resolve to a DeliveryOption.")
                        shipping_addr = user.address if user and user.address else "Default Pickup: Dynamic Mall, Shop M90, CBD"


                    items_to_order_snapshot = transaction.cart_items_snapshot
                    if not items_to_order_snapshot:
                        current_app.logger.error(f"Transaction {transaction.id}: Cart items snapshot missing. Cannot create order.")
                        raise ValueError("Cart items snapshot missing for order creation.")

                    new_order = Order(
                        user_id=transaction.user_id,
                        total_price=transaction.amount,
                        status='paid', 
                        payment_gateway_ref=mpesa_receipt,
                        delivery_option_id=transaction.selected_delivery_option_id,
                        delivery_fee=transaction.applied_delivery_fee or Decimal('0.00'),
                        shipping_address=shipping_addr,
                        billing_address=user.address if user and user.address else shipping_addr, # Default billing to user address or shipping
                        payment_transaction_id=transaction.id
                    )
                    db.session.add(new_order)
                    db.session.flush() 
                    current_app.logger.info(f"Transaction {transaction.id}: Order {new_order.id} flushed. Populating items.")

                    for item_data in items_to_order_snapshot:
                        artwork = db.session.query(Artwork).filter_by(id=item_data['artwork_id']).with_for_update().first()
                        if not artwork:
                            current_app.logger.error(f"Transaction {transaction.id}, Order {new_order.id}: Artwork ID {item_data['artwork_id']} not found.")
                            raise ValueError(f"Artwork ID {item_data['artwork_id']} not found.")
                        
                        item_quantity = int(item_data['quantity'])
                        if artwork.stock_quantity < item_quantity:
                            current_app.logger.error(f"Transaction {transaction.id}, Order {new_order.id}: Insufficient stock for {artwork.name} (ID: {artwork.id}).")
                            raise ValueError(f"Insufficient stock for {artwork.name}. Available: {artwork.stock_quantity}, Requested: {item_quantity}.")
                        
                        artwork.stock_quantity -= item_quantity
                        current_app.logger.info(f"Transaction {transaction.id}, Order {new_order.id}: Artwork {artwork.id} stock updated to {artwork.stock_quantity}.")
                        
                        order_item = OrderItem(
                            order_id=new_order.id,
                            artwork_id=item_data['artwork_id'],
                            quantity=item_quantity,
                            price_at_purchase=Decimal(str(item_data['price_at_purchase']))
                        )
                        db.session.add(order_item)
                    
                    current_app.logger.info(f"Transaction {transaction.id}, Order {new_order.id}: All order items added to session.")

                    if transaction.cart_id:
                        deleted_count = CartItem.query.filter_by(cart_id=transaction.cart_id).delete(synchronize_session='fetch')
                        current_app.logger.info(f"Transaction {transaction.id}: Deleted {deleted_count} items from Cart {transaction.cart_id} for Order {new_order.id}")
                    
                    transaction.status = 'successful'
                    db.session.commit()
                    current_app.logger.info(f"Order {new_order.id} created successfully and committed for Transaction {transaction.id} (CRID: {checkout_request_id}).")

                except ValueError as ve:
                    db.session.rollback()
                    current_app.logger.error(f"Transaction {transaction.id}: ValueError during order creation: {ve}")
                    try:
                        txn_to_update = db.session.merge(transaction) if transaction in db.session.dirty else PaymentTransaction.query.get(transaction.id)
                        if txn_to_update:
                           txn_to_update.status = 'failed_processing_error' 
                           txn_to_update.daraja_response_description = f"Order Creation Error: {str(ve)}"
                           db.session.commit()
                        else:
                           current_app.logger.error(f"Transaction {transaction.id}: Could not find transaction to mark as failed_processing_error after ValueError.")
                    except Exception as inner_e:
                        db.session.rollback()
                        current_app.logger.error(f"Transaction {transaction.id}: FAILED to update status to 'failed_processing_error' after ValueError. DB Error: {inner_e}")
                except Exception as e:
                    db.session.rollback()
                    current_app.logger.error(f"Transaction {transaction.id}: Unexpected Exception during order creation: {e}", exc_info=True)
                    try:
                        txn_to_update = db.session.merge(transaction) if transaction in db.session.dirty else PaymentTransaction.query.get(transaction.id)
                        if txn_to_update:
                            txn_to_update.status = 'failed_processing_error'
                            txn_to_update.daraja_response_description = f"Unexpected Order Creation Error: {str(e)}"
                            db.session.commit()
                        else:
                           current_app.logger.error(f"Transaction {transaction.id}: Could not find transaction to mark as failed_processing_error after unexpected Exception.")
                    except Exception as update_err:
                        db.session.rollback()
                        current_app.logger.error(f"Transaction {transaction.id}: Further error when trying to mark as 'failed_processing_error' after unexpected Exception: {update_err}", exc_info=True)
        else: 
            current_app.logger.warning(f"Transaction {transaction.id} (CRID: {checkout_request_id}): Payment reported as FAILED/CANCELLED by Daraja. ResultCode: {result_code_from_daraja}, Desc: {daraja_result_desc}")
            if result_code_from_daraja == "1" or result_code_from_daraja == "1032": 
                transaction.status = 'cancelled_by_user'
            elif result_code_from_daraja == "1037": 
                transaction.status = 'failed_timeout'
            else: 
                transaction.status = 'failed_daraja'
            
            try:
                db.session.commit()
                current_app.logger.info(f"Transaction {transaction.id}: Status updated to {transaction.status} and committed.")
            except Exception as e_commit:
                db.session.rollback()
                current_app.logger.error(f"Transaction {transaction.id}: DB Error committing failure status '{transaction.status}': {e_commit}")

        return {"ResultCode": 0, "ResultDesc": "Accepted"}, 200

payment_api.add_resource(DarajaCallback, '/callback')

# === ./app/resources/auth.py ===
from flask import request, jsonify, Blueprint
from flask_restful import Resource, Api
from marshmallow import ValidationError

from .. import db, bcrypt
from ..models import User
from ..schemas import user_schema

from flask_jwt_extended import create_access_token, jwt_required, get_jwt, get_jwt_identity
from .. import BLOCKLIST

auth_bp = Blueprint('auth', __name__)
auth_api = Api(auth_bp)


class UserRegistration(Resource):
    def post(self):
        """
        Handles new user registration.
        """
        json_data = request.get_json()
        if not json_data:
            return {"message": "No input data provided"}, 400

        try:
            password = json_data.get('password')
            if not password:
                 return {'message': {'password': ['Missing data for required field.']}}, 400

            user_data = user_schema.load(json_data, session=db.session, unknown='EXCLUDE')

        except ValidationError as err:
            return {"message": "Validation errors", "errors": err.messages}, 400

        if User.query.filter_by(email=user_data.email).first():
            return {"message": "User with this email already exists"}, 409

        user = user_data

        user.set_password(password)

        try:
            db.session.add(user)
            db.session.commit()
            return {
                "message": "User created successfully",
                "user": user_schema.dump(user)
            }, 201
        except Exception as e:
            db.session.rollback()
            print(f"Error during registration: {e}")
            return {"message": "An error occurred during registration."}, 500


class UserLogin(Resource):
    def post(self):
       
        json_data = request.get_json()
        if not json_data:
            return {"message": "No input data provided"}, 400

        email = json_data.get('email')
        password = json_data.get('password')

        if not email or not password:
            return {"message": "Email and password are required"}, 400

        user = User.query.filter_by(email=email).first()

        if user and user.check_password(password):
            access_token = create_access_token(identity=user.id)
            return {"message": "Login successful", "access_token": access_token}, 200
        else:
            return {"message": "Invalid credentials"}, 401


class UserLogout(Resource):
    @jwt_required()
    def post(self):
        """
        Handles user logout by blocklisting the current JWT.
        """
        jti = get_jwt()["jti"]
        BLOCKLIST.add(jti)
        return {"message": "Successfully logged out"}, 200

class UserProfile(Resource):
    @jwt_required()
    def get(self):
        """
        Gets the current logged-in user's profile.
        """
        current_user_id = get_jwt_identity()
        user = User.query.get(current_user_id)
        if not user:
            return {"message": "User not found"}, 404
        return user_schema.dump(user), 200


auth_api.add_resource(UserRegistration, '/signup')
auth_api.add_resource(UserLogin, '/login')
auth_api.add_resource(UserLogout, '/logout')
auth_api.add_resource(UserProfile, '/me')

# === ./app/resources/artwork.py ===
from flask import request, Blueprint, jsonify
from flask_restful import Resource, Api, abort
from marshmallow import ValidationError
from sqlalchemy.orm import joinedload

from .. import db
from ..models import Artwork, Artist
from ..schemas import artwork_schema, artworks_schema

artwork_bp = Blueprint('artworks', __name__)
artwork_api = Api(artwork_bp)


class ArtworkList(Resource):
    def get(self):
        """
        Fetches all artworks, including basic artist info.
        """
        artworks = Artwork.query.options(joinedload(Artwork.artist)).all()
        return artworks_schema.dump(artworks), 200

    def post(self):
        """
        Creates one OR multiple new artworks.
        Requires 'artist_id' in the input data for each artwork.
        Accepts either a single JSON object or a JSON array.
        """

        json_data = request.get_json()
        if not json_data:
            return {"message": "No input data provided"}, 400

        is_many = isinstance(json_data, list)

        try:
            if is_many:
                for item_data in json_data:
                    artist_id = item_data.get('artist_id')
                    if not artist_id or not Artist.query.get(artist_id):
                        abort(400, message=f"Invalid or missing artist_id: {artist_id}")
                new_artworks = artworks_schema.load(json_data, session=db.session)
            else:
                artist_id = json_data.get('artist_id')
                if not artist_id or not Artist.query.get(artist_id):
                    abort(400, message=f"Invalid or missing artist_id: {artist_id}")
                new_artworks = [artwork_schema.load(json_data, session=db.session)]
        except ValidationError as err:
            if 'artist_id' in err.messages:
                 return {"message": "Validation errors", "errors": err.messages}, 400
            return {"message": "Validation errors", "errors": err.messages}, 400
        except Exception as e:
             print(f"Unexpected error during schema load: {e}")
             abort(500, message="An internal error occurred during data processing.")


        if not new_artworks:
             return {"message": "No valid artwork data found after validation."}, 400

        try:
            db.session.add_all(new_artworks)
            db.session.commit()

            result = artworks_schema.dump(new_artworks) if is_many else artwork_schema.dump(new_artworks[0])
            return result, 201
        except Exception as e:
            db.session.rollback()
            print(f"Error creating artwork(s) in DB: {e}")
            if 'foreign key constraint fails' in str(e).lower() and 'artist_id' in str(e).lower():
                 abort(400, message="Invalid artist_id provided.")
            abort(500, message="An error occurred while saving the artwork(s) to the database.")


class ArtworkDetail(Resource):
    def get(self, artwork_id):
        """
        Fetches a single artwork by its UUID, including artist info.
        """
        artwork = Artwork.query.options(joinedload(Artwork.artist)).get_or_404(
            artwork_id, description=f"Artwork with ID {artwork_id} not found."
        )
        return artwork_schema.dump(artwork), 200

    def patch(self, artwork_id):
        """
        Updates an existing artwork partially.
        'artist_id' can be updated if provided.
        """

        artwork = Artwork.query.get_or_404(
            artwork_id, description=f"Artwork with ID {artwork_id} not found."
        )

        json_data = request.get_json()
        if not json_data:
            return {"message": "No input data provided"}, 400

        if 'artist_id' in json_data:
             artist_id = json_data.get('artist_id')
             if not artist_id or not Artist.query.get(artist_id):
                 abort(400, message=f"Invalid artist_id provided for update: {artist_id}")


        try:
            updated_artwork = artwork_schema.load(
                json_data,
                instance=artwork,
                partial=True,
                session=db.session
            )
        except ValidationError as err:
             if 'artist_id' in err.messages:
                 return {"message": "Validation errors", "errors": err.messages}, 400
             return {"message": "Validation errors", "errors": err.messages}, 400

        try:
            db.session.commit()
            refreshed_artwork = Artwork.query.options(joinedload(Artwork.artist)).get(artwork.id)
            return artwork_schema.dump(refreshed_artwork), 200
        except Exception as e:
            db.session.rollback()
            print(f"Error updating artwork {artwork_id}: {e}")
            if 'foreign key constraint fails' in str(e).lower() and 'artist_id' in str(e).lower():
                 abort(400, message="Invalid artist_id provided for update.")
            abort(500, message="An error occurred while updating the artwork.")

    def delete(self, artwork_id):
        """
        Deletes an artwork by its UUID.
        """

        artwork = Artwork.query.get_or_404(
             artwork_id, description=f"Artwork with ID {artwork_id} not found."
        )
        try:
            db.session.delete(artwork)
            db.session.commit()
            return '', 204
        except Exception as e:
            db.session.rollback()
            print(f"Error deleting artwork {artwork_id}: {e}")
            abort(500, message="An error occurred while deleting the artwork.")


artwork_api.add_resource(ArtworkList, '/')
artwork_api.add_resource(ArtworkDetail, '/<string:artwork_id>')

# === ./app/utils/daraja_client.py ===
import base64
import requests
from datetime import datetime
from flask import current_app, jsonify
import time

token_cache = {}

def get_daraja_access_token():
    """Fetches a new Daraja access token or returns a cached one."""
    global token_cache
    current_time = time.time()

    if token_cache and token_cache.get('expires_at', 0) > current_time:
        print("DEBUG: Using cached Daraja token")
        return token_cache['token']

    print("DEBUG: Fetching new Daraja token")
    consumer_key = current_app.config['DARAJA_CONSUMER_KEY']
    consumer_secret = current_app.config['DARAJA_CONSUMER_SECRET']
    auth_url = current_app.config['DARAJA_AUTH_URL']

    if not consumer_key or not consumer_secret:
        print("ERROR: Daraja consumer key or secret not configured.")
        return None

    try:
        response = requests.get(auth_url, auth=(consumer_key, consumer_secret))
        response.raise_for_status()
        token_data = response.json()

        expires_in = int(token_data.get('expires_in', 3599))
        token_cache = {
            'token': token_data['access_token'],
            'expires_at': current_time + expires_in - 60
        }
        print("DEBUG: Fetched and cached new Daraja token.")
        return token_data['access_token']
    except requests.exceptions.RequestException as e:
        print(f"ERROR: Failed to get Daraja access token: {e}")
        print(f"Response status: {response.status_code if 'response' in locals() else 'N/A'}")
        print(f"Response text: {response.text if 'response' in locals() else 'N/A'}")
        return None
    except KeyError:
        print(f"ERROR: 'access_token' or 'expires_in' not found in Daraja auth response: {token_data}")
        return None


def generate_daraja_password(shortcode, passkey, timestamp):
    """Generates the Base64 encoded password for Daraja API calls."""
    password_str = f"{shortcode}{passkey}{timestamp}"
    password_bytes = password_str.encode('utf-8')
    encoded_password = base64.b64encode(password_bytes).decode('utf-8')
    return encoded_password


def initiate_stk_push(phone_number, amount, order_id, description="Shoply Purchase"):
    """Initiates an STK Push request."""
    access_token = get_daraja_access_token()
    if not access_token:
        return {"error": "Failed to obtain Daraja access token"}, 500

    stk_push_url = current_app.config['DARAJA_STK_PUSH_URL']
    shortcode = current_app.config['DARAJA_SHORTCODE']
    passkey = current_app.config['DARAJA_PASSKEY']
    callback_url = current_app.config['DARAJA_CALLBACK_URL']
    transaction_type = current_app.config['DARAJA_TRANSACTION_TYPE']

    amount = int(round(float(amount)))
    if not phone_number.startswith('254') or not phone_number.isdigit() or len(phone_number) != 12:
         print(f"ERROR: Invalid phone number format: {phone_number}")
         return {"error": "Invalid phone number format. Use 254XXXXXXXXX."}, 400

    timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
    password = generate_daraja_password(shortcode, passkey, timestamp)

    headers = {
        'Authorization': f'Bearer {access_token}',
        'Content-Type': 'application/json'
    }

    payload = {
        "BusinessShortCode": shortcode,
        "Password": password,
        "Timestamp": timestamp,
        "TransactionType": transaction_type,
        "Amount": amount,
        "PartyA": phone_number,
        "PartyB": shortcode,
        "PhoneNumber": phone_number,
        "CallBackURL": callback_url,
        "AccountReference": str(order_id),
        "TransactionDesc": description
    }

    print(f"DEBUG: Initiating STK Push with payload: {payload}")

    try:
        response = requests.post(stk_push_url, json=payload, headers=headers)
        response.raise_for_status()
        response_data = response.json()
        print(f"DEBUG: STK Push Response: {response_data}")
        return response_data, 200
    except requests.exceptions.RequestException as e:
        print(f"ERROR: STK Push request failed: {e}")
        print(f"Response status: {response.status_code if 'response' in locals() else 'N/A'}")
        print(f"Response text: {response.text if 'response' in locals() else 'N/A'}")
        error_message = "Failed to initiate payment."
        try:
            error_details = response.json()
            error_message = error_details.get('errorMessage', error_message)
        except:
            pass
        return {"error": error_message}, getattr(response, 'status_code', 500)
    except Exception as e:
        print(f"ERROR: Unexpected error during STK Push: {e}")
        return {"error": "An unexpected error occurred during payment initiation."}, 500

# === ./media/artwork_images/rename.py ===
import os

def get_available_filename(base_name, extension):
    """Find the next available filename like art1.jpg, art2.jpg, etc."""
    counter = 1
    while True:
        new_name = f"{base_name}{counter}.{extension}"
        if not os.path.exists(new_name):
            return new_name
        counter += 1

def rename_images():
    images = [f for f in os.listdir('.') if f.lower().endswith('.jpg')]
    images.sort()

    for filename in images:
        new_name = get_available_filename("art", "jpg")
        os.rename(filename, new_name)
        print(f"Renamed '{filename}' to '{new_name}'")

if __name__ == "__main__":
    rename_images()
