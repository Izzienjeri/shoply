# Extracted Python Code
# Date and Time: 2025-05-26 01:05:17
# Files Included: 17

# === ./seed.py ===
import os
import random
from decimal import Decimal
from faker import Faker
from app import create_app, db
from app.models import User, Artist, Artwork, Cart, CartItem, Order, OrderItem, DeliveryOption, PaymentTransaction

NUM_ARTISTS = 10
NUM_USERS = 10
ARTWORK_IMAGE_FOLDER_RELATIVE = 'artwork_images'
IMAGES_BASE_NAME = 'art'
NUM_IMAGES = 48
DEFAULT_PASSWORD = "pass123"
ADMIN_EMAIL = "admin@artistryhaven.io"
TEST_USER_EMAIL = "testuser@artistryhaven.io"

try:
    fake = Faker()
except ImportError:
    print("Faker not installed. Using basic placeholder data. (pip install Faker)")
    fake = None

KENYAN_NAMES = [
    "Wanjiku", "Omondi", "Achieng", "Kamau", "Otieno", "Njeri", "Mwangi", "Kiplagat", "Cherono", "Nyambura"
]

KENYAN_LOCATIONS = [
    "Westlands, Nairobi", "Kisumu CBD", "Mombasa Island", "Eldoret Town", "Thika Road, Nairobi",
    "Nyali, Mombasa", "Kasarani, Nairobi", "Lang'ata, Nairobi", "Kakamega", "Machakos Town",
    "Kikuyu, Kiambu", "Ngong Road, Nairobi", "Rongai", "Meru Town", "Kitale"
]

def get_image_path(image_index):
    return f"{ARTWORK_IMAGE_FOLDER_RELATIVE}/{IMAGES_BASE_NAME}{image_index}.jpg"

def clear_data():
    print("Clearing existing data (but not users/artists/artworks/delivery options)...")
    db.session.query(OrderItem).delete()
    db.session.query(Order).delete()
    db.session.query(PaymentTransaction).delete()
    db.session.query(CartItem).delete()
    db.session.query(Cart).delete()
    db.session.commit()
    print("Data cleared.")

def seed_artists(num_artists):
    print(f"Seeding {num_artists} artists...")
    artists = []
    for _ in range(num_artists):
        first_name = fake.first_name() if fake else "John"
        kenyan_last_name = random.choice(KENYAN_NAMES)
        name = f"{first_name} {kenyan_last_name}"
        bio = fake.paragraph(nb_sentences=3) if fake else f"Bio for {name}."
        artists.append(Artist(name=name, bio=bio, is_active=True))
    db.session.add_all(artists)
    db.session.commit()
    print("Artists seeded.")
    return artists

def seed_artworks(artists, num_images_available, media_folder_base):
    if not artists:
        print("No artists available for artworks.")
        return

    print(f"Seeding artworks from {num_images_available} images...")
    artworks = []
    image_folder_full_path = os.path.join(media_folder_base, ARTWORK_IMAGE_FOLDER_RELATIVE)

    for i in range(1, num_images_available + 1):
        image_filename = f"{IMAGES_BASE_NAME}{i}.jpg"
        image_full_path = os.path.join(image_folder_full_path, image_filename)
        if not os.path.exists(image_full_path):
            print(f"Missing image: {image_full_path}, skipping.")
            continue

        artwork = Artwork(
            name=fake.catch_phrase() if fake else f"Artwork {i}",
            description=fake.text(max_nb_chars=200) if fake else f"Description for artwork {i}.",
            price=Decimal(random.randint(500, 15000)),
            stock_quantity=random.randint(0, 10),
            artist_id=random.choice(artists).id,
            image_url=get_image_path(i),
            is_active=True
        )
        artworks.append(artwork)

    if artworks:
        db.session.add_all(artworks)
        db.session.commit()
        print(f"{len(artworks)} artworks seeded.")
    else:
        print("No artworks seeded.")

def seed_users():
    print(f"Seeding 10 users (including 1 admin, 1 test user)...")
    users = []

    # Admin
    if not User.query.filter_by(email=ADMIN_EMAIL).first():
        admin = User(email=ADMIN_EMAIL, name="Admin User", address="Artistry Haven HQ", is_admin=True)
        admin.set_password(DEFAULT_PASSWORD)
        users.append(admin)
        print(f"Admin created: {ADMIN_EMAIL}")
    else:
        print("Admin already exists.")

    # Test User
    if not User.query.filter_by(email=TEST_USER_EMAIL).first():
        test_user = User(email=TEST_USER_EMAIL, name="Test User", address="Nairobi", is_admin=False)
        test_user.set_password(DEFAULT_PASSWORD)
        users.append(test_user)
        print(f"Test user created: {TEST_USER_EMAIL}")
    else:
        print("Test user already exists.")

    # 8 other users
    for i in range(8):
        email = fake.unique.email() if fake else f"user{i+1}@example.com"
        if User.query.filter_by(email=email).first():
            continue
        user = User(
            email=email,
            name=fake.name() if fake else f"User {i+1}",
            address=random.choice(KENYAN_LOCATIONS),
            is_admin=False
        )
        user.set_password(DEFAULT_PASSWORD)
        users.append(user)

    if users:
        db.session.add_all(users)
        db.session.commit()
        print(f"{len(users)} users seeded. All passwords: '{DEFAULT_PASSWORD}'")
    else:
        print("No new users added.")

def seed_delivery_options():
    print("Seeding delivery options...")
    options_data = [
        {"name": "In Store Pick Up", "price": "0.00", "is_pickup": True, "active": True, "sort_order": 0},
        {"name": "Nairobi CBD", "price": "200.00", "is_pickup": False, "active": True, "sort_order": 10},
        {"name": "Zone 1 (Upper-Hill)", "price": "300.00", "is_pickup": False, "active": True, "sort_order": 20},
    ]

    new_options = []
    for opt in options_data:
        if not DeliveryOption.query.filter_by(name=opt["name"]).first():
            new_options.append(DeliveryOption(
                name=opt["name"],
                price=Decimal(opt["price"]),
                is_pickup=opt["is_pickup"],
                active=opt["active"],
                sort_order=opt["sort_order"],
                description=opt.get("description", "")
            ))

    if new_options:
        db.session.add_all(new_options)
        db.session.commit()
        print(f"{len(new_options)} delivery options seeded.")
    else:
        print("Delivery options already exist.")

def run_seed():
    app = create_app()
    with app.app_context():
        media_folder = app.config.get('MEDIA_FOLDER')
        if not media_folder or not os.path.isdir(media_folder):
            print(f"ERROR: MEDIA_FOLDER '{media_folder}' is missing or invalid.")
            return

        clear_data()
        seed_delivery_options()
        artists = seed_artists(NUM_ARTISTS)
        seed_artworks(artists, NUM_IMAGES, media_folder)
        seed_users()
        print("-" * 20)
        print("Seeding complete.")
        print("-" * 20)

if __name__ == '__main__':
    run_seed()

# === ./run.py ===
from app import create_app
from seed import run_seed

app = create_app()

@app.cli.command("seed")
def seed_db():
    """Populates the database with initial data."""
    run_seed()

if __name__ =='__main__':
    app.run(debug=True)

# === ./app/schemas.py ===
from marshmallow import fields, validate, post_dump, exceptions as marshmallow_exceptions, missing as marshmallow_missing_value
from flask import url_for, current_app
from decimal import Decimal, InvalidOperation

from . import ma, db
from .models import User, Artist, Artwork, Cart, CartItem, Order, OrderItem, DeliveryOption


class UserSchema(ma.SQLAlchemyAutoSchema):
    password = fields.Str(required=True, load_only=True, validate=validate.Length(min=8))
    email = fields.Email(required=True)
    name = fields.Str()
    address = fields.Str()
    is_admin = fields.Bool(dump_only=True)

    class Meta:
        model = User
        load_instance = True
        exclude = ('password_hash',)
        sqla_session = db.session

class ArtworkSchema(ma.SQLAlchemyAutoSchema):
    price = fields.Decimal(as_string=True, required=True, validate=validate.Range(min=0))
    stock_quantity = fields.Int(validate=validate.Range(min=0))
    image_url = fields.String(required=False, allow_none=True)
    artist = fields.Nested("ArtistSchema", only=('id', 'name', 'is_active'), dump_only=True)
    artist_id = fields.Str(required=True, load_only=True)
    is_active = fields.Bool(load_default=True)

    class Meta:
        model = Artwork
        load_instance = True
        sqla_session = db.session
        include_fk = True

    @post_dump
    def make_image_url_absolute(self, data, **kwargs):
        relative_path = data.get('image_url')
        if relative_path:
            try:
                _app = current_app._get_current_object() if not current_app else current_app
                if _app:
                    absolute_url = url_for('serve_media', filename=relative_path, _external=True)
                    data['image_url'] = absolute_url
                else:
                    data['image_url'] = relative_path
            except RuntimeError:
                data['image_url'] = relative_path
            except Exception:
                data['image_url'] = relative_path
        else:
            data['image_url'] = None
        return data

class ArtistSchema(ma.SQLAlchemyAutoSchema):
    name = fields.Str(required=True)
    bio = fields.Str()
    artworks = fields.Nested(ArtworkSchema, many=True, dump_only=True, attribute="artworks", exclude=("artist",))
    artworks_count = fields.Method("get_artworks_count", dump_only=True)
    is_active = fields.Bool(load_default=True)

    def get_artworks_count(self, obj):
        if hasattr(obj, '_artworks_count_val'):
            return obj._artworks_count_val
        if hasattr(obj, 'artworks_for_display'):
            return len(obj.artworks_for_display)
        return len(obj.artworks) if obj.artworks else 0


    class Meta:
        model = Artist
        load_instance = True
        sqla_session = db.session
        include_relationships = True


class CartItemSchema(ma.SQLAlchemyAutoSchema):
    artwork = fields.Nested(
        ArtworkSchema,
        only=('id', 'name', 'price', 'image_url', 'artist', 'stock_quantity', 'is_active')
    )
    quantity = fields.Int(required=True, validate=validate.Range(min=1))

    class Meta:
        model = CartItem
        load_instance = True
        sqla_session = db.session
        exclude = ('cart_id',)

class CartSchema(ma.SQLAlchemyAutoSchema):
    items = fields.Nested(CartItemSchema, many=True)
    total_price = fields.Method("calculate_total", dump_only=True)

    def calculate_total(self, cart):
        total = Decimal('0.00')
        items_iterable = []
        if hasattr(cart, 'items'):
            try:
                items_iterable = cart.items
            except Exception as e:
                current_app.logger.error(f"Could not iterate cart items for cart {getattr(cart, 'id', 'N/A')}: {e}", exc_info=True)
                items_iterable = []

        for item in items_iterable:
            if (item.artwork and item.artwork.is_active and
                item.artwork.artist and item.artwork.artist.is_active and
                hasattr(item.artwork, 'price') and item.artwork.price is not None and
                hasattr(item, 'quantity')):
                try:
                    item_price = Decimal(item.artwork.price)
                    total += item_price * Decimal(item.quantity)
                except (TypeError, ValueError, InvalidOperation) as e:
                    current_app.logger.error(f"Could not calculate price for item {getattr(item, 'id', 'N/A')}, artwork {getattr(item.artwork, 'id', 'N/A')}. Price: '{item.artwork.price}', Qty: {item.quantity}. Error: {e}", exc_info=True)
                    continue
            elif item.artwork and (not item.artwork.is_active or (item.artwork.artist and not item.artwork.artist.is_active)):
                 current_app.logger.info(f"Skipping inactive artwork '{item.artwork.name}' or artwork by inactive artist from cart total calculation.")
            else:
                current_app.logger.warning(f"Artwork data (price/quantity/active status/artist status) missing or incomplete for cart item {getattr(item, 'id', 'N/A')} in cart {getattr(cart, 'id', 'N/A')}. Cannot calculate total accurately.")
        return str(total)

    class Meta:
        model = Cart
        load_instance = True
        sqla_session = db.session

class OrderItemSchema(ma.SQLAlchemyAutoSchema):
    artwork = fields.Nested(ArtworkSchema, only=('id', 'name', 'image_url', 'artist', 'is_active'))
    price_at_purchase = fields.Decimal(as_string=True, dump_only=True)
    quantity = fields.Int(dump_only=True)

    class Meta:
        model = OrderItem
        load_instance = True
        sqla_session = db.session
        exclude = ('order_id',)

class DeliveryOptionSchema(ma.SQLAlchemyAutoSchema):
    price = fields.Decimal(as_string=True, required=True)
    name = fields.Str(required=True)
    description = fields.Str(allow_none=True)
    is_pickup = fields.Bool(required=True)
    id = fields.Str(dump_only=True)
    active = fields.Bool(load_default=True)
    sort_order = fields.Int(load_default=0)

    class Meta:
        model = DeliveryOption
        load_instance = True
        sqla_session = db.session

class OrderSchema(ma.SQLAlchemyAutoSchema):
    items = fields.Nested(OrderItemSchema, many=True, dump_only=True)
    total_price = fields.Decimal(as_string=True, dump_only=True)
    status = fields.Str(dump_only=True)
    user_id = fields.String(dump_only=True)
    user = fields.Nested(UserSchema, only=('id', 'email', 'name'), dump_only=True)
    created_at = fields.DateTime(dump_only=True)
    updated_at = fields.DateTime(dump_only=True)
    shipped_at = fields.DateTime(dump_only=True, allow_none=True)
    shipping_address = fields.Str(dump_only=True, allow_none=True)
    billing_address = fields.Str(dump_only=True, allow_none=True)
    payment_gateway_ref = fields.Str(dump_only=True, allow_none=True)
    delivery_fee = fields.Decimal(as_string=True, dump_only=True)
    delivery_option_details = fields.Nested(DeliveryOptionSchema, dump_only=True, only=("id", "name", "price", "is_pickup", "description"))
    picked_up_by_name = fields.Str(allow_none=True)
    picked_up_by_id_no = fields.Str(allow_none=True)
    picked_up_at = fields.DateTime(allow_none=True)

    class Meta:
        model = Order
        load_instance = True
        sqla_session = db.session


user_schema = UserSchema()
cart_schema = CartSchema()
order_schema = OrderSchema()
delivery_option_schema_public = DeliveryOptionSchema(exclude=('created_at', 'updated_at', 'active', 'sort_order'))
artist_schema = ArtistSchema()
artwork_schema = ArtworkSchema()


users_schema = UserSchema(many=True)
artists_schema = ArtistSchema(many=True)
artworks_schema = ArtworkSchema(many=True)
orders_schema = OrderSchema(many=True)
delivery_options_schema_public = DeliveryOptionSchema(many=True, exclude=('created_at', 'updated_at'))


admin_artist_schema = ArtistSchema()
admin_artwork_schema = ArtworkSchema()
delivery_option_schema_admin = DeliveryOptionSchema()
delivery_options_schema_admin = DeliveryOptionSchema(many=True)

# === ./app/models.py ===
import uuid
from datetime import datetime
from sqlalchemy.dialects.mysql import DECIMAL
import json
from flask import current_app

from . import db, bcrypt



def generate_uuid():
    return str(uuid.uuid4())

class Artist(db.Model):
    __tablename__ = 'artists'

    id = db.Column(db.String(36), primary_key=True, default=generate_uuid)
    name = db.Column(db.String(150), nullable=False)
    bio = db.Column(db.Text, nullable=True)
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)
    is_active = db.Column(db.Boolean, default=True, nullable=False)

    artworks = db.relationship('Artwork', back_populates='artist', cascade="all, delete-orphan")

    def __repr__(self):
        return f"<Artist {self.name}>"

class User(db.Model):
    __tablename__ = 'users'

    id = db.Column(db.String(36), primary_key=True, default=generate_uuid)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.String(128), nullable=False)
    name = db.Column(db.String(100), nullable=True)
    address = db.Column(db.Text, nullable=True)
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    is_admin = db.Column(db.Boolean, default=False, nullable=False)

    cart = db.relationship('Cart', back_populates='user', uselist=False, cascade="all, delete-orphan")
    orders = db.relationship('Order', back_populates='user', lazy='dynamic', cascade="all, delete-orphan")
    payment_transactions = db.relationship('PaymentTransaction', back_populates='user', lazy='dynamic')


    def set_password(self, password):
        self.password_hash = bcrypt.generate_password_hash(password).decode('utf-8')

    def check_password(self, password):
        return bcrypt.check_password_hash(self.password_hash, password)

    def __repr__(self):
        return f"<User {self.email}>"

class Artwork(db.Model):
    __tablename__ = 'artworks'

    id = db.Column(db.String(36), primary_key=True, default=generate_uuid)
    name = db.Column(db.String(255), nullable=False)
    description = db.Column(db.Text, nullable=True)
    price = db.Column(DECIMAL(precision=10, scale=2), nullable=False)
    stock_quantity = db.Column(db.Integer, nullable=False, default=1)
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)
    image_url = db.Column(db.String(255), nullable=True)
    is_active = db.Column(db.Boolean, default=True, nullable=False)

    artist_id = db.Column(db.String(36), db.ForeignKey('artists.id'), nullable=False)

    artist = db.relationship('Artist', back_populates='artworks')
    cart_items = db.relationship('CartItem', back_populates='artwork', lazy='dynamic')
    order_items = db.relationship('OrderItem', back_populates='artwork', lazy='dynamic')

    def __repr__(self):
        return f"<Artwork {self.name} by Artist {self.artist_id}>"

class Cart(db.Model):
    __tablename__ = 'carts'

    id = db.Column(db.String(36), primary_key=True, default=generate_uuid)
    user_id = db.Column(db.String(36), db.ForeignKey('users.id'), unique=True, nullable=False)
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)

    user = db.relationship('User', back_populates='cart')
    items = db.relationship('CartItem', back_populates='cart', cascade="all, delete-orphan", lazy='joined')

    def __repr__(self):
        return f"<Cart {self.id} for User {self.user_id}>"

class CartItem(db.Model):
    __tablename__ = 'cart_items'

    id = db.Column(db.String(36), primary_key=True, default=generate_uuid)
    cart_id = db.Column(db.String(36), db.ForeignKey('carts.id'), nullable=False)
    artwork_id = db.Column(db.String(36), db.ForeignKey('artworks.id'), nullable=False)
    quantity = db.Column(db.Integer, nullable=False, default=1)

    __table_args__ = (db.UniqueConstraint('cart_id', 'artwork_id', name='_cart_artwork_uc'),)

    cart = db.relationship('Cart', back_populates='items')
    artwork = db.relationship('Artwork', back_populates='cart_items', lazy='joined')

    def __repr__(self):
        return f"<CartItem Artwork {self.artwork_id} Qty {self.quantity} in Cart {self.cart_id}>"

class DeliveryOption(db.Model):
    __tablename__ = 'delivery_options'

    id = db.Column(db.String(36), primary_key=True, default=generate_uuid)
    name = db.Column(db.String(255), nullable=False, unique=True)
    price = db.Column(DECIMAL(precision=10, scale=2), nullable=False, default=0.00)
    description = db.Column(db.Text, nullable=True)
    is_pickup = db.Column(db.Boolean, default=False, nullable=False)
    active = db.Column(db.Boolean, default=True, nullable=False)
    sort_order = db.Column(db.Integer, default=0, nullable=False)
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)

    def __repr__(self):
        return f"<DeliveryOption {self.name} Price: {self.price}>"

class Order(db.Model):
    __tablename__ = 'orders'

    id = db.Column(db.String(36), primary_key=True, default=generate_uuid)
    user_id = db.Column(db.String(36), db.ForeignKey('users.id'), nullable=False)
    total_price = db.Column(DECIMAL(precision=10, scale=2), nullable=False)
    status = db.Column(db.String(50), nullable=False, default='pending')
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)
    shipped_at = db.Column(db.DateTime, nullable=True)
    shipping_address = db.Column(db.Text, nullable=True)
    billing_address = db.Column(db.Text, nullable=True)
    payment_gateway_ref = db.Column(db.String(255), nullable=True)

    delivery_option_id = db.Column(db.String(36), db.ForeignKey('delivery_options.id'), nullable=True)
    delivery_fee = db.Column(DECIMAL(precision=10, scale=2), nullable=False, default=0.00)

    picked_up_by_name = db.Column(db.String(150), nullable=True)
    picked_up_by_id_no = db.Column(db.String(50), nullable=True)
    picked_up_at = db.Column(db.DateTime, nullable=True)


    user = db.relationship('User', back_populates='orders')
    items = db.relationship('OrderItem', back_populates='order', cascade="all, delete-orphan", lazy='joined')
    
    payment_transaction_id = db.Column(db.String(36), db.ForeignKey('payment_transactions.id'), nullable=True, index=True)
    payment_transaction = db.relationship('PaymentTransaction', backref=db.backref('order_record', uselist=False))
    
    delivery_option_details = db.relationship('DeliveryOption', lazy='joined')

    def __repr__(self):
        return f"<Order {self.id} Status {self.status} User {self.user_id} Total {self.total_price}>"

class OrderItem(db.Model):
    __tablename__ = 'order_items'

    id = db.Column(db.String(36), primary_key=True, default=generate_uuid)
    order_id = db.Column(db.String(36), db.ForeignKey('orders.id'), nullable=False)
    artwork_id = db.Column(db.String(36), db.ForeignKey('artworks.id'), nullable=False)
    quantity = db.Column(db.Integer, nullable=False)
    price_at_purchase = db.Column(DECIMAL(precision=10, scale=2), nullable=False)

    order = db.relationship('Order', back_populates='items')
    artwork = db.relationship('Artwork', back_populates='order_items', lazy='joined')

    def __repr__(self):
        return f"<OrderItem Artwork {self.artwork_id} Qty {self.quantity} Price {self.price_at_purchase} in Order {self.order_id}>"

class PaymentTransaction(db.Model):
    __tablename__ = 'payment_transactions'

    id = db.Column(db.String(36), primary_key=True, default=generate_uuid)
    checkout_request_id = db.Column(db.String(100), unique=True, nullable=True, index=True)
    user_id = db.Column(db.String(36), db.ForeignKey('users.id'), nullable=False)
    cart_id = db.Column(db.String(36), db.ForeignKey('carts.id'), nullable=True) 
    amount = db.Column(DECIMAL(precision=10, scale=2), nullable=False)
    phone_number = db.Column(db.String(15), nullable=True)
    status = db.Column(db.String(50), nullable=False, default='initiated') 
    daraja_response_description = db.Column(db.Text, nullable=True)
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)

    _cart_items_snapshot = db.Column(db.Text, nullable=True)

    selected_delivery_option_id = db.Column(db.String(36), db.ForeignKey('delivery_options.id'), nullable=True)
    applied_delivery_fee = db.Column(DECIMAL(precision=10, scale=2), nullable=True)

    user = db.relationship('User', back_populates='payment_transactions')


    @property
    def cart_items_snapshot(self):
        if self._cart_items_snapshot:
            try:
                return json.loads(self._cart_items_snapshot)
            except json.JSONDecodeError:
                current_app.logger.error(f"Failed to decode cart_items_snapshot for PaymentTransaction {self.id}")
                return None
        return None

    @cart_items_snapshot.setter
    def cart_items_snapshot(self, value):
        if value:
            self._cart_items_snapshot = json.dumps(value)
        else:
            self._cart_items_snapshot = None
            
    def __repr__(self):
        return f"<PaymentTransaction {self.id} CRID: {self.checkout_request_id} Status: {self.status} Amount: {self.amount}>"

# === ./app/config.py ===
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    SECRET_KEY = os.getenv('SECRET_KEY')
    JWT_SECRET_KEY = os.getenv('JWT_SECRET_KEY')
    SQLALCHEMY_TRACK_MODIFICATIONS = False

    DATABASE_USER = os.getenv('DATABASE_USER')
    DATABASE_PASSWORD = os.getenv('DATABASE_PASSWORD')
    DATABASE_HOST = os.getenv('DATABASE_HOST')
    DATABASE_PORT = os.getenv('DATABASE_PORT')
    DATABASE_NAME = os.getenv('DATABASE_NAME')
    SQLALCHEMY_DATABASE_URI = (
        f"mysql+pymysql://{DATABASE_USER}:{DATABASE_PASSWORD}@{DATABASE_HOST}:{DATABASE_PORT}/{DATABASE_NAME}"
    )

    JWT_BLACKLIST_ENABLED = True
    JWT_BLACKLIST_TOKEN_CHECKS = ['access']

    DARAJA_ENVIRONMENT = os.getenv('DARAJA_ENVIRONMENT', 'sandbox')
    DARAJA_CONSUMER_KEY = os.getenv('DARAJA_CONSUMER_KEY')
    DARAJA_CONSUMER_SECRET = os.getenv('DARAJA_CONSUMER_SECRET')
    DARAJA_SHORTCODE = os.getenv('DARAJA_SHORTCODE')
    DARAJA_PASSKEY = os.getenv('DARAJA_PASSKEY')
    DARAJA_TRANSACTION_TYPE = os.getenv('DARAJA_TRANSACTION_TYPE', 'CustomerPayBillOnline')
    DARAJA_CALLBACK_URL_BASE = os.getenv('DARAJA_CALLBACK_URL_BASE')

    if DARAJA_ENVIRONMENT == 'production':
        DARAJA_AUTH_URL = 'https://api.safaricom.co.ke/oauth/v1/generate?grant_type=client_credentials'
        DARAJA_STK_PUSH_URL = 'https://api.safaricom.co.ke/mpesa/stkpush/v1/processrequest'
    else:
        DARAJA_AUTH_URL = 'https://sandbox.safaricom.co.ke/oauth/v1/generate?grant_type=client_credentials'
        DARAJA_STK_PUSH_URL = 'https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest'

    DARAJA_CALLBACK_URL = f"{DARAJA_CALLBACK_URL_BASE.rstrip('/')}/api/payments/callback"


    if not all([DARAJA_CONSUMER_KEY, DARAJA_CONSUMER_SECRET, DARAJA_SHORTCODE, DARAJA_PASSKEY, DARAJA_CALLBACK_URL_BASE]):
        print("WARNING: Essential Daraja configuration missing in environment variables!")

    APP_ROOT = os.path.dirname(os.path.abspath(__file__))
    MEDIA_FOLDER = os.path.join(APP_ROOT, '..', 'media')
    UPLOAD_FOLDER = os.path.join(MEDIA_FOLDER, 'artwork_images')
    ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}

# === ./app/decorators.py ===
from functools import wraps
from flask_jwt_extended import verify_jwt_in_request, get_jwt_identity
from flask_jwt_extended.exceptions import JWTExtendedException
from flask import current_app
from flask_restful import abort

from .models import User

def admin_required(fn):
    """
    A decorator to protect routes that require admin privileges.
    Uses flask_restful.abort for proper error handling with Flask-RESTful.
    """
    @wraps(fn)
    def wrapper(*args, **kwargs):
        try:
            verify_jwt_in_request()
        except JWTExtendedException as e:
            current_app.logger.warning(f"JWT verification failed in admin_required: {e}")
            abort(401, message=getattr(e, 'description', str(e)) or "Unauthorized: JWT verification failed.")
        
        user_id = get_jwt_identity()
        user = User.query.get(user_id)

        if not user:
            current_app.logger.warning(f"Admin access denied: User ID {user_id} not found in database.")
            abort(403, message="Admin access denied. User not found.")
        
        if not user.is_admin:
            current_app.logger.warning(f"Admin access denied: User {user.email} (ID: {user_id}) is not an admin.")
            abort(403, message="Administrator access required.")
        
        try:
            return fn(*args, **kwargs)
        except Exception as e:
            if hasattr(e, 'data') and 'message' in e.data and hasattr(e, 'code') and e.code >= 400:
                current_app.logger.warning(f"Route function {fn.__name__} aborted with status {e.code}: {e.data['message']}")
                raise
            
            current_app.logger.error(f"Error in protected route {fn.__name__}: {e}", exc_info=True)
            abort(500, message="An internal server error occurred in the requested operation.")
            
    return wrapper

# === ./app/__init__.py ===
import os
from flask import Flask, jsonify, send_from_directory, abort, current_app
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from flask_jwt_extended import JWTManager
from flask_bcrypt import Bcrypt
from flask_marshmallow import Marshmallow
from flask_cors import CORS
from .config import Config

db = SQLAlchemy()
migrate = Migrate()
jwt = JWTManager()
bcrypt = Bcrypt()
ma = Marshmallow()

BLOCKLIST = set()

@jwt.token_in_blocklist_loader
def check_if_token_in_blocklist(jwt_header, jwt_payload):
    jti = jwt_payload["jti"]
    return jti in BLOCKLIST

@jwt.unauthorized_loader
def missing_token_callback(error):
    return jsonify({"description": "Request does not contain an access token.", "error": "authorization_required"}), 401

def create_app(config_class=Config):
    app = Flask(__name__)
    app.config.from_object(config_class)

    db.init_app(app)
    migrate.init_app(app, db)
    jwt.init_app(app)
    bcrypt.init_app(app)
    ma.init_app(app)
    
    CORS(app, resources={r"/api/*": {"origins": "*"}}, supports_credentials=True)


    from . import models

    @app.route('/media/<path:filename>')
    def serve_media(filename):
        media_folder = current_app.config.get('MEDIA_FOLDER')
        if not media_folder:
            current_app.logger.error("ERROR: MEDIA_FOLDER not configured in Flask app.")
            abort(500)
        try:
            return send_from_directory(media_folder, filename)
        except FileNotFoundError:
            current_app.logger.warning(f"Media file not found: {filename}")
            abort(404)
        except Exception as e:
            current_app.logger.error(f"Unexpected error serving file {filename}: {e}", exc_info=True)
            abort(500)

    from .resources.auth import auth_bp
    from .resources.artwork import artwork_bp
    from .resources.artist import artist_bp
    from .resources.cart import cart_bp
    from .resources.order import order_bp
    from .resources.payment import payment_bp
    from .resources.delivery import delivery_bp
    from .resources.admin_dashboard import admin_dashboard_bp 

    app.register_blueprint(auth_bp, url_prefix='/api/auth')
    app.register_blueprint(artwork_bp, url_prefix='/api/artworks')
    app.register_blueprint(artist_bp, url_prefix='/api/artists')
    app.register_blueprint(cart_bp, url_prefix='/api/cart')
    app.register_blueprint(order_bp, url_prefix='/api/orders')
    app.register_blueprint(payment_bp, url_prefix='/api/payments')
    app.register_blueprint(delivery_bp, url_prefix='/api/delivery')
    app.register_blueprint(admin_dashboard_bp, url_prefix='/api/admin/dashboard')


    @app.route('/')
    def index():
        return "Artistry Haven Backend is running!"

    return app

# === ./app/resources/cart.py ===
from flask import request, Blueprint, jsonify
from flask_restful import Resource, Api, abort
from marshmallow import ValidationError, fields
from sqlalchemy.orm import joinedload

from .. import db, ma
from ..models import Cart, CartItem, Artwork, User
from ..schemas import cart_schema

from flask_jwt_extended import jwt_required, get_jwt_identity

cart_bp = Blueprint('cart', __name__)
cart_api = Api(cart_bp)

def get_or_create_cart(user_id):
    """Finds the user's cart or creates one if it doesn't exist."""
    user = User.query.get(user_id)
    if not user:
        abort(404, message="User not found.")

    cart = Cart.query.options(
        joinedload(Cart.items).options(
            joinedload(CartItem.artwork).joinedload(Artwork.artist)
        )
    ).filter_by(user_id=user_id).first()

    if not cart:
        cart = Cart(user_id=user_id)
        db.session.add(cart)
        try:
            db.session.commit()
        except Exception as e:
            db.session.rollback()
            print(f"Error creating new cart: {e}")
            abort(500, message="Could not create cart.")
        cart = Cart.query.options(
            joinedload(Cart.items).options(
                joinedload(CartItem.artwork).joinedload(Artwork.artist)
            )
        ).filter_by(user_id=user_id).first()

    return cart

class AddToCartSchema(ma.Schema):
    artwork_id = fields.Str(required=True)
    quantity = fields.Int(required=True, validate=lambda q: q > 0)

add_to_cart_schema = AddToCartSchema()


class CartResource(Resource):
    @jwt_required()
    def get(self):
        """
        Fetches the current user's cart contents, including artwork and artist details.
        """
        user_id = get_jwt_identity()
        cart = get_or_create_cart(user_id)

        return cart_schema.dump(cart), 200

    @jwt_required()
    def post(self):
        """
        Adds an artwork to the current user's cart or updates its quantity.
        """
        user_id = get_jwt_identity()
        json_data = request.get_json()
        if not json_data:
            abort(400, message="No input data provided")

        try:
            data = add_to_cart_schema.load(json_data)
        except ValidationError as err:
            abort(400, message=err.messages)

        artwork_id = data['artwork_id']
        quantity_to_add = data['quantity']

        cart = get_or_create_cart(user_id)
        if cart.id is None:
            abort(500, message="Failed to retrieve or initialize cart.")

        artwork = Artwork.query.get(artwork_id)

        if not artwork:
            abort(404, message=f"Artwork with ID {artwork_id} not found.")

        if artwork.stock_quantity < quantity_to_add:
             abort(400, message=f"Insufficient stock for Artwork ID {artwork_id}. Available: {artwork.stock_quantity}")

        cart_item = next((item for item in cart.items if item.artwork_id == artwork_id), None)
        if cart_item is None:
             cart_item = CartItem.query.filter_by(cart_id=cart.id, artwork_id=artwork_id).first()


        if cart_item:
            new_quantity = cart_item.quantity + quantity_to_add
            if artwork.stock_quantity < new_quantity:
                 abort(400, message=f"Insufficient stock to increase quantity for Artwork ID {artwork_id}. Available: {artwork.stock_quantity}, In Cart: {cart_item.quantity}")
            cart_item.quantity = new_quantity
        else:
            cart_item = CartItem(cart_id=cart.id, artwork_id=artwork_id, quantity=quantity_to_add)
            db.session.add(cart_item)

        try:
            db.session.commit()
            cart_updated = Cart.query.options(
                 joinedload(Cart.items).options(
                     joinedload(CartItem.artwork).joinedload(Artwork.artist)
                 )
            ).get(cart.id)
            return cart_schema.dump(cart_updated), 200
        except Exception as e:
            db.session.rollback()
            print(f"Error committing cart changes: {e}")
            if "UniqueViolation" in str(e) or "_cart_artwork_uc" in str(e):
                 abort(409, message="Item already exists in cart or concurrent modification error.")
            abort(500, message="An error occurred while updating the cart.")


class CartItemResource(Resource):

    @jwt_required()
    def put(self, item_id):
        """
        Updates the quantity of a specific item in the cart.
        """
        user_id = get_jwt_identity()
        cart = get_or_create_cart(user_id)

        json_data = request.get_json()
        if not json_data or 'quantity' not in json_data:
             abort(400, message="Quantity is required.")

        try:
            new_quantity = int(json_data['quantity'])
            if new_quantity <= 0:
                abort(400, message="Quantity must be positive. Use DELETE to remove item.")
        except ValueError:
            abort(400, message="Quantity must be an integer.")

        cart_item = CartItem.query.filter_by(id=item_id, cart_id=cart.id).first()
        if not cart_item:
            abort(404, message=f"Cart item with ID {item_id} not found in your cart.")

        artwork = Artwork.query.get(cart_item.artwork_id)
        if not artwork:
             abort(404, message=f"Artwork associated with cart item not found.")

        if artwork.stock_quantity < new_quantity:
            abort(400, message=f"Insufficient stock for Artwork ID {artwork.id}. Available: {artwork.stock_quantity}")

        cart_item.quantity = new_quantity

        try:
            db.session.commit()
            cart_updated = Cart.query.options(
                 joinedload(Cart.items).options(
                     joinedload(CartItem.artwork).joinedload(Artwork.artist)
                 )
            ).get(cart.id)
            return cart_schema.dump(cart_updated), 200
        except Exception as e:
            db.session.rollback()
            print(f"Error updating cart item: {e}")
            abort(500, message="An error occurred while updating the cart item.")


    @jwt_required()
    def delete(self, item_id):
        """
        Removes a specific item from the cart.
        """
        user_id = get_jwt_identity()
        cart = get_or_create_cart(user_id)

        cart_item = CartItem.query.filter_by(id=item_id, cart_id=cart.id).first()
        if not cart_item:
            abort(404, message=f"Cart item with ID {item_id} not found in your cart.")

        try:
            db.session.delete(cart_item)
            db.session.commit()
            cart_updated = Cart.query.options(
                 joinedload(Cart.items).options(
                     joinedload(CartItem.artwork).joinedload(Artwork.artist)
                 )
            ).get(cart.id)
            return cart_schema.dump(cart_updated), 200
        except Exception as e:
            db.session.rollback()
            print(f"Error deleting cart item: {e}")
            abort(500, message="An error occurred while removing the item from the cart.")


cart_api.add_resource(CartResource, '/', '')
cart_api.add_resource(CartItemResource, '/items/<string:item_id>')

# === ./app/resources/artist.py ===
from flask import request, Blueprint, jsonify, current_app
from flask_restful import Resource, Api, abort
from marshmallow import ValidationError
from sqlalchemy.orm import joinedload, selectinload
from flask_jwt_extended import jwt_required, get_jwt_identity, get_jwt

from .. import db
from ..models import Artist, Artwork, User
from ..schemas import artist_schema, artists_schema, ArtworkSchema
from ..decorators import admin_required

artist_bp = Blueprint('artists', __name__)
artist_api = Api(artist_bp)

class ArtistList(Resource):
    def get(self):
        is_admin_request = False
        try:
            jwt_payload = get_jwt()
            if jwt_payload:
                user_id_from_token = get_jwt_identity()
                user = User.query.get(user_id_from_token)
                if user and user.is_admin:
                    is_admin_request = True
        except Exception:
            pass

        if is_admin_request:
            current_app.logger.info("Admin request: Fetching all artists with artwork counts for ArtistList.")
            artists = Artist.query.options(selectinload(Artist.artworks)).order_by(Artist.name).all()
            for artist in artists:
                 artist._artworks_count_val = len(artist.artworks)
        else:
            artists = Artist.query.filter_by(is_active=True).order_by(Artist.name).all()

        return artists_schema.dump(artists), 200

    @admin_required
    def post(self):
        json_data = request.get_json()
        if not json_data:
            return {"message": "No input data provided"}, 400

        try:
            json_data.setdefault('is_active', True)
            new_artist = artist_schema.load(json_data, session=db.session)
        except ValidationError as err:
            return {"message": "Validation errors", "errors": err.messages}, 400
        except Exception as e:
            current_app.logger.error(f"Unexpected error during artist schema load: {e}", exc_info=True)
            abort(500, message="An internal error occurred during data processing.")

        try:
            db.session.add(new_artist)
            db.session.commit()
            return artist_schema.dump(new_artist), 201
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error creating artist in DB: {e}", exc_info=True)
            abort(500, message="An error occurred while saving the artist.")

class ArtistDetail(Resource):
    def get(self, artist_id):
        is_admin_request = False
        try:
            jwt_payload = get_jwt()
            if jwt_payload:
                user_id_from_token = get_jwt_identity()
                user = User.query.get(user_id_from_token)
                if user and user.is_admin:
                    is_admin_request = True
        except Exception:
            pass

        query = Artist.query.options(
            selectinload(Artist.artworks)
        )
        
        artist = query.get(artist_id)

        if not artist:
            return {"message": f"Artist with ID {artist_id} not found."}, 404
        
        if not is_admin_request and not artist.is_active:
             return {"message": f"Artist with ID {artist_id} not found or not active."}, 404

        if is_admin_request:
            artist_dump_data = artist_schema.dump(artist)
        else:
            active_artworks = [aw for aw in artist.artworks if aw.is_active]
            artist.artworks_for_display = active_artworks

            artist_dump_data = artist_schema.dump(artist)

            artist_dump_data['artworks'] = ArtworkSchema(many=True, exclude=("artist",)).dump(active_artworks)
            artist_dump_data['artworks_count'] = len(active_artworks)

        return artist_dump_data, 200


    @admin_required
    def patch(self, artist_id):
        artist = Artist.query.get_or_404(artist_id, description=f"Artist with ID {artist_id} not found.")

        json_data = request.get_json()
        if not json_data:
            return {"message": "No input data provided"}, 400
        
        is_active_in_payload = json_data.get('is_active')

        try:
            updated_artist = artist_schema.load(
                json_data,
                instance=artist,
                partial=True,
                session=db.session
            )
        except ValidationError as err:
            return {"message": "Validation errors", "errors": err.messages}, 400

        try:
            if is_active_in_payload is False and artist.is_active is True:
                current_app.logger.info(f"Artist {artist.id} is being deactivated. Deactivating associated artworks.")
                for artwork_item in artist.artworks:
                    artwork_item.is_active = False
                    current_app.logger.info(f"Deactivated artwork {artwork_item.id} for artist {artist.id}")
            

            db.session.commit()
            refreshed_artist = Artist.query.options(selectinload(Artist.artworks)).get(artist_id)
            return artist_schema.dump(refreshed_artist), 200
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error updating artist {artist_id}: {e}", exc_info=True)
            abort(500, message="An error occurred while updating the artist.")

    @admin_required
    def delete(self, artist_id):
        artist = Artist.query.get_or_404(artist_id, description=f"Artist with ID {artist_id} not found.")
        try:
            db.session.delete(artist)
            db.session.commit()
            return '', 204
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error deleting artist {artist_id}: {e}", exc_info=True)
            abort(500, message="An error occurred while deleting the artist.")


artist_api.add_resource(ArtistList, '/')
artist_api.add_resource(ArtistDetail, '/<string:artist_id>')

# === ./app/resources/order.py ===
# === ./app/resources/order.py ===

from flask import request, Blueprint, jsonify, current_app
from flask_restful import Resource, Api, abort
from marshmallow import fields, Schema, ValidationError, validate
from sqlalchemy.orm import joinedload
from decimal import Decimal
import json
from datetime import datetime

from .. import db, ma
from ..models import Order, OrderItem, User, Cart, Artwork, CartItem, Artist, PaymentTransaction, DeliveryOption
from ..schemas import order_schema, orders_schema # delivery_option_schema not directly used for input here

from flask_jwt_extended import jwt_required, get_jwt_identity
from ..utils.daraja_client import initiate_stk_push

order_bp = Blueprint('orders', __name__)
order_api = Api(order_bp)

class CheckoutInputSchema(ma.Schema):
    phone_number = fields.Str(
        required=True,
        validate=validate.Regexp(
            r'^254\d{9}$',
            error="Phone number must be 12 digits and start with 254 (e.g., 2547XXXXXXXX)."
        )
    )
    delivery_option_id = fields.Str(required=True) # ID of the chosen DeliveryOption
    # delivery_address = fields.Str(required=False, allow_none=True) # Future: If allowing custom address different from user.address

checkout_input_schema = CheckoutInputSchema()

class OrderList(Resource):
    @jwt_required()
    def get(self):
        user_id = get_jwt_identity()
        user_orders = Order.query.options(
            joinedload(Order.items).options(
                joinedload(OrderItem.artwork).joinedload(Artwork.artist)
            ),
            joinedload(Order.delivery_option_details) # Eager load delivery option details with the order
        ).filter_by(user_id=user_id).order_by(Order.created_at.desc()).all()
        return orders_schema.dump(user_orders), 200

    @jwt_required()
    def post(self): # This is the STK Initiation endpoint
        user_id = get_jwt_identity()
        current_user = User.query.get(user_id)
        if not current_user:
            abort(401, message="User not found or invalid token.")

        json_data = request.get_json()
        if not json_data:
            abort(400, message="Missing checkout data (e.g., phone_number, delivery_option_id).")
        try:
            checkout_data = checkout_input_schema.load(json_data)
        except ValidationError as err:
            abort(400, message=err.messages)

        phone_number = checkout_data['phone_number']
        selected_delivery_option_id = checkout_data['delivery_option_id']
        # custom_delivery_address = checkout_data.get('delivery_address') # If implemented for custom address

        cart = Cart.query.options(
            joinedload(Cart.items).joinedload(CartItem.artwork) # Ensure artwork is loaded with cart items
        ).filter_by(user_id=user_id).first()
        
        if not cart or not cart.items:
            abort(400, message="Your cart is empty.")

        # Fetch the selected delivery option
        delivery_option = DeliveryOption.query.get(selected_delivery_option_id)
        if not delivery_option or not delivery_option.active:
            abort(400, message="Invalid or inactive delivery option selected.")
        
        applied_delivery_fee = delivery_option.price

        # Recalculate cart subtotal and prepare item snapshot
        cart_subtotal_decimal = Decimal('0.0')
        item_details_for_transaction_snapshot = []
        
        for item in cart.items:
            if not item.artwork: 
                current_app.logger.error(f"Critical: Artwork data missing for cart item {item.id} during checkout. Cart ID: {cart.id}")
                abort(500, message="Error processing cart. An artwork is missing details.")
            
            if item.artwork.stock_quantity < item.quantity:
                abort(400, message=f"Insufficient stock for '{item.artwork.name}'. Available: {item.artwork.stock_quantity}, Requested: {item.quantity}")
            
            cart_subtotal_decimal += Decimal(item.artwork.price) * Decimal(item.quantity)
            item_details_for_transaction_snapshot.append({
                'artwork_id': item.artwork.id,
                'name': item.artwork.name,
                'quantity': item.quantity,
                'price_at_purchase': str(item.artwork.price) 
            })
        
        if cart_subtotal_decimal < Decimal('0.0'): # Should ideally be >= 0
            abort(400, message="Cart subtotal cannot be negative.")
        
        # Grand total for payment
        grand_total_for_payment = cart_subtotal_decimal + applied_delivery_fee
        if grand_total_for_payment <= Decimal('0.0'): # Mpesa STK needs > 0
            abort(400, message="Total amount for payment (including delivery) must be greater than zero.")


        # Create PaymentTransaction record
        transaction = PaymentTransaction(
            user_id=user_id,
            cart_id=cart.id,
            amount=grand_total_for_payment, 
            phone_number=phone_number,
            status='pending_stk_initiation',
            _cart_items_snapshot=json.dumps(item_details_for_transaction_snapshot),
            selected_delivery_option_id=selected_delivery_option_id,
            applied_delivery_fee=applied_delivery_fee
        )
        try:
            db.session.add(transaction)
            db.session.commit() # Commit to get transaction.id
            current_app.logger.info(f"Created PaymentTransaction {transaction.id} for user {user_id}, cart {cart.id}, amount {grand_total_for_payment} (subtotal: {cart_subtotal_decimal}, delivery: {applied_delivery_fee})")
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Failed to create PaymentTransaction for user {user_id}: {e}", exc_info=True)
            abort(500, message="Error preparing payment. Please try again.")

        daraja_account_ref = transaction.id 
        amount_for_daraja = int(round(float(grand_total_for_payment))) # Daraja STK usually wants whole number

        stk_response, status_code = initiate_stk_push(
            phone_number=phone_number,
            amount=amount_for_daraja,
            order_id=daraja_account_ref, 
            description=f"Artistry Haven Order {transaction.id[:8]}"
        )

        if status_code >= 400 or str(stk_response.get("ResponseCode", "1")) != "0":
            error_msg = stk_response.get("errorMessage", stk_response.get("ResponseDescription", "Failed to initiate STK push."))
            current_app.logger.error(f"STK Push Initiation Failed for user {user_id}, Transaction {transaction.id}: Code {stk_response.get('ResponseCode', 'N/A')}, Desc: {error_msg}")
            transaction.status = 'failed_stk_initiation'
            transaction.daraja_response_description = error_msg
            db.session.commit()
            abort(status_code if status_code >= 400 else 500, message=error_msg)

        checkout_request_id_from_daraja = stk_response.get('CheckoutRequestID')
        if not checkout_request_id_from_daraja:
            current_app.logger.error(f"STK Push initiated but CheckoutRequestID missing. User: {user_id}, Transaction: {transaction.id}")
            transaction.status = 'failed_stk_missing_id'
            transaction.daraja_response_description = "CheckoutRequestID missing from Daraja response."
            db.session.commit()
            abort(500, message="Payment initiation incomplete. Please contact support if debited.")
        
        transaction.checkout_request_id = checkout_request_id_from_daraja
        transaction.status = 'pending_confirmation' 
        transaction.daraja_response_description = stk_response.get("ResponseDescription")
        db.session.commit()

        current_app.logger.info(f"STK Push successful for Transaction {transaction.id}. Daraja CheckoutRequestID: {checkout_request_id_from_daraja}")

        return {
            "message": "STK Push initiated successfully. Please check your phone to authorize payment.",
            "CheckoutRequestID": checkout_request_id_from_daraja,
            "transaction_id": transaction.id, 
            "ResponseDescription": stk_response.get("ResponseDescription", "Success")
        }, 200

class OrderDetail(Resource):
    @jwt_required()
    def get(self, order_id):
        user_id = get_jwt_identity()
        order = Order.query.options(
            joinedload(Order.items).options(
                joinedload(OrderItem.artwork).joinedload(Artwork.artist)
            ),
            joinedload(Order.delivery_option_details) # Eager load delivery option details
        ).filter_by(id=order_id, user_id=user_id).first_or_404(
            description=f"Order with ID {order_id} not found or does not belong to user."
        )
        return order_schema.dump(order), 200

class PaymentStatus(Resource):
    @jwt_required()
    def get(self, checkout_request_id_from_url):
        user_id = get_jwt_identity()
        transaction = PaymentTransaction.query.filter_by(
            checkout_request_id=checkout_request_id_from_url,
            user_id=user_id
        ).first()

        if not transaction:
            current_app.logger.warning(f"PaymentStatus GET: Transaction not found for CRID {checkout_request_id_from_url} and user {user_id}")
            return {"status": "not_found", "message": "Transaction not found or still processing initial STK push."}, 404

        response_data = {
            "status": transaction.status,
            "checkout_request_id": transaction.checkout_request_id,
            "message": transaction.daraja_response_description or transaction.status.replace('_', ' ').title()
        }
        
        if transaction.status == 'successful' and transaction.order_record:
            response_data["order_id"] = transaction.order_record.id
        
        return response_data, 200

order_api.add_resource(OrderList, '/')
order_api.add_resource(OrderDetail, '/<string:order_id>') # Ensure string type hint for path param
order_api.add_resource(PaymentStatus, '/status/<string:checkout_request_id_from_url>') # Ensure string type hint

# === ./app/resources/delivery.py ===
# === ./app/resources/delivery.py ===

from flask import Blueprint
from flask_restful import Resource, Api, current_app

from ..models import DeliveryOption
# Corrected import names:
from ..schemas import delivery_options_schema_public, delivery_option_schema_public 

delivery_bp = Blueprint('delivery', __name__)
delivery_api = Api(delivery_bp)

class DeliveryOptionList(Resource):
    def get(self):
        """Fetches all active delivery options, ordered by sort_order then name."""
        try:
            options = DeliveryOption.query.filter_by(active=True).order_by(DeliveryOption.sort_order, DeliveryOption.name).all()
            # Use the imported schema
            return delivery_options_schema_public.dump(options), 200
        except Exception as e:
            current_app.logger.error(f"Error fetching delivery options: {e}")
            return {"message": "Could not retrieve delivery options"}, 500

# delivery_option_schema_public might not be used here if only list is exposed publicly
delivery_api.add_resource(DeliveryOptionList, '/options') # Route for GET /api/delivery/options

# === ./app/resources/admin_dashboard.py ===
from flask import Blueprint, jsonify, current_app
from flask_restful import Resource, Api
from sqlalchemy import func, extract
from datetime import datetime, timedelta
from decimal import Decimal

from .. import db
from ..models import Artwork, Artist, Order, OrderItem
from ..decorators import admin_required

admin_dashboard_bp = Blueprint('admin_dashboard', __name__)
admin_dashboard_api = Api(admin_dashboard_bp)

class AdminDashboardStats(Resource):
    @admin_required
    def get(self):
        try:
            total_artworks = db.session.query(func.count(Artwork.id)).scalar()
            active_artworks = db.session.query(func.count(Artwork.id)).filter(Artwork.is_active == True).scalar()
            
            total_artists = db.session.query(func.count(Artist.id)).scalar()
            active_artists = db.session.query(func.count(Artist.id)).filter(Artist.is_active == True).scalar()

            pending_orders_count = db.session.query(func.count(Order.id)).filter(Order.status == 'pending').scalar()
            paid_orders_count = db.session.query(func.count(Order.id)).filter(Order.status == 'paid').scalar()

            current_month = datetime.utcnow().month
            current_year = datetime.utcnow().year
            
            revenue_this_month = db.session.query(func.sum(Order.total_price))\
                .filter(
                    extract('month', Order.created_at) == current_month,
                    extract('year', Order.created_at) == current_year,
                    Order.status.in_(['paid', 'delivered', 'picked_up'])
                ).scalar() or Decimal('0.00')

            recent_orders = Order.query.order_by(Order.created_at.desc()).limit(5).all()
            
            sales_trend_data = []
            for i in range(5, -1, -1):
                month_date = datetime.utcnow() - timedelta(days=i*30)
                month_val = month_date.month
                year_val = month_date.year
                
                monthly_revenue = db.session.query(func.sum(Order.total_price))\
                    .filter(
                        extract('month', Order.created_at) == month_val,
                        extract('year', Order.created_at) == year_val,
                        Order.status.in_(['paid', 'delivered', 'picked_up'])
                    ).scalar() or Decimal('0.00')
                sales_trend_data.append({
                    "month": month_date.strftime("%b %Y"),
                    "revenue": float(monthly_revenue)
                })


            from ..schemas import orders_schema
            
            stats = {
                "total_artworks": total_artworks,
                "active_artworks": active_artworks,
                "total_artists": total_artists,
                "active_artists": active_artists,
                "pending_orders_count": pending_orders_count,
                "paid_orders_count": paid_orders_count,
                "revenue_this_month": str(revenue_this_month),
                "recent_orders": orders_schema.dump(recent_orders),
                "sales_trend": sales_trend_data
            }
            return jsonify(stats)

        except Exception as e:
            current_app.logger.error(f"Error fetching dashboard stats: {e}", exc_info=True)
            return {"message": "Error fetching dashboard statistics"}, 500

admin_dashboard_api.add_resource(AdminDashboardStats, '/stats')

# === ./app/resources/payment.py ===
# === ./app/resources/payment.py ===

from flask import request, Blueprint, jsonify, current_app
from flask_restful import Resource, Api, abort
from decimal import Decimal
import json

from .. import db
from ..models import Order, OrderItem, Artwork, Cart, CartItem, User, PaymentTransaction, DeliveryOption # Added DeliveryOption

payment_bp = Blueprint('payments', __name__)
payment_api = Api(payment_bp)

class DarajaCallback(Resource):
    def post(self):
        current_app.logger.info("--- Daraja Callback Received ---")
        try:
            callback_data = request.get_json()
            if not callback_data:
                current_app.logger.error("Daraja Callback: Received empty JSON body.")
                return {"ResultCode": 0, "ResultDesc": "Accepted empty body"}, 200
        except Exception as e:
            current_app.logger.error(f"Daraja Callback: Failed to parse JSON body: {e}. Raw data: {request.data}")
            return {"ResultCode": 0, "ResultDesc": "Accepted invalid JSON"}, 200

        current_app.logger.info(f"Daraja Callback - Raw Data: {json.dumps(callback_data)}")

        if 'Body' not in callback_data or 'stkCallback' not in callback_data['Body']:
            current_app.logger.error("Daraja Callback ERROR: Invalid format. Missing 'Body' or 'stkCallback'.")
            return {"ResultCode": 0, "ResultDesc": "Accepted format error"}, 200

        stk_callback = callback_data['Body']['stkCallback']
        result_code_from_daraja = str(stk_callback.get('ResultCode', '-1'))
        checkout_request_id = stk_callback.get('CheckoutRequestID')
        daraja_result_desc = stk_callback.get('ResultDesc', 'No ResultDesc from Daraja.')
        daraja_merchant_request_id = stk_callback.get('MerchantRequestID')

        current_app.logger.info(f"Daraja Callback - Processing: CRID: {checkout_request_id}, Daraja_MRID: {daraja_merchant_request_id}, ResultCode: {result_code_from_daraja}, ResultDesc: {daraja_result_desc}")

        if not checkout_request_id:
            current_app.logger.error("Daraja Callback ERROR: CheckoutRequestID missing from Daraja. Cannot process.")
            return {"ResultCode": 0, "ResultDesc": "Accepted missing CheckoutRequestID"}, 200
        
        transaction = PaymentTransaction.query.filter_by(checkout_request_id=checkout_request_id).first()

        if not transaction:
            current_app.logger.warning(f"Daraja Callback WARNING: PaymentTransaction for CRID {checkout_request_id} not found in DB. Daraja MerchantRequestID was {daraja_merchant_request_id}.")
            return {"ResultCode": 0, "ResultDesc": "Accepted, transaction not found by CRID"}, 200

        current_app.logger.info(f"Daraja Callback: Found internal PaymentTransaction {transaction.id} with status {transaction.status} for CRID {checkout_request_id}.")

        final_states = ['successful', 'failed_daraja', 'cancelled_by_user', 'failed_processing_error', 'failed_underpaid', 'failed_missing_receipt', 'failed_timeout']
        if transaction.status in final_states:
            current_app.logger.info(f"Daraja Callback INFO: Transaction {transaction.id} (CRID: {checkout_request_id}) already in a final state: {transaction.status}. Ignoring callback.")
            return {"ResultCode": 0, "ResultDesc": "Accepted, already processed"}, 200

        transaction.daraja_response_description = daraja_result_desc

        if result_code_from_daraja == "0":
            current_app.logger.info(f"Daraja Callback SUCCESS: Payment successful for Transaction {transaction.id} (CRID: {checkout_request_id}).")

            metadata_items = stk_callback.get('CallbackMetadata', {}).get('Item', [])
            metadata = {item['Name']: item.get('Value') for item in metadata_items if 'Name' in item and 'Value' in item}
            
            amount_paid_str = str(metadata.get('Amount', "0.00"))
            mpesa_receipt = metadata.get('MpesaReceiptNumber')
            
            current_app.logger.info(f"Transaction {transaction.id}: Amount Paid (Daraja): {amount_paid_str}, Expected: {transaction.amount}, M-Pesa Receipt: {mpesa_receipt}")

            if not mpesa_receipt:
                current_app.logger.error(f"Transaction {transaction.id}: MpesaReceiptNumber is MISSING from Daraja callback (ResultCode 0). Marking as processing error.")
                transaction.status = 'failed_missing_receipt'
                transaction.daraja_response_description = "MpesaReceiptNumber missing from successful Daraja callback."
                try:
                    db.session.commit()
                except Exception as e_commit:
                    db.session.rollback()
                    current_app.logger.error(f"Transaction {transaction.id}: DB Error committing 'failed_missing_receipt' status: {e_commit}")
                return {"ResultCode": 0, "ResultDesc": "Accepted, MpesaReceiptNumber missing"}, 200
            
            try:
                amount_paid_decimal = Decimal(amount_paid_str)
            except Exception as e_decimal:
                current_app.logger.error(f"Transaction {transaction.id}: Could not convert Daraja Amount '{amount_paid_str}' to Decimal: {e_decimal}. Marking as processing error.")
                transaction.status = 'failed_processing_error'
                transaction.daraja_response_description = f"Invalid amount format from Daraja: {amount_paid_str}"
                try:
                    db.session.commit()
                except Exception as e_commit:
                    db.session.rollback()
                    current_app.logger.error(f"Transaction {transaction.id}: DB Error committing status for invalid amount: {e_commit}")
                return {"ResultCode": 0, "ResultDesc": "Accepted, invalid amount format"}, 200

            if amount_paid_decimal < transaction.amount:
                current_app.logger.warning(f"Transaction {transaction.id}: Amount paid ({amount_paid_decimal}) is less than expected ({transaction.amount}). Marking as underpaid.")
                transaction.status = 'failed_underpaid'
                try:
                    db.session.commit()
                except Exception as e_commit:
                    db.session.rollback()
                    current_app.logger.error(f"Transaction {transaction.id}: DB Error committing 'failed_underpaid' status: {e_commit}")
            else:
                try:
                    user = User.query.get(transaction.user_id)
                    
                    chosen_delivery_option = DeliveryOption.query.get(transaction.selected_delivery_option_id)
                    shipping_addr = "Error: Delivery Option details not found."
                    if chosen_delivery_option:
                        if chosen_delivery_option.is_pickup:
                            shipping_addr = chosen_delivery_option.description or "In Store Pick Up: Dynamic Mall, Shop M90, CBD, Nairobi"
                        else:
                            shipping_addr = user.address if user and user.address else "Delivery Address Not Specified by User"
                            if not user.address and not chosen_delivery_option.is_pickup:
                                current_app.logger.warning(f"Transaction {transaction.id}: Delivery option chosen but user has no default address. Shipping address set to generic.")
                    else:
                        current_app.logger.error(f"Transaction {transaction.id}: selected_delivery_option_id {transaction.selected_delivery_option_id} did not resolve to a DeliveryOption.")
                        shipping_addr = user.address if user and user.address else "Default Pickup: Dynamic Mall, Shop M90, CBD"


                    items_to_order_snapshot = transaction.cart_items_snapshot
                    if not items_to_order_snapshot:
                        current_app.logger.error(f"Transaction {transaction.id}: Cart items snapshot missing. Cannot create order.")
                        raise ValueError("Cart items snapshot missing for order creation.")

                    new_order = Order(
                        user_id=transaction.user_id,
                        total_price=transaction.amount,
                        status='paid', 
                        payment_gateway_ref=mpesa_receipt,
                        delivery_option_id=transaction.selected_delivery_option_id,
                        delivery_fee=transaction.applied_delivery_fee or Decimal('0.00'),
                        shipping_address=shipping_addr,
                        billing_address=user.address if user and user.address else shipping_addr, # Default billing to user address or shipping
                        payment_transaction_id=transaction.id
                    )
                    db.session.add(new_order)
                    db.session.flush() 
                    current_app.logger.info(f"Transaction {transaction.id}: Order {new_order.id} flushed. Populating items.")

                    for item_data in items_to_order_snapshot:
                        artwork = db.session.query(Artwork).filter_by(id=item_data['artwork_id']).with_for_update().first()
                        if not artwork:
                            current_app.logger.error(f"Transaction {transaction.id}, Order {new_order.id}: Artwork ID {item_data['artwork_id']} not found.")
                            raise ValueError(f"Artwork ID {item_data['artwork_id']} not found.")
                        
                        item_quantity = int(item_data['quantity'])
                        if artwork.stock_quantity < item_quantity:
                            current_app.logger.error(f"Transaction {transaction.id}, Order {new_order.id}: Insufficient stock for {artwork.name} (ID: {artwork.id}).")
                            raise ValueError(f"Insufficient stock for {artwork.name}. Available: {artwork.stock_quantity}, Requested: {item_quantity}.")
                        
                        artwork.stock_quantity -= item_quantity
                        current_app.logger.info(f"Transaction {transaction.id}, Order {new_order.id}: Artwork {artwork.id} stock updated to {artwork.stock_quantity}.")
                        
                        order_item = OrderItem(
                            order_id=new_order.id,
                            artwork_id=item_data['artwork_id'],
                            quantity=item_quantity,
                            price_at_purchase=Decimal(str(item_data['price_at_purchase']))
                        )
                        db.session.add(order_item)
                    
                    current_app.logger.info(f"Transaction {transaction.id}, Order {new_order.id}: All order items added to session.")

                    if transaction.cart_id:
                        deleted_count = CartItem.query.filter_by(cart_id=transaction.cart_id).delete(synchronize_session='fetch')
                        current_app.logger.info(f"Transaction {transaction.id}: Deleted {deleted_count} items from Cart {transaction.cart_id} for Order {new_order.id}")
                    
                    transaction.status = 'successful'
                    db.session.commit()
                    current_app.logger.info(f"Order {new_order.id} created successfully and committed for Transaction {transaction.id} (CRID: {checkout_request_id}).")

                except ValueError as ve:
                    db.session.rollback()
                    current_app.logger.error(f"Transaction {transaction.id}: ValueError during order creation: {ve}")
                    try:
                        txn_to_update = db.session.merge(transaction) if transaction in db.session.dirty else PaymentTransaction.query.get(transaction.id)
                        if txn_to_update:
                           txn_to_update.status = 'failed_processing_error' 
                           txn_to_update.daraja_response_description = f"Order Creation Error: {str(ve)}"
                           db.session.commit()
                        else:
                           current_app.logger.error(f"Transaction {transaction.id}: Could not find transaction to mark as failed_processing_error after ValueError.")
                    except Exception as inner_e:
                        db.session.rollback()
                        current_app.logger.error(f"Transaction {transaction.id}: FAILED to update status to 'failed_processing_error' after ValueError. DB Error: {inner_e}")
                except Exception as e:
                    db.session.rollback()
                    current_app.logger.error(f"Transaction {transaction.id}: Unexpected Exception during order creation: {e}", exc_info=True)
                    try:
                        txn_to_update = db.session.merge(transaction) if transaction in db.session.dirty else PaymentTransaction.query.get(transaction.id)
                        if txn_to_update:
                            txn_to_update.status = 'failed_processing_error'
                            txn_to_update.daraja_response_description = f"Unexpected Order Creation Error: {str(e)}"
                            db.session.commit()
                        else:
                           current_app.logger.error(f"Transaction {transaction.id}: Could not find transaction to mark as failed_processing_error after unexpected Exception.")
                    except Exception as update_err:
                        db.session.rollback()
                        current_app.logger.error(f"Transaction {transaction.id}: Further error when trying to mark as 'failed_processing_error' after unexpected Exception: {update_err}", exc_info=True)
        else: 
            current_app.logger.warning(f"Transaction {transaction.id} (CRID: {checkout_request_id}): Payment reported as FAILED/CANCELLED by Daraja. ResultCode: {result_code_from_daraja}, Desc: {daraja_result_desc}")
            if result_code_from_daraja == "1" or result_code_from_daraja == "1032": 
                transaction.status = 'cancelled_by_user'
            elif result_code_from_daraja == "1037": 
                transaction.status = 'failed_timeout'
            else: 
                transaction.status = 'failed_daraja'
            
            try:
                db.session.commit()
                current_app.logger.info(f"Transaction {transaction.id}: Status updated to {transaction.status} and committed.")
            except Exception as e_commit:
                db.session.rollback()
                current_app.logger.error(f"Transaction {transaction.id}: DB Error committing failure status '{transaction.status}': {e_commit}")

        return {"ResultCode": 0, "ResultDesc": "Accepted"}, 200

payment_api.add_resource(DarajaCallback, '/callback')

# === ./app/resources/auth.py ===
from flask import request, jsonify, Blueprint
from flask_restful import Resource, Api
from marshmallow import ValidationError

from .. import db, bcrypt
from ..models import User
from ..schemas import user_schema

from flask_jwt_extended import create_access_token, jwt_required, get_jwt, get_jwt_identity
from .. import BLOCKLIST

auth_bp = Blueprint('auth', __name__)
auth_api = Api(auth_bp)


class UserRegistration(Resource):
    def post(self):
        """
        Handles new user registration.
        """
        json_data = request.get_json()
        if not json_data:
            return {"message": "No input data provided"}, 400

        try:
            if 'password' not in json_data:
                 return {"message": {"password": ["Password is required for registration."]}}, 400
            
            user_instance = user_schema.load(json_data, session=db.session, unknown='EXCLUDE')

        except ValidationError as err:
            return {"message": "Validation errors", "errors": err.messages}, 400
        
        if User.query.filter_by(email=user_instance.email).first():
            return {"message": "User with this email already exists"}, 409

        user_instance.set_password(json_data['password'])

        try:
            db.session.add(user_instance)
            db.session.commit()
            return {
                "message": "User created successfully",
                "user": user_schema.dump(user_instance)
            }, 201
        except Exception as e:
            db.session.rollback()
            print(f"Error during registration: {e}")
            return {"message": "An error occurred during registration."}, 500


class UserLogin(Resource):
    def post(self):
        json_data = request.get_json()
        if not json_data:
            return {"message": "No input data provided"}, 400

        email = json_data.get('email')
        password = json_data.get('password')

        if not email or not password:
            return {"message": "Email and password are required"}, 400

        user = User.query.filter_by(email=email).first()

        if user and user.check_password(password):
            access_token = create_access_token(identity=user.id)
            return {
                "message": "Login successful",
                "access_token": access_token,
                "user": {
                    "id": user.id,
                    "email": user.email,
                    "name": user.name,
                    "is_admin": user.is_admin 
                }
            }, 200
        else:
            return {"message": "Invalid credentials"}, 401


class UserLogout(Resource):
    @jwt_required()
    def post(self):
        jti = get_jwt()["jti"]
        BLOCKLIST.add(jti)
        return {"message": "Successfully logged out"}, 200

class UserProfile(Resource):
    @jwt_required()
    def get(self):
        current_user_id = get_jwt_identity()
        user = User.query.get(current_user_id)
        if not user:
            return {"message": "User not found"}, 404
        return user_schema.dump(user), 200


auth_api.add_resource(UserRegistration, '/signup')
auth_api.add_resource(UserLogin, '/login')
auth_api.add_resource(UserLogout, '/logout')
auth_api.add_resource(UserProfile, '/me')

# === ./app/resources/artwork.py ===
# === ./app/resources/artwork.py ===
from flask import request, Blueprint, jsonify, current_app
from flask_restful import Resource, Api, abort
from marshmallow import ValidationError
from sqlalchemy.orm import joinedload
from flask_jwt_extended import jwt_required, get_jwt_identity, get_jwt
from werkzeug.utils import secure_filename
import os
import uuid

from .. import db
from ..models import Artwork, Artist, User
# from ..schemas import artwork_schema, artworks_schema, ArtworkSchema # OLD WAY
from .. import schemas  # NEW WAY: Import the module itself
from ..decorators import admin_required

artwork_bp = Blueprint('artworks', __name__)
artwork_api = Api(artwork_bp)

# Access schemas via the module:
# artwork_schema_instance = schemas.artwork_schema
# artworks_schema_instance = schemas.artworks_schema
# ArtworkSchema_class = schemas.ArtworkSchema 
# It's better to use the instances directly if they are defined in schemas.py

def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in current_app.config['ALLOWED_EXTENSIONS']

def save_artwork_image(image_file):
    if image_file and allowed_file(image_file.filename):
        filename = secure_filename(image_file.filename)
        unique_id = uuid.uuid4().hex
        file_ext = filename.rsplit('.', 1)[1].lower()
        unique_filename = f"art_{unique_id}.{file_ext}"
        
        upload_folder = current_app.config['UPLOAD_FOLDER']
        if not os.path.exists(upload_folder):
            os.makedirs(upload_folder)
            
        file_path = os.path.join(upload_folder, unique_filename)
        image_file.save(file_path)
        relative_path = os.path.join(os.path.basename(upload_folder), unique_filename)
        return relative_path.replace("\\", "/")
    return None


class ArtworkList(Resource):
    def get(self):
        is_admin_request = False
        try:
            jwt_payload = get_jwt() 
            if jwt_payload:
                user_id = get_jwt_identity()
                user = User.query.get(user_id)
                if user and user.is_admin:
                    is_admin_request = True
        except Exception:
            pass

        if is_admin_request:
            current_app.logger.info("Admin request: Fetching all artworks for ArtworkList.")
            artworks = Artwork.query.options(joinedload(Artwork.artist)).order_by(Artwork.created_at.desc()).all()
        else:
            artworks = Artwork.query.options(joinedload(Artwork.artist))\
                .join(Artist, Artwork.artist_id == Artist.id)\
                .filter(Artwork.is_active == True, Artist.is_active == True)\
                .order_by(Artwork.created_at.desc()).all()
        
        return schemas.artworks_schema.dump(artworks), 200 # Use schemas.artworks_schema

    @admin_required
    def post(self):
        form_data = request.form.to_dict()
        image_file = request.files.get('image_file')

        if 'is_active' not in form_data:
            form_data['is_active'] = True
        else:
            form_data['is_active'] = str(form_data['is_active']).lower() in ['true', 'on', '1', 'yes']

        artist_id_val = form_data.get('artist_id')
        if artist_id_val:
            artist = Artist.query.get(artist_id_val)
            if not artist:
                abort(400, message=f"Artist with ID {artist_id_val} not found.")
        else:
             abort(400, message="artist_id is required.")

        uploaded_image_path = None
        if image_file:
            uploaded_image_path = save_artwork_image(image_file)
            if uploaded_image_path:
                form_data['image_url'] = uploaded_image_path
            else:
                return {"message": "Invalid image file or error during upload."}, 400
        elif 'image_url' in form_data and form_data['image_url']:
            pass
        else:
            if not image_file:
                 return {"message": "image_file is required for new artworks."}, 400
            form_data['image_url'] = None 

        try:
            # Use schemas.artwork_schema here
            new_artwork_instance = schemas.artwork_schema.load(form_data, session=db.session)
        except ValidationError as err:
            return {"message": "Validation errors", "errors": err.messages}, 400
        except Exception as e:
             current_app.logger.error(f"Unexpected error during artwork schema load: {e}", exc_info=True)
             abort(500, message="An internal error occurred during data processing.")

        try:
            db.session.add(new_artwork_instance)
            db.session.commit()
            return schemas.artwork_schema.dump(new_artwork_instance), 201 # Use schemas.artwork_schema
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error creating artwork in DB: {e}", exc_info=True)
            if 'foreign key constraint fails' in str(e).lower() and 'artist_id' in str(e).lower():
                 abort(400, message="Invalid artist_id provided.")
            abort(500, message="An error occurred while saving the artwork to the database.")


class ArtworkDetail(Resource):
    def get(self, artwork_id):
        is_admin_request = False
        try:
            jwt_payload = get_jwt()
            if jwt_payload:
                user_id = get_jwt_identity()
                user = User.query.get(user_id)
                if user and user.is_admin:
                    is_admin_request = True
        except Exception:
            pass

        query = Artwork.query.options(joinedload(Artwork.artist))
        artwork = query.get(artwork_id)

        if not artwork:
            return {"message": f"Artwork with ID {artwork_id} not found."}, 404

        if not is_admin_request:
            if not artwork.is_active or (artwork.artist and not artwork.artist.is_active):
                return {"message": f"Artwork with ID {artwork_id} not found or not active."}, 404
        
        return schemas.artwork_schema.dump(artwork), 200 # Use schemas.artwork_schema

    @admin_required
    def patch(self, artwork_id):
        artwork = Artwork.query.get_or_404(
            artwork_id, description=f"Artwork with ID {artwork_id} not found."
        )

        form_data = request.form.to_dict()
        image_file = request.files.get('image_file')
        
        if 'is_active' in form_data:
            form_data['is_active'] = str(form_data['is_active']).lower() in ['true', 'on', '1', 'yes']

        new_artist_id = form_data.get('artist_id')
        if new_artist_id and new_artist_id != artwork.artist_id:
            artist = Artist.query.get(new_artist_id)
            if not artist:
                abort(400, message=f"New artist with ID {new_artist_id} not found.")

        if image_file:
            old_image_path_abs = os.path.join(current_app.config['MEDIA_FOLDER'], artwork.image_url) if artwork.image_url else None
            
            uploaded_image_path = save_artwork_image(image_file)
            if uploaded_image_path:
                form_data['image_url'] = uploaded_image_path
                if old_image_path_abs and os.path.exists(old_image_path_abs) and artwork.image_url != uploaded_image_path:
                    try:
                        os.remove(old_image_path_abs)
                        current_app.logger.info(f"Deleted old image: {old_image_path_abs}")
                    except OSError as e:
                        current_app.logger.error(f"Error deleting old image {old_image_path_abs}: {e}")
            else:
                return {"message": "Invalid image file or error during upload for update."}, 400
        elif 'image_url' in form_data and form_data['image_url'] == "" : 
            if artwork.image_url:
                old_image_path_abs = os.path.join(current_app.config['MEDIA_FOLDER'], artwork.image_url)
                if os.path.exists(old_image_path_abs):
                    try: 
                        os.remove(old_image_path_abs)
                        current_app.logger.info(f"Deleted image {old_image_path_abs} as image_url was set to empty.")
                    except OSError as e:
                        current_app.logger.error(f"Error deleting image {old_image_path_abs}: {e}")
            form_data['image_url'] = None
        elif 'image_url' in form_data :
            pass

        try:
            # Use schemas.artwork_schema
            updated_artwork = schemas.artwork_schema.load(
                form_data,
                instance=artwork,
                partial=True, 
                session=db.session
            )
        except ValidationError as err:
             return {"message": "Validation errors", "errors": err.messages}, 400

        try:
            db.session.commit()
            refreshed_artwork = Artwork.query.options(joinedload(Artwork.artist)).get(artwork.id)
            return schemas.artwork_schema.dump(refreshed_artwork), 200 # Use schemas.artwork_schema
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error updating artwork {artwork_id}: {e}", exc_info=True)
            if 'foreign key constraint fails' in str(e).lower() and 'artist_id' in str(e).lower():
                 abort(400, message="Invalid artist_id provided for update.")
            abort(500, message="An error occurred while updating the artwork.")

    @admin_required
    def delete(self, artwork_id):
        artwork = Artwork.query.get_or_404(
             artwork_id, description=f"Artwork with ID {artwork_id} not found."
        )
        
        if artwork.image_url:
            image_full_path = os.path.join(current_app.config['MEDIA_FOLDER'], artwork.image_url)
            if os.path.exists(image_full_path):
                try:
                    os.remove(image_full_path)
                    current_app.logger.info(f"Deleted image file {image_full_path} for artwork {artwork_id}")
                except OSError as e:
                    current_app.logger.error(f"Error deleting image file {image_full_path}: {e}")

        try:
            db.session.delete(artwork)
            db.session.commit()
            return '', 204
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error deleting artwork {artwork_id}: {e}", exc_info=True)
            abort(500, message="An error occurred while deleting the artwork.")

artwork_api.add_resource(ArtworkList, '/')
artwork_api.add_resource(ArtworkDetail, '/<string:artwork_id>')

# === ./app/utils/daraja_client.py ===
import base64
import requests
from datetime import datetime
from flask import current_app, jsonify
import time

token_cache = {}

def get_daraja_access_token():
    """Fetches a new Daraja access token or returns a cached one."""
    global token_cache
    current_time = time.time()

    if token_cache and token_cache.get('expires_at', 0) > current_time:
        print("DEBUG: Using cached Daraja token")
        return token_cache['token']

    print("DEBUG: Fetching new Daraja token")
    consumer_key = current_app.config['DARAJA_CONSUMER_KEY']
    consumer_secret = current_app.config['DARAJA_CONSUMER_SECRET']
    auth_url = current_app.config['DARAJA_AUTH_URL']

    if not consumer_key or not consumer_secret:
        print("ERROR: Daraja consumer key or secret not configured.")
        return None

    try:
        response = requests.get(auth_url, auth=(consumer_key, consumer_secret))
        response.raise_for_status()
        token_data = response.json()

        expires_in = int(token_data.get('expires_in', 3599))
        token_cache = {
            'token': token_data['access_token'],
            'expires_at': current_time + expires_in - 60
        }
        print("DEBUG: Fetched and cached new Daraja token.")
        return token_data['access_token']
    except requests.exceptions.RequestException as e:
        print(f"ERROR: Failed to get Daraja access token: {e}")
        print(f"Response status: {response.status_code if 'response' in locals() else 'N/A'}")
        print(f"Response text: {response.text if 'response' in locals() else 'N/A'}")
        return None
    except KeyError:
        print(f"ERROR: 'access_token' or 'expires_in' not found in Daraja auth response: {token_data}")
        return None


def generate_daraja_password(shortcode, passkey, timestamp):
    """Generates the Base64 encoded password for Daraja API calls."""
    password_str = f"{shortcode}{passkey}{timestamp}"
    password_bytes = password_str.encode('utf-8')
    encoded_password = base64.b64encode(password_bytes).decode('utf-8')
    return encoded_password


def initiate_stk_push(phone_number, amount, order_id, description="Shoply Purchase"):
    """Initiates an STK Push request."""
    access_token = get_daraja_access_token()
    if not access_token:
        return {"error": "Failed to obtain Daraja access token"}, 500

    stk_push_url = current_app.config['DARAJA_STK_PUSH_URL']
    shortcode = current_app.config['DARAJA_SHORTCODE']
    passkey = current_app.config['DARAJA_PASSKEY']
    callback_url = current_app.config['DARAJA_CALLBACK_URL']
    transaction_type = current_app.config['DARAJA_TRANSACTION_TYPE']

    amount = int(round(float(amount)))
    if not phone_number.startswith('254') or not phone_number.isdigit() or len(phone_number) != 12:
         print(f"ERROR: Invalid phone number format: {phone_number}")
         return {"error": "Invalid phone number format. Use 254XXXXXXXXX."}, 400

    timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
    password = generate_daraja_password(shortcode, passkey, timestamp)

    headers = {
        'Authorization': f'Bearer {access_token}',
        'Content-Type': 'application/json'
    }

    payload = {
        "BusinessShortCode": shortcode,
        "Password": password,
        "Timestamp": timestamp,
        "TransactionType": transaction_type,
        "Amount": amount,
        "PartyA": phone_number,
        "PartyB": shortcode,
        "PhoneNumber": phone_number,
        "CallBackURL": callback_url,
        "AccountReference": str(order_id),
        "TransactionDesc": description
    }

    print(f"DEBUG: Initiating STK Push with payload: {payload}")

    try:
        response = requests.post(stk_push_url, json=payload, headers=headers)
        response.raise_for_status()
        response_data = response.json()
        print(f"DEBUG: STK Push Response: {response_data}")
        return response_data, 200
    except requests.exceptions.RequestException as e:
        print(f"ERROR: STK Push request failed: {e}")
        print(f"Response status: {response.status_code if 'response' in locals() else 'N/A'}")
        print(f"Response text: {response.text if 'response' in locals() else 'N/A'}")
        error_message = "Failed to initiate payment."
        try:
            error_details = response.json()
            error_message = error_details.get('errorMessage', error_message)
        except:
            pass
        return {"error": error_message}, getattr(response, 'status_code', 500)
    except Exception as e:
        print(f"ERROR: Unexpected error during STK Push: {e}")
        return {"error": "An unexpected error occurred during payment initiation."}, 500

# === ./media/artwork_images/rename.py ===
import os

def get_available_filename(base_name, extension):
    """Find the next available filename like art1.jpg, art2.jpg, etc."""
    counter = 1
    while True:
        new_name = f"{base_name}{counter}.{extension}"
        if not os.path.exists(new_name):
            return new_name
        counter += 1

def rename_images():
    images = [f for f in os.listdir('.') if f.lower().endswith('.jpg')]
    images.sort()

    for filename in images:
        new_name = get_available_filename("art", "jpg")
        os.rename(filename, new_name)
        print(f"Renamed '{filename}' to '{new_name}'")

if __name__ == "__main__":
    rename_images()
